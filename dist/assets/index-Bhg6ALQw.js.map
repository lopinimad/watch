{"version":3,"mappings":"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CT,EACAC,OAAQ,CACNZ,GAAYQ,CAAK,EACjB,MAAMK,EAAgB5B,GAAsBuB,CAAK,EACjDlD,UAAOkD,EAAM/B,KAAO,EAAE,EAAI,CAACoC,EAAeL,CAAK,EACxCK,CACT,EAEJ,48j3BC7HaC,GAAU,CACrBC,MACAC,MACA,QAASC,GACTC,MACAC,MACAC,MACA,QAASC,GACTC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,UACAC,SACAC,OACAC,UACAC,WACAC,GACAC,MACAC,MACAC,MACAC,MACAC,MACAC,OACAC,MACA,QAASC,GACT,QAASC,GACTC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAtH,MACAuH,MACAC,MACAC,MACAC,MACA,UAAWC,GACXC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,KACF,EClGMC,GAAgB,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,EAOnDC,GAA0C,CAC9CrC,GAAI,KACJmC,GAAI,IACN,EAGMG,GAAiC,CACrC,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OAAO,EAUHC,GAA6C,CACjDpC,OAAQ,CACNqC,KAAM,SACNhH,KAAM,SACNiH,WAAY,iBAEdrC,MAAO,CACLoC,KAAM,MACNhH,KAAM,MACNiH,WAAY,eAEdpC,IAAK,CACHmC,KAAM,MACNhH,KAAM,aACNiH,WAAY,OAEdnC,OAAQ,CACNkC,KAAM,SACNhH,KAAM,SACNiH,WAAY,aAEd3B,IAAK,CACH0B,KAAM,MACNhH,KAAM,YACNiH,WAAY,aAEdlC,QAAS,CACPiC,KAAM,UACNhH,KAAM,qBACNiH,WAAY,eAEhB,EAEA,SAASC,GAAqBC,EAA0B,CAEtD,OADIA,EAASC,SAAS,GAAG,GACrBD,EAASxF,SAAW,EAAUwF,EAEhCL,GAAqBO,KAAMtH,GAAMA,EAAEuH,WAAW,GAAGH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","names":["MWMediaType","updateId","useBookmarkStore","create","persist","immer","set","bookmarks","updateQueue","removeBookmark","id","s","push","toString","action","tmdbId","addBookmark","meta","type","title","year","releaseYear","poster","updatedAt","Date","now","replaceBookmarks","items","clear","clearUpdateQueue","removeUpdateItem","filter","v","name","storeCallbacks","stores","initializeOldStores","store","internal","Object","values","versions","sort","a","b","version","data","_raw","dataVersion","relevantVersions","mostRecentData","migrate","localStorage","setItem","key","JSON","stringify","err","console","error","length","save","buildStorageObject","latestVersion","onChange","cb","destroy","makeRaw","getRaw","item","getItem","parse","withVersion","forEach","window","structuredClone","get","assertStore","versionListSorted","i","arr","Error","migrations","pop","createVersionedStore","_data","setKey","addVersion","ver","build","storageObject","locales","en","ca","caVl","cs","da","de","deCh","fr","it","nl","pl","tr","vi","zh","he","sv","pirate","kitty","uwu","minion","futhark","lv","th","ne","ar","es","et","tok","hi","ptbr","ptpt","uk","bg","bn","el","fa","gu","ja","ko","sl","ta","zhhant","is","ru","gl","pa","ro","fi","nv","languageOrder","countryPriority","defaultLanguageCodes","extraLanguages","code","nativeName","populateLanguageCode","language","includes","find","startsWith","getPrettyLanguageNameFromLocale","locale","tag","getTag","iso6393To1","lang","Description","region","regionText","sortLangCodes","langCodes","languagesOrder","reverse","langOrderA","findIndex","langOrderB","localeCompare","getCountryCodeForLocale","output","Subtag","countryLanguages","getLanguage","_err","priority","iso639_1","toLowerCase","countries","prioritizedCountry","code_2","regionSubtag","regionCode","c","code_3","getLocaleInfo","realLocale","document","body","style","wordSpacing","extraLang","extras","script","extraStringified","map","join","parts","langtag","isRtl","direction","undefined","getTmdbLanguageCode","keys","defaultCode","toUpperCase","resources","fromEntries","entries","entry","translation","i18n","use","initReactI18next","init","fallbackLng","interpolation","escapeValue","appLanguageOptions","langObj","JW_API_BASE","JW_IMAGE_BASE","mediaTypeToJW","MOVIE","SERIES","JWMediaToMediaType","formatJWMeta","media","season","object_type","seasons","season_number","number","original_release_year","replace","seasonData","episodes","episode_number","APP_VERSION","import","DISCORD_LINK","GITHUB_LINK","TWITTER_LINK","BACKEND_URL","env","TMDB_READ_API_KEY","ONBOARDING_CHROME_EXTENSION_INSTALL_LINK","ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK","ONBOARDING_PROXY_INSTALL_LINK","DMCA_EMAIL","CORS_PROXY_URL","M3U8_PROXY_URL","NORMAL_ROUTER","DISALLOWED_IDS","TURNSTILE_KEY","CDN_REPLACEMENTS","HAS_ONBOARDING","ALLOW_AUTOPLAY","ALLOW_FEBBOX_KEY","ALLOW_REAL_DEBRID_KEY","SHOW_AD","AD_CONTENT_URL","TRACK_SCRIPT","coerceUndefined","value","getKeyValue","windowValue","__CONFIG__","getKey","defaultString","conf","PROXY_URLS","split","trim","M3U8_PROXY_URLS","useAuthStore","account","backendUrl","proxySet","setAccount","acc","removeAccount","setBackendUrl","setProxySet","urls","setAccountProfile","profile","updateAccount","updateDeviceName","deviceName","originalUrls","types","canParseUrl","url","URL","isParsedUrlType","parseParams","input","entriesParams","param","part","getParsedUrls","getState","match","exec","getProxyUrls","getM3U8ProxyUrls","getProviderApiUrls","TMDBContentTypes","allowedExtensionRange","isAllowedExtensionVersion","satisfies","RULE_IDS","PREPARE_STREAM","SET_DOMAINS_HLS","SET_DOMAINS_HLS_AUDIO","isExtensionReady","Promise","resolve","setTimeout","activeExtension","sendMessage","message","payload","arguments","timeout","sendToBackgroundViaRelay","then","res","catch","sendExtensionRequest","ops","setDomainRule","sendPage","extensionInfo","isExtensionActiveCached","isExtensionActive","info","success","allowed","hasPermission","getStackTrace","lines","topMessage","stackTraceLines","stack","reportProviders","segmentStatusMap","notfound","failure","pending","waiting","scrapeSourceOutputToProviderMetric","providerId","embedId","status","episodeId","episode","seasonId","errorMessage","fullError","scrapeSegmentToProviderMetric","segment","reason","scrapePartsToProviderMetric","order","sources","orderItem","source","children","embed","metric","useReportProviders","report","useCallback","metaDataCache","token","setCachedMetadata","getCachedMetadata","setApiToken","newToken","getTokenIfValid","jwtDecode","exp","fetchMetadata","base","mwFetch","flat","scrapeMediaToQueryMedia","extra","episodeNumber","episodeTmdbId","seasonNumber","seasonTmdbId","imdbId","addQueryDataToUrl","searchParams","makeProviderUrl","makeUrl","p","scrapeSource","sourceId","scrapeAll","scrapeEmbed","embedUrl","getApiToken","apiToken","isTurnstileInitialized","getTurnstileToken","parseEventInput","inp","connectServerSideEvents","endEvents","parsedUrl","eventSource","EventSource","promReject","promResolve","promise","reject","evt","addEventListener","e","close","errObj","NotFoundError","assign","ev","on","event","getBodyTypeFromBody","FormData","URLSearchParams","convertBodyToObject","makeLoadbalancedList","getter","listIndex","fetchers","Math","floor","random","proxyUrl","getLoadbalancedProxyUrl","getLoadbalancedProviderApiUrl","getLoadbalancedM3U8ProxyUrl","fetchButWithApiTokens","headers","Headers","response","fetch","newApiToken","setupM3U8Proxy","setM3U8ProxyUrl","makeLoadBalancedSimpleProxyFetcher","makeSimpleProxyFetcher","makeFinalHeaders","readHeaders","lowercasedHeaders","makeExtensionFetcher","result","bodyType","finalUrl","statusCode","baseFetch","ofetch","retry","_ref","k","encodeURIComponent","singularProxiedFetch","combinedUrl","baseURL","endsWith","slice","params","_ref2","query","_ref3","destination","onResponse","context","tokenHeader","Array","isArray","hook","proxiedFetch","mediaTypeToTMDB","TV","mediaItemTypeToMediaType","TMDBMediaToMediaType","TMDBMediaToMediaItemType","formatTMDBMeta","original_release_date","getFullYear","air_date","still_path","overview","formatTMDBMetaToMediaItem","release_date","TMDBIdToUrlId","slugify","lower","strict","mediaItemToId","decodeTMDBId","paramId","prefix","mediaType","tmdbBaseUrl1","tmdbBaseUrl2","apiKey","tmdbHeaders","accept","Authorization","abortOnTimeout","controller","AbortController","abort","signal","proxyRotationIndex","getNextProxy","proxyUrls","proxy","shouldProxyTmdb","usePreferencesStore","proxyTmdb","userLanguage","useLanguageStore","formattedLanguage","fullUrl","allParams","append","String","encodeURI","multiSearch","include_adult","page","results","r","media_type","generateQuickSearchMediaUrl","getMediaDetails","append_to_response","showData","episodePromises","allEpisodes","all","getMediaBackdrop","backdropPath","imgUrl","getMediaPoster","posterPath","getEpisodes","getMovieFromExternalId","movie","external_source","movie_results","formatTMDBSearchResult","mediatype","show","poster_path","first_air_date","getMediaLogo","include_image_language","logo","logos","l","iso_639_1","file_path","getMediaCredits","endpoint","getPersonProfileImage","profilePath","formatTMDBMetaResult","details","getMetaFromId","external_ids","imdb_id","selectedSeason","tmdbmeta","getLegacyMetaFromId","queryType","FetchError","provider","external_id","seasonToScrape","isLegacyUrl","isLegacyMediaType","convertLegacyUrl","urlParts","suffix","movieId","SimpleCache","INTERVAL_MS","_interval","_compare","_storage","initialize","setInterval","val","expiry","clearInterval","setCompare","compare","has","foundValue","expirySeconds","getTime","remove","cache","searchQuery","tmdbIdPattern","yearPattern","searchForMedia","tmdbMatch","mediaResult","yearValue","queryWithoutYear","yearMatch","formattedResult","movieWithPosters","movieWithoutPosters","sortedresult","concat","normalizeTitle","compareTitle","getMetas","uniqueMedias","oldData","yearsAreClose","abs","mediaMetas","relevantItems","Number","relevantItem","mediaId","Boolean","Set","watchedEntry","num","max","migrateV1Bookmarks","old","t","migrateV2Videos","newData","oldWatched","newItem","progress","percentage","watchedAt","series","isNotNull","obj","migrateId","migrateV2Bookmarks","updatedBookmarks","migrateV3Videos","migratedId","clone","typeMap","ANIME","oldBookmarks","newItems","oldBookmark","useSubtitleStore","enabled","lastSync","lastSelectedLanguage","isOpenSubtitles","overrideCasing","delay","styling","color","backgroundOpacity","size","backgroundBlur","bold","verticalPosition","fontStyle","showDelayIndicator","resetSubtitleSpecificSettings","updateStyling","newStyling","min","resetStyling","setLanguage","setIsOpenSubtitles","setCustomSubs","setOverrideCasing","setDelay","importSubtitleLanguage","setShowDelayIndicator","merge","persisted","current","captionSettings","fontSize","backgroundColor","langStore","subtitleStore","opacitySplit","parseInt","useVolumeStore","volume","setVolume","useEmpheralVolumeStore","showVolume","setShowVolume","bool","useProgressStore","removeItem","replaceItems","updateItem","duration","watched","migrateV4Videos","oldItem","episodeTitle","ep","getAuthHeaders","authorization","bookmarkMediaToInput","userId","method","uint8ArrayToBuffer","array","forge","util","createBuffer","from","byte","fromCharCode","seedFromMnemonic","mnemonic","pbkdf2Async","sha256","dkLen","verifyValidMnemonic","validateMnemonic","wordlist","keysFromSeed","seed","privateKey","publicKey","pki","ed25519","generateKeyPair","Uint8Array","keysFromMnemonic","genMnemonic","generateMnemonic","signCode","signature","sign","encoding","bytesToBase64","bytes","encode64","fromCodePoint","bytesToBase64Url","signChallenge","challengeCode","base64ToBuffer","binary","base64","decode","base64ToStringBuffer","decoded","stringBufferToBase64","buffer","getBytes","encryptData","secret","byteLength","iv","cipher","createCipher","start","tagLength","update","finish","encryptedData","mode","decryptData","decipher","createDecipher","importProgress","progressItems","importBookmarks","getLoginChallengeToken","loginAccount","namespace","progressUpdateItemToInput","NaN","progressMediaItemToInputs","flatMap","_","toISOString","setProgress","removeProgress","getRegisterChallengeToken","captchaToken","registerAccount","getSessions","updateSession","sessionId","removeSession","updateSettings","settings","getSettings","bookmarkResponsesToEntries","responses","bookmark","progressResponsesToEntries","getUser","editUser","object","deleteUser","getBookmarks","getProgress","useAuthData","loggedIn","clearBookmarks","clearProgress","setTheme","useThemeStore","setAppLanguage","setFebboxKey","setEnableThumbnails","setEnableAutoplay","setEnableSkipCredits","setEnableDiscover","setEnableFeatured","setEnableDetailsModal","setEnableImageLogos","setEnableCarouselView","setSourceOrder","setEnableSourceOrder","setProxyTmdb","setEnableLowPerformanceMode","setEnableNativeSubtitles","login","loginResponse","user","session","device","logout","syncData","_user","_session","applicationLanguage","defaultSubtitleLanguage","applicationTheme","enableThumbnails","enableAutoplay","enableSkipCredits","enableDiscover","enableFeatured","enableDetailsModal","enableImageLogos","enableCarouselView","sourceOrder","enableSourceOrder","febboxKey","enableLowPerformanceMode","enableNativeSubtitles","useBackendUrl","useAuth","currentAccount","userDataLogout","userDataLogin","loginData","publicKeyBase64Url","challenge","loginResult","userData","seedBase64","register","registerData","recaptchaToken","registerResult","importData","progressInputs","bookmarkInputs","restore","anyError","AUTH_CHECK_INTERVAL","useAuthRestore","hasRestored","useRef","useInterval","useAsync","finally","useQueryParams","loc","useLocation","useMemo","search","useQueryParam","location","navigate","useNavigate","currentValue","parsed","delete","useOverlayStore","transition","routes","anchorPoint","setTransition","newTrans","registerRoute","route","setAnchorPoint","point","splitPath","path","joinPath","useRouterAnchorUpdate","routerActive","anchor","getElementById","rect","getBoundingClientRect","h","height","w","width","x","y","useEffect","resizeEvent","removeEventListener","useInternalOverlayRouter","setRoute","makePath","oldRoute","newRoute","to","showBackwardsTransition","isCurrentPage","isOverlayActive","preventRouteClear","open","defaultRoute","activeRoute","currentRoute","useOverlayRouter","router","isRouterActive","useIsMobile","horizontal","isMobile","setIsMobile","useState","isMobileCurrent","onResize","innerWidth","sendPlayerStatus","ok","statusText","json","getRoomStatuses","roomCode","useBannerStore","banners","isOnline","isTurnstile","ignoredBannerIds","updateOnline","updateTurnstile","setLocation","showBanner","hideBanner","force","updateHeight","found","useBannerSize","currentLocation","reduce","useRegisterBanner","ref","useMeasure","useOnlineListener","counter","interval","getBackendMeta","createCastingSlice","casting","instance","player","setInstance","setPlayer","setController","setIsCasting","isCasting","interface","qualitySorting","unknown","sortedQualities","getPreferredQuality","availableQualites","qualityPreferences","automaticQuality","lastChosenQuality","chosenQualityIndex","indexOf","nearestChoseQuality","selectQuality","stream","quality","availableQualities","qualities","qualityNameMap","allQualities","qualityToString","useQualityStore","setLastChosenQuality","setAutomaticQuality","playerStatus","IDLE","SCRAPING","PLAYING","SCRAPE_NOT_FOUND","PLAYBACK_ERROR","metaToScrapeMedia","createSourceSlice","audioTracks","captionList","currentQuality","currentAudioTrack","caption","selected","asTrack","setSourceId","setStatus","setMeta","newStatus","hideNextEpisodeBtn","setCaption","display","setSource","captions","startAt","loadableStream","redisplaySource","load","preferredQuality","switchQuality","selectedQuality","time","changeQuality","enableAutomaticQuality","setCaptionAsTrack","createDisplaySlice","setDisplay","newDisplay","mediaPlaying","isPaused","isPlaying","hasPlayedOnce","isFullscreen","vol","buffered","isLoading","audioTrack","needsTrack","canAirplay","rate","playbackRate","reset","thumbnails","images","VideoPlayerTimeFormat","PlayerHoverState","createInterfaceSlice","hasOpenOverlay","isSeeking","lastVolume","leftControlHovering","isHoveringControls","hovering","NOT_HOVERING","lastHoveringState","volumeChangedWithKeybind","volumeChangedWithKeybindDebounce","timeFormat","REGULAR","shouldStartFromBeginning","setShouldStartFromBeginning","setLastVolume","state","setHasOpenOverlay","setTimeFormat","format","updateInterfaceHovering","newState","setSeeking","seeking","setHoveringLeftControls","setHoveringAnyControls","hideNextEpisodeButton","createPlayingSlice","isDragSeeking","play","pause","createProgressSlice","draggingTime","setDraggingTime","nearestImageAt","at","indexPastTimestamp","index","image","imagePastTimestamp","imageBeforeTimestamp","distanceBefore","distancePast","createThumbnailSlice","resetImages","addImage","img","exactOrPastImageIndex","splice","usePlayerStore","sanitize","DOMPurify","captionIsVisible","end","currentTime","delayedStart","delayedEnd","makeQueId","convertSubtitlesToVtt","text","textTrimmed","vtt","convert","detect","convertSubtitlesToSrt","srt","filterDuplicateCaptionCues","cues","cap","lastCap","isSameAsLast","content","parseVttSubtitles","cue","parseSubtitles","_language","stringToBase64","btoa","TextEncoder","encode","convertSubtitlesToSrtDataurl","convertSubtitlesToObjectUrl","createObjectURL","Blob","convertProviderCaption","needsProxy","hasCorsRestrictions","opensubtitles","subtitleTypeList","list","downloadCache","downloadCaption","cached","extensionResponse","responseType","contentType","charset","arrayBuffer","TextDecoder","encoder","decoder","utf8Bytes","utf8Data","downloadWebVTT","useCaptions","getHlsCaptionList","getCaptionList","getSubtitleTracks","setSubtitlePreference","selectCaptionById","captionId","captionToSet","srtData","hls","track","fragments","frag","vttCaptions","filtered","subsrt","selectLanguage","disable","selectLastUsedLanguage","toggleLastUsed","selectLastUsedLanguageIfEnabled","useInitializePlayer","useInitializeSource","sourceIdentifier","funRef","usePlayer","progressStore","m","playMedia","startAtOverride","setScrapeStatus","setScrapeNotFound","isSafari","test","navigator","userAgent","cachedVolumeResult","canChangeVolume","timeoutPromise","video","createElement","handler","race","canFullscreenAnyElement","fscreen","fullscreenEnabled","canWebkitFullscreen","canFullscreen","canPictureInPicture","canWebkitPictureInPicture","canPlayHlsNatively","Hls","isSupported","canPlayType","detectExtensionInstall","makePercentageString","toFixed","makePercentage","isClickEvent","getEventX","pageX","changedTouches","useProgressBar","barRef","commit","commitImmediately","mouseDown","setMouseDown","mouseMove","pos","left","offsetWidth","mouseUp","removeAttribute","dragMouseDown","setAttribute","dragging","dragPercentage","formatSeconds","secs","showHours","isNaN","seconds","minutes","hours","paddedSecs","padStart","paddedMins","durationExceedsHour","useVolume","setStoredVolume","toggleVolume","newVolume","toggleMute","extractDomain","hostname","extractDomainsFromStream","playlist","buildHeadersFromStream","preferredHeaders","prepareStream","ruleId","targetDomains","requestHeaders","getProviders","makeProviders","fetcher","makeStandardFetcher","proxiedFetcher","target","targets","BROWSER_EXTENSION","consistentIpForRequests","BROWSER","getAllProviders","allowedQualitiesMap","allowedQualities","allowedFileTypes","isAllowedQuality","convertRunoutputToSource","out","warn","useEmbedScraping","routerId","request","run","useAsyncFn","providerApiUrl","baseUrlMaker","runEmbedScraper","loading","errored","useSourceScraping","scrapeMedia","runSourceScraper","embeds","embedResult","watching","Menu","Cards","Links","Sections","Misc","generateRoomCode","resetPlaybackRate","setPlaybackRate","useWatchPartyStore","isHost","showStatusOverlay","enableAsHost","enableAsGuest","updateRoomCode","setShowStatusOverlay","isAutoplayAllowed","useWatchPartySync","syncThresholdSeconds","roomUsers","setRoomUsers","isSyncing","setIsSyncing","userCount","setUserCount","syncStateRef","lastUserCount","previousHostPlaying","previousHostTime","lastSyncTime","syncInProgress","checkedUrlParams","prevRoomUsers","watchPartyCode","hostUser","getPredictedHostTime","secondsSinceUpdate","lastUpdate","timeDifferenceFromHost","isBehindHost","isAheadOfHost","syncWithHost","predictedHostTime","setTime","hostIsPlaying","difference","activeThreshold","needsTimeSync","needsPlayStateSync","needsJumpSync","refreshRoomData","users","userIdFromResponse","statuses","latestStatus","timestamp","newUserCount","syncState","usePlayerMeta","setDirectMeta","setPlayerMeta","playerMeta","hasAiredCache","hasAired","date","airDate","useOverlayStack","currentOverlay","setCurrentOverlay","overlay","handleBuffered","mediaErrorMap","getMediaErrorDetails","processCdnLink","replacements","before","after","port","protocol","makeEmitter","listeners","eventName","fn","off","emit","levelConversionMap","qualityThresholds","minHeight","hlsLevelToQuality","level","exactMatch","threshold","hlsLevelsToQualities","levels","sortLevelsByQuality","makeVideoElementDisplayInterface","videoElement","containerElement","isPausedBeforeSeeking","preferenceQuality","languagePromises","Map","reportLevels","convertedLevels","reportAudioTracks","currentLanguage","languageTrack","currentTrack","label","setupQualityForHls","currentLevel","loadLevel","sortedLevels","availableQuality","matchingLevels","bestLevel","levelIndex","setupSource","vid","src","autoStartLoad","maxBufferLength","maxMaxBufferLength","fragLoadPolicy","default","maxLoadTimeMs","maxTimeToFirstByteMs","errorRetry","maxNumRetry","retryDelayMs","maxRetryDelayMs","timeoutRetry","renderTextTracksNatively","exceptions","Events","ERROR","fatal","baseurl","stackTrace","errorName","MANIFEST_LOADED","LEVEL_LOADED","chunkUrlsDomains","chunkUrls","AUDIO_TRACK_LOADED","LEVEL_SWITCHED","SUBTITLE_TRACK_LOADED","subtitleTracks","attachMedia","loadSource","errorDetails","muted","availability","unloadSource","destroyVideoElement","fullscreenChange","fullscreenElement","webkitFullscreenElement","getType","newAutomaticQuality","newPreferredQuality","processVideoElement","processContainerElement","container","active","paused","toggleFullscreen","exitFullscreen","requestFullscreen","webkitEnterFullscreen","togglePictureInPicture","webkitPlayer","webkitSetPresentationMode","webkitPresentationMode","pictureInPictureElement","requestPictureInPicture","exitPictureInPicture","startAirplay","videoPlayer","webkitShowPlaybackTargetPicker","setSubtitleOption","changeAudioTrack","makeChromecastDisplayInterface","listenForEvents","listen","field","cast","framework","RemotePlayerEventType","ANY_CHANGE","stop","metaData","chrome","GenericMediaMetadata","mediaInfo","MediaInfo","contentUrl","streamType","StreamType","BUFFERED","metadata","customData","LoadRequest","autoplay","staticMedia","hlsSegmentFormat","HlsSegmentFormat","FMP4","hlsVideoSegmentFormat","HlsVideoSegmentFormat","getCurrentSession","loadMedia","stopListening","loadOps","newCaption","playOrPause","seek","volumeLevel","setVolumeLevel","CHROMECAST_SENDER_SDK","callbacks","_available","available","isChromecastAvailable","initializeChromecast","__onGCastApiAvailable","isAvailable","appendChild","useChromecastAvailable","setAvailable","usePlayerStatusPolling","maxHistory","statusHistory","setStatusHistory","previousStateRef","lastUpdateTimeRef","updateHistory","currentStatus","prevState","timeSinceLastUpdate","hasPlaybackStateChanged","hasPlaybackRateChanged","hasTimeChangedDuringPlayback","hasDurationChanged","periodicUpdateDuringPlayback","prev","newHistory","clearHistory","forceUpdate","TRAKT_BASE_URL","paginateResults","pageSize","startIndex","endIndex","tmdb_ids","hasMore","totalCount","fetchFromTrakt","getReleaseDetails","getLatestReleases","getLatest4KReleases","getLatestTVReleases","getAppleTVReleases","getNetflixMovies","getNetflixTVShows","getPrimeReleases","getHuluReleases","getDisneyReleases","getHBOReleases","getActionReleases","getDramaReleases","getDiscoverContent","getNetworkContent","PROVIDER_TO_TRAKT_MAP","GENRE_TO_TRAKT_MAP","PROVIDER_TO_IMAGE_MAP","Max","Netflix","Hulu","defaultProgress","progressIsCompleted","progressIsNotStarted","progressIsAcceptableRange","isFirstEpisodeOfShow","shouldShowProgress","epi","imdbLanguageMap","getImdbLanguageCode","months","userAgents","getRandomUserAgent","scrapeIMDb","hasExtension","hasProxy","log","imdbLanguage","imdbUrl","separator","jsonMatch","original_title","title_type","end_year","day","month","runtime","age_rating","imdb_rating","votes","plot","poster_url","trailer_url","genre","directors","writers","keywords","languages","locations","aboveTheFold","props","pageProps","aboveTheFoldData","mainColumn","mainColumnData","titleText","originalTitleText","titleType","certificate","rating","endYear","releaseDate","plotText","plainText","ratingsSummary","aggregateRating","voteCount","primaryImage","primaryVideos","edges","node","playbackURLs","genres","g","castPageTitle","nameText","directorsPageTitle","credits","countriesOfOrigin","spokenLanguages","filmingLocations","calculateSimilarity","str1","str2","s1","s2","words1","words2","intersection","union","findBestMatch","searchTitle","movies","bestMatch","bestScore","similarity","yearBoost","score","scrapeRottenTomatoes","searchUrl","searchResultsDiv","movieRows","row","nameMatch","urlMatch","scoreMatch","sentimentMatch","tomatometeriscertified","tomatometer","tomatoIcon","tomatoScore","getRTIcon","BASE_URL","MAX_RETRIES","useSkipTime","skiptime","setSkiptime","fetchSkipTime","retries","apiUrl","skipTime","timeStr","introSkipTime","dmcaEmail","chromeExtension","firefoxExtension","proxyInstallLink","turnstileKey","fetchFromLetterboxd","getLetterboxdLists","decodeURIComponent","useSearchQuery","useParams","setSearch","updateParams","commitToUrl","generatePath","newSearch","useDiscoverStore","selectedCategory","lastView","setSelectedCategory","category","setLastView","view","clearLastView","shuffleArray","shuffled","j","EDITOR_PICKS_MOVIES","EDITOR_PICKS_TV_SHOWS","MOVIE_PROVIDERS","TV_PROVIDERS","useDiscoverOptions","setGenres","setIsLoading","setError","providers","api_key","fetchGenres","useDiscoverMedia","fallbackType","genreName","providerName","mediaTitle","isCarouselView","setMedia","setHasMore","sectionTitle","setSectionTitle","currentContentType","setCurrentContentType","useTranslation","fetchTMDBMedia","total_pages","fetchTraktMedia","traktFunction","tmdbIds","hasMoreResults","mediaPromises","allSettled","getTraktProviderFunction","trakt","getTraktGenreFunction","genreId","fetchEditorPicks","picks","picksToFetch","fetchMedia","attemptFetch","traktGenreFunction","traktProviderFunction","traktErr","with_genres","with_watch_providers","watch_region","prevMedia","fallbackData","fallbackErr","refetch","useDebounce","debouncedValue","setDebouncedValue","clearTimeout","shouldGiveJokeTitle","useRandomTranslation","shouldJoke","defaultTitle","returnObjects","defaultValue","getRandomTranslation","useMigration","bookmarkItems","useRedirectBack","setCompleted","useOnboardingStore","redirectBack","completeAndRedirect","useNavigateOnboarding","pathname","getExtensionState","useHistoryStore","useHistoryListener","useEffectOnce","useLastNonPlayerLink","reversedRoutes"],"ignoreList":[],"sources":["../../src/backend/metadata/types/mw.ts","../../src/stores/bookmarks/index.ts","../../src/stores/__old/migrations.ts","../../src/assets/languages.ts","../../src/utils/language.ts","../../src/setup/i18n.ts","../../src/backend/metadata/types/justwatch.ts","../../src/backend/metadata/justwatch.ts","../../src/setup/constants.ts","../../src/setup/config.ts","../../src/stores/auth/index.ts","../../src/utils/proxyUrls.ts","../../src/backend/metadata/types/tmdb.ts","../../src/backend/extension/compatibility.ts","../../src/backend/extension/messaging.ts","../../src/backend/helpers/report.ts","../../src/backend/helpers/providerApi.ts","../../src/backend/extension/request.ts","../../src/backend/providers/fetchers.ts","../../src/backend/helpers/fetch.ts","../../src/backend/metadata/tmdb.ts","../../src/backend/metadata/getmeta.ts","../../src/utils/cache.ts","../../src/backend/metadata/search.ts","../../src/stores/__old/utils.ts","../../src/stores/__old/watched/migrations/v2.ts","../../src/utils/typeguard.ts","../../src/stores/__old/watched/migrations/v3.ts","../../src/stores/__old/bookmark/store.ts","../../src/stores/subtitles/index.ts","../../src/stores/__old/settings/store.ts","../../src/stores/volume/index.ts","../../src/stores/__old/volume/store.ts","../../src/stores/progress/index.ts","../../src/stores/__old/watched/migrations/v4.ts","../../src/stores/__old/watched/store.ts","../../src/backend/accounts/auth.ts","../../src/backend/accounts/bookmarks.ts","../../src/backend/accounts/crypto.ts","../../src/backend/accounts/import.ts","../../src/backend/accounts/login.ts","../../src/backend/accounts/progress.ts","../../src/backend/accounts/register.ts","../../src/backend/accounts/sessions.ts","../../src/backend/accounts/settings.ts","../../src/backend/accounts/user.ts","../../src/hooks/auth/useAuthData.ts","../../src/hooks/auth/useBackendUrl.ts","../../src/hooks/auth/useAuth.ts","../../src/hooks/auth/useAuthRestore.ts","../../src/hooks/useQueryParams.ts","../../src/stores/overlay/store.ts","../../src/hooks/useOverlayRouter.ts","../../src/hooks/useIsMobile.ts","../../src/backend/player/status.ts","../../src/stores/banner/index.ts","../../src/hooks/usePing.ts","../../src/backend/accounts/meta.ts","../../src/stores/player/slices/casting.ts","../../src/stores/player/utils/qualities.ts","../../src/stores/quality/index.ts","../../src/stores/player/slices/source.ts","../../src/stores/player/slices/display.ts","../../src/stores/player/slices/interface.ts","../../src/stores/player/slices/playing.ts","../../src/stores/player/slices/progress.ts","../../src/stores/player/slices/thumbnails.ts","../../src/stores/player/store.ts","../../src/components/player/utils/captions.ts","../../src/backend/helpers/subs.ts","../../src/components/player/hooks/useCaptions.ts","../../src/components/player/hooks/useInitializePlayer.ts","../../src/components/player/hooks/usePlayer.ts","../../src/utils/detectFeatures.ts","../../src/hooks/useProgressBar.ts","../../src/utils/formatSeconds.ts","../../src/components/player/hooks/useVolume.ts","../../src/backend/extension/streams.ts","../../src/backend/providers/providers.ts","../../src/components/player/utils/convertRunoutputToSource.ts","../../src/components/player/hooks/useSourceSelection.ts","../../src/components/player/internals/ContextMenu/index.ts","../../src/stores/watchParty.ts","../../src/utils/autoplay.ts","../../src/hooks/useWatchPartySync.ts","../../src/components/player/hooks/usePlayerMeta.ts","../../src/components/player/utils/aired.ts","../../src/stores/interface/overlayStack.ts","../../src/components/player/utils/handleBuffered.ts","../../src/components/player/utils/mediaErrorDetails.ts","../../src/utils/cdn.ts","../../src/utils/events.ts","../../src/components/player/display/base.ts","../../src/components/player/display/chromecast.ts","../../src/setup/chromecast.ts","../../src/hooks/useChromecastAvailable.ts","../../src/components/player/hooks/usePlayerStatusPolling.ts","../../src/backend/metadata/traktApi.ts","../../src/stores/progress/utils.ts","../../src/utils/imdbScraper.ts","../../src/utils/rottenTomatoesScraper.ts","../../src/components/player/hooks/useSkipTime.ts","../../src/utils/setup/constants.ts","../../src/utils/setup/config.ts","../../src/backend/metadata/letterboxd.ts","../../src/hooks/useSearchQuery.ts","../../src/stores/discover/index.ts","../../src/pages/discover/hooks/useDiscoverMedia.ts","../../src/hooks/useDebounce.ts","../../src/hooks/useRandomTranslation.ts","../../src/hooks/auth/useMigration.ts","../../src/pages/onboarding/onboardingHooks.ts","../../src/utils/extension.ts","../../src/stores/history/index.ts"],"sourcesContent":["export enum MWMediaType {\n  MOVIE = \"movie\",\n  SERIES = \"series\",\n  ANIME = \"anime\",\n}\n\nexport type MWSeasonMeta = {\n  id: string;\n  number: number;\n  title: string;\n};\n\nexport type MWSeasonWithEpisodeMeta = {\n  id: string;\n  number: number;\n  title: string;\n  episodes: {\n    id: string;\n    number: number;\n    title: string;\n    air_date: string;\n    still_path: string | null;\n    overview: string;\n  }[];\n};\n\ntype MWMediaMetaBase = {\n  title: string;\n  id: string;\n  year?: string;\n  poster?: string;\n};\n\ntype MWMediaMetaSpecific =\n  | {\n      type: MWMediaType.MOVIE | MWMediaType.ANIME;\n      seasons: undefined;\n    }\n  | {\n      type: MWMediaType.SERIES;\n      seasons: MWSeasonMeta[];\n      seasonData: MWSeasonWithEpisodeMeta;\n    };\n\nexport type MWMediaMeta = MWMediaMetaBase & MWMediaMetaSpecific;\n\nexport interface MWQuery {\n  searchQuery: string;\n}\n\nexport interface DetailedMeta {\n  meta: MWMediaMeta;\n  imdbId?: string;\n  tmdbId?: string;\n}\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\nexport interface BookmarkMediaItem {\n  title: string;\n  year?: number;\n  poster?: string;\n  type: \"show\" | \"movie\";\n  updatedAt: number;\n}\n\nexport interface BookmarkUpdateItem {\n  tmdbId: string;\n  title?: string;\n  year?: number;\n  id: string;\n  poster?: string;\n  type?: \"show\" | \"movie\";\n  action: \"delete\" | \"add\";\n}\n\nexport interface BookmarkStore {\n  bookmarks: Record<string, BookmarkMediaItem>;\n  updateQueue: BookmarkUpdateItem[];\n  addBookmark(meta: PlayerMeta): void;\n  removeBookmark(id: string): void;\n  replaceBookmarks(items: Record<string, BookmarkMediaItem>): void;\n  clear(): void;\n  clearUpdateQueue(): void;\n  removeUpdateItem(id: string): void;\n}\n\nlet updateId = 0;\n\nexport const useBookmarkStore = create(\n  persist(\n    immer<BookmarkStore>((set) => ({\n      bookmarks: {},\n      updateQueue: [],\n      removeBookmark(id) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"delete\",\n            tmdbId: id,\n          });\n\n          delete s.bookmarks[id];\n        });\n      },\n      addBookmark(meta) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"add\",\n            tmdbId: meta.tmdbId,\n            type: meta.type,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n          });\n\n          s.bookmarks[meta.tmdbId] = {\n            type: meta.type,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n            updatedAt: Date.now(),\n          };\n        });\n      },\n      replaceBookmarks(items: Record<string, BookmarkMediaItem>) {\n        set((s) => {\n          s.bookmarks = items;\n        });\n      },\n      clear() {\n        set((s) => {\n          s.bookmarks = {};\n        });\n      },\n      clearUpdateQueue() {\n        set((s) => {\n          s.updateQueue = [];\n        });\n      },\n      removeUpdateItem(id: string) {\n        set((s) => {\n          s.updateQueue = [...s.updateQueue.filter((v) => v.id !== id)];\n        });\n      },\n    })),\n    {\n      name: \"__MW::bookmarks\",\n    },\n  ),\n);\n","interface StoreVersion<A> {\n  version: number;\n  migrate?(data: A): any;\n  create?: () => A;\n}\ninterface StoreRet<T> {\n  save: (data: T) => void;\n  get: () => T;\n  _raw: () => any;\n  onChange: (cb: (data: T) => void) => {\n    destroy: () => void;\n  };\n}\n\nexport interface StoreBuilder<T> {\n  setKey: (key: string) => StoreBuilder<T>;\n  addVersion: <A>(ver: StoreVersion<A>) => StoreBuilder<T>;\n  build: () => StoreRet<T>;\n}\n\ninterface InternalStoreData {\n  versions: StoreVersion<any>[];\n  key: string | null;\n}\n\nconst storeCallbacks: Record<string, ((data: any) => void)[]> = {};\nconst stores: Record<string, [StoreRet<any>, InternalStoreData]> = {};\n\nexport async function initializeOldStores() {\n  // migrate all stores\n  for (const [store, internal] of Object.values(stores)) {\n    const versions = internal.versions.sort((a, b) => a.version - b.version);\n\n    const data = store._raw();\n    const dataVersion =\n      data[\"--version\"] && typeof data[\"--version\"] === \"number\"\n        ? data[\"--version\"]\n        : 0;\n\n    // Find which versions need to be used for migrations\n    const relevantVersions = versions.filter((v) => v.version >= dataVersion);\n\n    // Migrate over each version\n    let mostRecentData = data;\n    try {\n      for (const version of relevantVersions) {\n        if (version.migrate) {\n          localStorage.setItem(\n            `BACKUP-v${version.version}-${internal.key}`,\n            JSON.stringify(mostRecentData),\n          );\n          mostRecentData = await version.migrate(mostRecentData);\n        }\n      }\n    } catch (err) {\n      console.error(`FAILED TO MIGRATE STORE ${internal.key}`, err);\n      // reset store to lastest version create\n      mostRecentData =\n        relevantVersions[relevantVersions.length - 1].create?.() ?? {};\n    }\n\n    store.save(mostRecentData);\n  }\n}\n\nfunction buildStorageObject<T>(store: InternalStoreData): StoreRet<T> {\n  const key = store.key ?? \"\";\n  const latestVersion = store.versions.sort((a, b) => b.version - a.version)[0];\n\n  function onChange(cb: (data: T) => void) {\n    if (!storeCallbacks[key]) storeCallbacks[key] = [];\n    storeCallbacks[key].push(cb);\n    return {\n      destroy() {\n        // remove function pointer from callbacks\n        storeCallbacks[key] = storeCallbacks[key].filter((v) => v === cb);\n      },\n    };\n  }\n\n  function makeRaw() {\n    const data = latestVersion.create?.() ?? {};\n    data[\"--version\"] = latestVersion.version;\n    return data;\n  }\n\n  function getRaw() {\n    const item = localStorage.getItem(key);\n    if (!item) return makeRaw();\n    try {\n      return JSON.parse(item);\n    } catch (err) {\n      // we assume user has fucked with the data, give them a fresh store\n      console.error(`FAILED TO PARSE LOCALSTORAGE FOR KEY ${key}`, err);\n      return makeRaw();\n    }\n  }\n\n  function save(data: T) {\n    const withVersion: any = { ...data };\n    withVersion[\"--version\"] = latestVersion.version;\n    localStorage.setItem(key, JSON.stringify(withVersion));\n\n    if (!storeCallbacks[key]) storeCallbacks[key] = [];\n    storeCallbacks[key].forEach((v) => v(window.structuredClone(data)));\n  }\n\n  return {\n    get() {\n      const data = getRaw();\n      delete data[\"--version\"];\n      return data as T;\n    },\n    _raw() {\n      return getRaw();\n    },\n    onChange,\n    save,\n  };\n}\n\nfunction assertStore(store: InternalStoreData) {\n  const versionListSorted = store.versions.sort(\n    (a, b) => a.version - b.version,\n  );\n  versionListSorted.forEach((v, i, arr) => {\n    if (i === 0) return;\n    if (v.version !== arr[i - 1].version + 1)\n      throw new Error(\"Version list of store is not incremental\");\n  });\n  versionListSorted.forEach((v) => {\n    if (v.version < 0) throw new Error(\"Versions cannot be negative\");\n  });\n\n  // version zero must exist\n  if (versionListSorted[0]?.version !== 0)\n    throw new Error(\"Version 0 doesn't exist in version list of store\");\n\n  // max version must have create function\n  if (!store.versions[store.versions.length - 1].create)\n    throw new Error(`Missing create function on latest version of store`);\n\n  // check storage string\n  if (!store.key) throw new Error(\"storage key not set in store\");\n\n  // check if all parts have migratio\n  const migrations = [...versionListSorted];\n  migrations.pop();\n  migrations.forEach((v) => {\n    if (!v.migrate)\n      throw new Error(`Migration missing on version ${v.version}`);\n  });\n}\n\nexport function createVersionedStore<T>(): StoreBuilder<T> {\n  const _data: InternalStoreData = {\n    versions: [],\n    key: null,\n  };\n\n  return {\n    setKey(key) {\n      _data.key = key;\n      return this;\n    },\n    addVersion(ver) {\n      _data.versions.push(ver);\n      return this;\n    },\n    build() {\n      assertStore(_data);\n      const storageObject = buildStorageObject<T>(_data);\n      stores[_data.key ?? \"\"] = [storageObject, _data];\n      return storageObject;\n    },\n  };\n}\n","import ar from \"@/assets/locales/ar.json\";\nimport bg from \"@/assets/locales/bg.json\";\nimport bn from \"@/assets/locales/bn.json\";\nimport ca from \"@/assets/locales/ca.json\";\nimport caVl from \"@/assets/locales/ca@valencia.json\";\nimport cs from \"@/assets/locales/cs.json\";\nimport da from \"@/assets/locales/da.json\";\nimport deCh from \"@/assets/locales/de-CH.json\";\nimport de from \"@/assets/locales/de.json\";\nimport el from \"@/assets/locales/el.json\";\nimport en from \"@/assets/locales/en.json\";\nimport es from \"@/assets/locales/es.json\";\nimport et from \"@/assets/locales/et.json\";\nimport fa from \"@/assets/locales/fa.json\";\nimport fi from \"@/assets/locales/fi-FI.json\";\nimport fr from \"@/assets/locales/fr.json\";\nimport futhark from \"@/assets/locales/futhark.json\";\nimport gl from \"@/assets/locales/gl.json\";\nimport gu from \"@/assets/locales/gu.json\";\nimport he from \"@/assets/locales/he.json\";\nimport hi from \"@/assets/locales/hi.json\";\nimport id from \"@/assets/locales/id.json\";\nimport is from \"@/assets/locales/is-IS.json\";\nimport it from \"@/assets/locales/it.json\";\nimport ja from \"@/assets/locales/ja.json\";\nimport kitty from \"@/assets/locales/kitty.json\";\nimport ko from \"@/assets/locales/ko.json\";\nimport lv from \"@/assets/locales/lv.json\";\nimport minion from \"@/assets/locales/minion.json\";\nimport ne from \"@/assets/locales/ne.json\";\nimport nl from \"@/assets/locales/nl.json\";\nimport nv from \"@/assets/locales/nv.json\";\nimport pa from \"@/assets/locales/pa.json\";\nimport pirate from \"@/assets/locales/pirate.json\";\nimport pl from \"@/assets/locales/pl.json\";\nimport ptbr from \"@/assets/locales/pt-BR.json\";\nimport ptpt from \"@/assets/locales/pt-PT.json\";\nimport ro from \"@/assets/locales/ro.json\";\nimport ru from \"@/assets/locales/ru.json\";\nimport sl from \"@/assets/locales/sl.json\";\nimport sv from \"@/assets/locales/sv.json\";\nimport ta from \"@/assets/locales/ta.json\";\nimport th from \"@/assets/locales/th.json\";\nimport tok from \"@/assets/locales/tok.json\";\nimport tr from \"@/assets/locales/tr.json\";\nimport uk from \"@/assets/locales/uk.json\";\nimport uwu from \"@/assets/locales/uwu.json\";\nimport vi from \"@/assets/locales/vi.json\";\nimport zhhant from \"@/assets/locales/zh-Hant.json\";\nimport zh from \"@/assets/locales/zh.json\";\n\nexport const locales = {\n  en,\n  ca,\n  \"ca-ES\": caVl,\n  cs,\n  da,\n  de,\n  \"de-CH\": deCh,\n  fr,\n  it,\n  nl,\n  pl,\n  tr,\n  vi,\n  zh,\n  he,\n  sv,\n  pirate,\n  kitty,\n  uwu,\n  minion,\n  futhark,\n  lv,\n  th,\n  ne,\n  ar,\n  es,\n  et,\n  tok,\n  hi,\n  \"pt-BR\": ptbr,\n  \"pt-PT\": ptpt,\n  uk,\n  bg,\n  bn,\n  el,\n  fa,\n  gu,\n  id,\n  ja,\n  ko,\n  sl,\n  ta,\n  \"zh-Hant\": zhhant,\n  is,\n  ru,\n  gl,\n  pa,\n  ro,\n  fi,\n  nv,\n};\n\nexport type Locales = keyof typeof locales;\n","import countryLanguages, { LanguageObj } from \"@ladjs/country-language\";\nimport { getTag } from \"@sozialhelden/ietf-language-tags\";\nimport { iso6393To1 } from \"iso-639-3\";\n\nconst languageOrder = [\"ar\", \"en\", \"es\", \"de\", \"nl\", \"pt\"];\n\n// mapping of language code to country code.\n// multiple mappings can exist, since languages are spoken in multiple countries.\n// This mapping purely exists to prioritize a country over another in languages where the base language code does\n// not contain a region (i.e. if the language code is zh-Hant where Hant is a script) or if the region in the language code is incorrect\n// iso639_1 -> iso3166 Alpha-2\nconst countryPriority: Record<string, string> = {\n  zh: \"cn\",\n  nv: \"us\",\n};\n\n// list of iso639_1 Alpha-2 codes used as default languages\nconst defaultLanguageCodes: string[] = [\n  \"ar-SA\",\n  \"bg-BG\",\n  \"bn-BD\",\n  \"cs-CZ\",\n  \"ca-AD\",\n  \"da-DK\",\n  \"de-DE\",\n  \"de-CH\",\n  \"el-GR\",\n  \"en-US\",\n  \"es-ES\",\n  \"et-EE\",\n  \"fa-IR\",\n  \"fr-FR\",\n  \"gl-ES\",\n  \"gu-IN\",\n  \"he-IL\",\n  \"id-ID\",\n  \"it-IT\",\n  \"ja-JP\",\n  \"ko-KR\",\n  \"lv-LV\",\n  \"ne-NP\",\n  \"nl-NL\",\n  \"pl-PL\",\n  \"pt-BR\",\n  \"ru-RU\",\n  \"sl-SI\",\n  \"sv-SE\",\n  \"ta-LK\",\n  \"th-TH\",\n  \"tr-TR\",\n  \"vi-VN\",\n  \"zh-CN\",\n  \"nv-US\",\n];\n\nexport interface LocaleInfo {\n  name: string;\n  nativeName?: string;\n  code: string;\n  isRtl?: boolean;\n}\n\nconst extraLanguages: Record<string, LocaleInfo> = {\n  pirate: {\n    code: \"pirate\",\n    name: \"Pirate\",\n    nativeName: \"Pirate Tongue\",\n  },\n  kitty: {\n    code: \"cat\",\n    name: \"Cat\",\n    nativeName: \"Kitty Speak\",\n  },\n  uwu: {\n    code: \"uwu\",\n    name: \"Cutsie OwO\",\n    nativeName: \"UwU\",\n  },\n  minion: {\n    code: \"minion\",\n    name: \"Minion\",\n    nativeName: \"Minionese\",\n  },\n  tok: {\n    code: \"tok\",\n    name: \"Toki pona\",\n    nativeName: \"Toki pona\",\n  },\n  futhark: {\n    code: \"futhark\",\n    name: \"Elder Futhark (EN)\",\n    nativeName: \" \",\n  },\n};\n\nfunction populateLanguageCode(language: string): string {\n  if (language.includes(\"-\")) return language;\n  if (language.length !== 2) return language;\n  return (\n    defaultLanguageCodes.find((v) => v.startsWith(`${language}-`)) ?? language\n  );\n}\n\n/**\n * @param locale idk what kinda code this takes, anything in ietf format I guess\n * @returns pretty format for language, null if it no info can be found for language\n */\nexport function getPrettyLanguageNameFromLocale(locale: string): string | null {\n  const tag =\n    locale.length === 3\n      ? getTag(iso6393To1[locale] ?? locale, true)\n      : getTag(locale, true);\n  const lang = tag?.language?.Description?.[0] ?? null;\n  if (!lang) return null;\n\n  const region = tag?.region?.Description?.[0] ?? null;\n  let regionText = \"\";\n  if (region) regionText = ` (${region})`;\n\n  return `${lang}${regionText}`;\n}\n\n/**\n * Sort locale codes by occurrence, rest on alphabetical order\n * @param langCodes list language codes to sort\n * @returns sorted version of inputted list\n */\nexport function sortLangCodes(langCodes: string[]) {\n  const languagesOrder = [...languageOrder].reverse(); // Reverse is necessary, not sure why\n\n  const results = langCodes.sort((a, b) => {\n    const langOrderA = languagesOrder.findIndex(\n      (v) => a.startsWith(`${v}-`) || a === v,\n    );\n    const langOrderB = languagesOrder.findIndex(\n      (v) => b.startsWith(`${v}-`) || b === v,\n    );\n    if (langOrderA !== -1 || langOrderB !== -1) return langOrderB - langOrderA;\n\n    return a.localeCompare(b);\n  });\n\n  return results;\n}\n\n/**\n * Get country code for locale\n * @param locale input locale\n * @returns country code or null\n */\nexport function getCountryCodeForLocale(locale: string): string | null {\n  let output: LanguageObj | null = null as any as LanguageObj;\n  const tag = getTag(populateLanguageCode(locale), true);\n\n  if (!tag?.language?.Subtag) return null;\n  // this function isn't async, so its guaranteed to work like this\n  countryLanguages.getLanguage(tag.language.Subtag, (_err, lang) => {\n    if (lang) output = lang;\n  });\n\n  if (!output) return null;\n  const priority = countryPriority[output.iso639_1.toLowerCase()];\n  if (output.countries.length === 0) {\n    return priority ?? null;\n  }\n\n  if (priority) {\n    const prioritizedCountry = output.countries.find(\n      (v) => v.code_2.toLowerCase() === priority,\n    );\n    if (prioritizedCountry) return prioritizedCountry.code_2.toLowerCase();\n  }\n\n  // If the language contains a region, check that against the countries and\n  // return the region if it matches\n  const regionSubtag = tag?.region?.Subtag.toLowerCase();\n  if (regionSubtag) {\n    const regionCode = output.countries.find(\n      (c) =>\n        c.code_2.toLowerCase() === regionSubtag ||\n        c.code_3.toLowerCase() === regionSubtag,\n    );\n    if (regionCode) return regionCode.code_2.toLowerCase();\n  }\n  return output.countries[0].code_2.toLowerCase();\n}\n\n/**\n * Get information for a specific local\n * @param locale local code\n * @returns locale object\n */\nexport function getLocaleInfo(locale: string): LocaleInfo | null {\n  const realLocale = populateLanguageCode(locale);\n\n  document.body.style.wordSpacing = \"normal\";\n\n  const extraLang = extraLanguages[realLocale];\n  if (extraLang) {\n    if (extraLang.code === \"futhark\") {\n      document.body.style.wordSpacing = \"5px\";\n    }\n    return extraLang;\n  }\n\n  const tag = getTag(realLocale, true);\n  if (!tag?.language?.Subtag) return null;\n\n  let output: LanguageObj | null = null as any as LanguageObj;\n  // this function isnt async, so its garuanteed to work like this\n  countryLanguages.getLanguage(tag.language.Subtag, (_err, lang) => {\n    if (lang) output = lang;\n  });\n  if (!output) return null;\n\n  const extras = [];\n  if (tag.region?.Description) extras.push(tag.region.Description[0]);\n  if (tag.script?.Description) extras.push(tag.script.Description[0]);\n  const extraStringified = extras.map((v) => `(${v})`).join(\" \");\n\n  return {\n    code: tag.parts.langtag ?? realLocale,\n    isRtl: output.direction === \"RTL\",\n    name: output.name[0] + (extraStringified ? ` ${extraStringified}` : \"\"),\n    nativeName: output.nativeName[0] ?? undefined,\n  };\n}\n\n/**\n * Converts a language code to a TMDB-compatible format (ISO 639-1 with region)\n * @param language The language code to convert\n * @returns A TMDB-compatible language code (e.g., \"en-US\", \"el-GR\")\n */\nexport function getTmdbLanguageCode(language: string): string {\n  // Handle empty or undefined\n  if (!language) return \"ar-SA\";\n\n  // If it already has a region code (e.g., \"en-US\"), use it directly\n  if (language.includes(\"-\")) return language;\n\n  // Handle special/custom languages by defaulting to English\n  if (language.length > 2 || Object.keys(extraLanguages).includes(language))\n    return \"ar-SA\";\n\n  // For standard language codes, find the appropriate region from the existing defaultLanguageCodes array\n  const defaultCode = defaultLanguageCodes.find((code) =>\n    code.startsWith(`${language}-`),\n  );\n\n  if (defaultCode) return defaultCode;\n\n  // If we can't find a good match, create a standard format like \"fr-FR\" from \"fr\"\n  if (language.length === 2) {\n    return `${language}-${language.toUpperCase()}`;\n  }\n\n  // Last resort fallback\n  return \"ar-SA\";\n}\n","import i18n from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\n\nimport { locales } from \"@/assets/languages\";\nimport { getLocaleInfo } from \"@/utils/language\";\n\n// Languages\nconst langCodes = Object.keys(locales);\nconst resources = Object.fromEntries(\n  Object.entries(locales).map((entry) => [entry[0], { translation: entry[1] }]),\n);\ni18n.use(initReactI18next).init({\n  fallbackLng: \"ar\",\n  resources,\n  interpolation: {\n    escapeValue: false, // not needed for react as it escapes by default\n  },\n});\n\nexport const appLanguageOptions = langCodes.map((lang) => {\n  const langObj = getLocaleInfo(lang);\n  if (!langObj)\n    throw new Error(`Language with code ${lang} cannot be found in database`);\n  return langObj;\n});\n\nexport default i18n;\n","export type JWContentTypes = \"movie\" | \"show\";\n\nexport type JWSearchQuery = {\n  content_types: JWContentTypes[];\n  page: number;\n  page_size: number;\n  query: string;\n};\n\nexport type JWPage<T> = {\n  items: T[];\n  page: number;\n  page_size: number;\n  total_pages: number;\n  total_results: number;\n};\n\nexport const JW_API_BASE = \"https://apis.justwatch.com\";\nexport const JW_IMAGE_BASE = \"https://images.justwatch.com\";\n\nexport type JWSeasonShort = {\n  title: string;\n  id: number;\n  season_number: number;\n};\n\nexport type JWEpisodeShort = {\n  title: string;\n  id: number;\n  episode_number: number;\n};\n\nexport type JWMediaResult = {\n  title: string;\n  poster?: string;\n  id: number;\n  original_release_year?: number;\n  jw_entity_id: string;\n  object_type: JWContentTypes;\n  seasons?: JWSeasonShort[];\n};\n\nexport type JWSeasonMetaResult = {\n  title: string;\n  id: string;\n  season_number: number;\n  episodes: JWEpisodeShort[];\n};\n\nexport type JWExternalIdType =\n  | \"eidr\"\n  | \"imdb_latest\"\n  | \"imdb\"\n  | \"tmdb_latest\"\n  | \"tmdb\"\n  | \"tms\";\n\nexport interface JWExternalId {\n  provider: JWExternalIdType;\n  external_id: string;\n}\n\nexport interface JWDetailedMeta extends JWMediaResult {\n  external_ids: JWExternalId[];\n}\n","import {\n  JWContentTypes,\n  JWMediaResult,\n  JWSeasonMetaResult,\n  JW_IMAGE_BASE,\n} from \"./types/justwatch\";\nimport { MWMediaMeta, MWMediaType, MWSeasonMeta } from \"./types/mw\";\n\nexport function mediaTypeToJW(type: MWMediaType): JWContentTypes {\n  if (type === MWMediaType.MOVIE) return \"movie\";\n  if (type === MWMediaType.SERIES) return \"show\";\n  throw new Error(\"unsupported type\");\n}\n\nexport function JWMediaToMediaType(type: string): MWMediaType {\n  if (type === \"movie\") return MWMediaType.MOVIE;\n  if (type === \"show\") return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function formatJWMeta(\n  media: JWMediaResult,\n  season?: JWSeasonMetaResult,\n): MWMediaMeta {\n  const type = JWMediaToMediaType(media.object_type);\n  let seasons: undefined | MWSeasonMeta[];\n  if (type === MWMediaType.SERIES) {\n    seasons = media.seasons\n      ?.sort((a, b) => a.season_number - b.season_number)\n      .map(\n        (v): MWSeasonMeta => ({\n          id: v.id.toString(),\n          number: v.season_number,\n          title: v.title,\n        }),\n      );\n  }\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_year?.toString(),\n    poster: media.poster\n      ? `${JW_IMAGE_BASE}${media.poster.replace(\"{profile}\", \"s166\")}`\n      : undefined,\n    type,\n    seasons: seasons as any,\n    seasonData: season\n      ? ({\n          id: season.id.toString(),\n          number: season.season_number,\n          title: season.title,\n          episodes: season.episodes\n            .sort((a, b) => a.episode_number - b.episode_number)\n            .map((v) => ({\n              id: v.id.toString(),\n              number: v.episode_number,\n              title: v.title,\n            })),\n        } as any)\n      : (undefined as any),\n  };\n}\n\nexport function JWMediaToId(media: MWMediaMeta): string {\n  return [\"JW\", mediaTypeToJW(media.type), media.id].join(\"-\");\n}\n\nexport function decodeJWId(\n  paramId: string,\n): { id: string; type: MWMediaType } | null {\n  const [prefix, type, id] = paramId.split(\"-\", 3);\n  if (prefix !== \"JW\") return null;\n  let mediaType;\n  try {\n    mediaType = JWMediaToMediaType(type);\n  } catch {\n    return null;\n  }\n  return {\n    type: mediaType,\n    id,\n  };\n}\n","export const APP_VERSION = import.meta.env.PACKAGE_VERSION;\nexport const DISCORD_LINK = \"https://discord.gg/7z6znYgrTG\";\nexport const GITHUB_LINK = \"https://github.com/p-stream/p-strean\";\nexport const TWITTER_LINK = \"https://twitter.com/SudoFlix\";\nexport const GA_ID = import.meta.env.VITE_GA_ID;\nexport const BACKEND_URL = import.meta.env.VITE_BACKEND_URL;\n// Do it clap??\n","import {\n  APP_VERSION,\n  BACKEND_URL,\n  DISCORD_LINK,\n  GITHUB_LINK,\n  TWITTER_LINK,\n} from \"./constants\";\n\ninterface Config {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string;\n  TWITTER_LINK: string;\n  TMDB_READ_API_KEY: string;\n  CORS_PROXY_URL: string;\n  M3U8_PROXY_URL: string;\n  NORMAL_ROUTER: boolean;\n  BACKEND_URL: string;\n  DISALLOWED_IDS: string;\n  TURNSTILE_KEY: string;\n  CDN_REPLACEMENTS: string;\n  HAS_ONBOARDING: string;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_PROXY_INSTALL_LINK: string;\n  ALLOW_AUTOPLAY: boolean;\n  ALLOW_FEBBOX_KEY: boolean;\n  ALLOW_REAL_DEBRID_KEY: boolean;\n  SHOW_AD: boolean;\n  AD_CONTENT_URL: string;\n  TRACK_SCRIPT: string;\n}\n\nexport interface RuntimeConfig {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string | null;\n  TWITTER_LINK: string;\n  TMDB_READ_API_KEY: string | null;\n  ALLOW_REAL_DEBRID_KEY: boolean;\n  NORMAL_ROUTER: boolean;\n  PROXY_URLS: string[];\n  M3U8_PROXY_URLS: string[];\n  BACKEND_URL: string | null;\n  DISALLOWED_IDS: string[];\n  TURNSTILE_KEY: string | null;\n  CDN_REPLACEMENTS: Array<string[]>;\n  HAS_ONBOARDING: boolean;\n  ALLOW_AUTOPLAY: boolean;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_PROXY_INSTALL_LINK: string | null;\n  ALLOW_FEBBOX_KEY: boolean;\n  SHOW_AD: boolean;\n  AD_CONTENT_URL: string[];\n  TRACK_SCRIPT: string | null;\n}\n\nconst env: Record<keyof Config, undefined | string> = {\n  TMDB_READ_API_KEY: import.meta.env.VITE_TMDB_READ_API_KEY,\n  APP_VERSION: undefined,\n  GITHUB_LINK: undefined,\n  DISCORD_LINK: undefined,\n  TWITTER_LINK: undefined,\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_CHROME_EXTENSION_INSTALL_LINK,\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK,\n  ONBOARDING_PROXY_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_PROXY_INSTALL_LINK,\n  DMCA_EMAIL: import.meta.env.VITE_DMCA_EMAIL,\n  CORS_PROXY_URL: import.meta.env.VITE_CORS_PROXY_URL,\n  M3U8_PROXY_URL: import.meta.env.VITE_M3U8_PROXY_URL,\n  NORMAL_ROUTER: import.meta.env.VITE_NORMAL_ROUTER,\n  BACKEND_URL: import.meta.env.VITE_BACKEND_URL,\n  DISALLOWED_IDS: import.meta.env.VITE_DISALLOWED_IDS,\n  TURNSTILE_KEY: import.meta.env.VITE_TURNSTILE_KEY,\n  CDN_REPLACEMENTS: import.meta.env.VITE_CDN_REPLACEMENTS,\n  HAS_ONBOARDING: import.meta.env.VITE_HAS_ONBOARDING,\n  ALLOW_AUTOPLAY: import.meta.env.VITE_ALLOW_AUTOPLAY,\n  ALLOW_FEBBOX_KEY: import.meta.env.VITE_ALLOW_FEBBOX_KEY,\n  ALLOW_REAL_DEBRID_KEY: import.meta.env.VITE_ALLOW_REAL_DEBRID_KEY,\n  SHOW_AD: import.meta.env.VITE_SHOW_AD,\n  AD_CONTENT_URL: import.meta.env.VITE_AD_CONTENT_URL,\n  TRACK_SCRIPT: import.meta.env.VITE_TRACK_SCRIPT,\n};\n\nfunction coerceUndefined(value: string | null | undefined): string | undefined {\n  if (value == null) return undefined;\n  if (value.length === 0) return undefined;\n  return value;\n}\n\n// loads from different locations, in order: environment (VITE_{KEY}), window (public/config.js)\nfunction getKeyValue(key: keyof Config): string | undefined {\n  const windowValue = (window as any)?.__CONFIG__?.[`VITE_${key}`];\n\n  return coerceUndefined(env[key]) ?? coerceUndefined(windowValue) ?? undefined;\n}\n\nfunction getKey(key: keyof Config): string | null;\nfunction getKey(key: keyof Config, defaultString: string): string;\nfunction getKey(key: keyof Config, defaultString?: string): string | null {\n  return getKeyValue(key)?.toString() ?? defaultString ?? null;\n}\n\nexport function conf(): RuntimeConfig {\n  return {\n    APP_VERSION,\n    GITHUB_LINK,\n    DISCORD_LINK,\n    TWITTER_LINK,\n    DMCA_EMAIL: getKey(\"DMCA_EMAIL\"),\n    ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: getKey(\n      \"ONBOARDING_CHROME_EXTENSION_INSTALL_LINK\",\n      \"https://docs.pstream.org/extension\",\n    ),\n    ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: getKey(\n      \"ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK\",\n      \"https://docs.pstream.org/extension\",\n    ),\n    ONBOARDING_PROXY_INSTALL_LINK: getKey(\"ONBOARDING_PROXY_INSTALL_LINK\"),\n    BACKEND_URL: getKey(\"BACKEND_URL\", BACKEND_URL),\n    TMDB_READ_API_KEY: getKey(\"TMDB_READ_API_KEY\"),\n    PROXY_URLS: getKey(\"CORS_PROXY_URL\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0),\n    M3U8_PROXY_URLS: getKey(\"M3U8_PROXY_URL\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0),\n    NORMAL_ROUTER: getKey(\"NORMAL_ROUTER\", \"false\") === \"true\",\n    HAS_ONBOARDING: getKey(\"HAS_ONBOARDING\", \"false\") === \"true\",\n    ALLOW_AUTOPLAY: getKey(\"ALLOW_AUTOPLAY\", \"false\") === \"true\",\n    TURNSTILE_KEY: getKey(\"TURNSTILE_KEY\"),\n    DISALLOWED_IDS: getKey(\"DISALLOWED_IDS\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0), // Should be comma-seperated and contain the media type and ID, formatted like so: movie-753342,movie-753342,movie-753342\n    CDN_REPLACEMENTS: getKey(\"CDN_REPLACEMENTS\", \"\")\n      .split(\",\")\n      .map((v) =>\n        v\n          .split(\":\")\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0),\n      )\n      .filter((v) => v.length === 2), // The format is <beforeA>:<afterA>,<beforeB>:<afterB>\n    ALLOW_FEBBOX_KEY: getKey(\"ALLOW_FEBBOX_KEY\", \"false\") === \"true\",\n    ALLOW_REAL_DEBRID_KEY: getKey(\"ALLOW_REAL_DEBRID_KEY\", \"false\") === \"true\",\n    SHOW_AD: getKey(\"SHOW_AD\", \"false\") === \"true\",\n    AD_CONTENT_URL: getKey(\"AD_CONTENT_URL\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0),\n    TRACK_SCRIPT: getKey(\"TRACK_SCRIPT\"),\n  };\n}\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface Account {\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport type AccountWithToken = Account & {\n  sessionId: string;\n  userId: string;\n  token: string;\n  seed: string;\n  deviceName: string;\n};\n\ninterface AuthStore {\n  account: null | AccountWithToken;\n  backendUrl: null | string;\n  proxySet: null | string[];\n  removeAccount(): void;\n  setAccount(acc: AccountWithToken): void;\n  updateDeviceName(deviceName: string): void;\n  updateAccount(acc: Account): void;\n  setAccountProfile(acc: Account[\"profile\"]): void;\n  setBackendUrl(url: null | string): void;\n  setProxySet(urls: null | string[]): void;\n}\n\nexport const useAuthStore = create(\n  persist(\n    immer<AuthStore>((set) => ({\n      account: null,\n      backendUrl: null,\n      proxySet: null,\n      setAccount(acc) {\n        set((s) => {\n          s.account = acc;\n        });\n      },\n      removeAccount() {\n        set((s) => {\n          s.account = null;\n        });\n      },\n      setBackendUrl(v) {\n        set((s) => {\n          s.backendUrl = v;\n        });\n      },\n      setProxySet(urls) {\n        set((s) => {\n          s.proxySet = urls;\n        });\n      },\n      setAccountProfile(profile) {\n        set((s) => {\n          if (s.account) {\n            s.account.profile = profile;\n          }\n        });\n      },\n      updateAccount(acc) {\n        set((s) => {\n          if (!s.account) return;\n          s.account = {\n            ...s.account,\n            ...acc,\n          };\n        });\n      },\n      updateDeviceName(deviceName) {\n        set((s) => {\n          if (!s.account) return;\n          s.account.deviceName = deviceName;\n        });\n      },\n    })),\n    {\n      name: \"__MW::auth\",\n    },\n  ),\n);\n","import { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nconst originalUrls = conf().PROXY_URLS;\nconst types = [\"proxy\", \"api\"] as const;\n\ntype ParsedUrlType = (typeof types)[number];\n\nexport interface ParsedUrl {\n  url: string;\n  type: ParsedUrlType;\n}\n\nfunction canParseUrl(url: string): boolean {\n  try {\n    return !!new URL(url);\n  } catch {\n    return false;\n  }\n}\n\nfunction isParsedUrlType(type: string): type is ParsedUrlType {\n  return types.includes(type as any);\n}\n\n/**\n * Turn a string like \"a=b;c=d;d=e\" into a dictionary object\n */\nfunction parseParams(input: string): Record<string, string> {\n  const entriesParams = input\n    .split(\";\")\n    .map((param) => param.split(\"=\", 2).filter((part) => part.length !== 0))\n    .filter((v) => v.length === 2);\n  return Object.fromEntries(entriesParams);\n}\n\nexport function getParsedUrls() {\n  const urls = useAuthStore.getState().proxySet ?? originalUrls;\n  const output: ParsedUrl[] = [];\n  urls.forEach((url) => {\n    if (!url.startsWith(\"|\")) {\n      if (canParseUrl(url)) {\n        output.push({\n          url,\n          type: \"proxy\",\n        });\n        return;\n      }\n    }\n\n    const match = /^\\|([^|]+)\\|(.*)$/g.exec(url);\n    if (!match || !match[2]) return;\n    if (!canParseUrl(match[2])) return;\n    const params = parseParams(match[1]);\n    const type = params.type ?? \"proxy\";\n\n    if (!isParsedUrlType(type)) return;\n    output.push({\n      url: match[2],\n      type,\n    });\n  });\n\n  return output;\n}\n\nexport function getProxyUrls() {\n  return getParsedUrls()\n    .filter((v) => v.type === \"proxy\")\n    .map((v) => v.url);\n}\n\nexport function getM3U8ProxyUrls(): string[] {\n  return conf().M3U8_PROXY_URLS;\n}\n\nexport function getProviderApiUrls() {\n  return getParsedUrls()\n    .filter((v) => v.type === \"api\")\n    .map((v) => v.url);\n}\n","export enum TMDBContentTypes {\n  MOVIE = \"movie\",\n  TV = \"tv\",\n}\n\nexport type TMDBSeasonShort = {\n  title: string;\n  id: number;\n  season_number: number;\n};\n\nexport type TMDBEpisodeShort = {\n  title: string;\n  id: number;\n  episode_number: number;\n  air_date: string;\n  still_path: string | null;\n  overview: string;\n};\n\nexport type TMDBMediaResult = {\n  title: string;\n  poster?: string;\n  id: number;\n  original_release_date?: Date;\n  object_type: TMDBContentTypes;\n  seasons?: TMDBSeasonShort[];\n};\n\nexport type TMDBSeasonMetaResult = {\n  title: string;\n  id: string;\n  season_number: number;\n  episodes: TMDBEpisodeShort[];\n};\n\nexport interface TMDBShowData {\n  adult: boolean;\n  backdrop_path: string | null;\n  created_by: {\n    id: number;\n    credit_id: string;\n    name: string;\n    gender: number;\n    profile_path: string | null;\n  }[];\n  episode_run_time: number[];\n  first_air_date: string;\n  genres: {\n    id: number;\n    name: string;\n  }[];\n  homepage: string;\n  id: number;\n  in_production: boolean;\n  languages: string[];\n  last_air_date: string;\n  last_episode_to_air: {\n    id: number;\n    name: string;\n    overview: string;\n    vote_average: number;\n    vote_count: number;\n    air_date: string;\n    episode_number: number;\n    production_code: string;\n    runtime: number | null;\n    season_number: number;\n    show_id: number;\n    still_path: string | null;\n  } | null;\n  name: string;\n  next_episode_to_air: {\n    id: number;\n    name: string;\n    overview: string;\n    vote_average: number;\n    vote_count: number;\n    air_date: string;\n    episode_number: number;\n    production_code: string;\n    runtime: number | null;\n    season_number: number;\n    show_id: number;\n    still_path: string | null;\n  } | null;\n  networks: {\n    id: number;\n    logo_path: string;\n    name: string;\n    origin_country: string;\n  }[];\n  number_of_episodes: number;\n  number_of_seasons: number;\n  origin_country: string[];\n  original_language: string;\n  original_name: string;\n  overview: string;\n  popularity: number;\n  poster_path: string | null;\n  production_companies: {\n    id: number;\n    logo_path: string | null;\n    name: string;\n    origin_country: string;\n  }[];\n  production_countries: {\n    iso_3166_1: string;\n    name: string;\n  }[];\n  seasons: {\n    air_date: string;\n    episode_count: number;\n    id: number;\n    name: string;\n    overview: string;\n    poster_path: string | null;\n    season_number: number;\n  }[];\n  spoken_languages: {\n    english_name: string;\n    iso_639_1: string;\n    name: string;\n  }[];\n  status: string;\n  tagline: string;\n  type: string;\n  vote_average: number;\n  vote_count: number;\n  external_ids: {\n    imdb_id: string | null;\n  };\n  credits?: {\n    cast: Array<{\n      id: number;\n      name: string;\n      character: string;\n      profile_path: string | null;\n    }>;\n    crew: Array<{\n      id: number;\n      name: string;\n      job: string;\n      department: string;\n      profile_path: string | null;\n    }>;\n  };\n  content_ratings?: {\n    results: Array<{\n      iso_3166_1: string;\n      rating: string;\n    }>;\n  };\n}\n\nexport interface TMDBMovieData {\n  adult: boolean;\n  backdrop_path: string | null;\n  belongs_to_collection: {\n    id: number;\n    name: string;\n    poster_path: string | null;\n    backdrop_path: string | null;\n  } | null;\n  budget: number;\n  genres: {\n    id: number;\n    name: string;\n  }[];\n  homepage: string | null;\n  id: number;\n  imdb_id: string | null;\n  original_language: string;\n  original_title: string;\n  overview: string | null;\n  popularity: number;\n  poster_path: string | null;\n  production_companies: {\n    id: number;\n    logo_path: string | null;\n    name: string;\n    origin_country: string;\n  }[];\n  production_countries: {\n    iso_3166_1: string;\n    name: string;\n  }[];\n  release_date: string;\n  revenue: number;\n  runtime: number | null;\n  spoken_languages: {\n    english_name: string;\n    iso_639_1: string;\n    name: string;\n  }[];\n  status: string;\n  tagline: string | null;\n  title: string;\n  video: boolean;\n  vote_average: number;\n  vote_count: number;\n  external_ids: {\n    imdb_id: string | null;\n  };\n  credits?: {\n    cast: Array<{\n      id: number;\n      name: string;\n      character: string;\n      profile_path: string | null;\n    }>;\n    crew: Array<{\n      id: number;\n      name: string;\n      job: string;\n      department: string;\n      profile_path: string | null;\n    }>;\n  };\n  release_dates?: {\n    results: Array<{\n      iso_3166_1: string;\n      release_dates: Array<{\n        certification: string;\n        release_date: string;\n      }>;\n    }>;\n  };\n}\n\nexport interface TMDBEpisodeResult {\n  season: number;\n  number: number;\n  title: string;\n  ids: {\n    trakt: number;\n    tvdb: number;\n    imdb: string;\n    tmdb: number;\n  };\n}\n\nexport interface TMDBEpisode {\n  air_date: string;\n  episode_number: number;\n  id: number;\n  name: string;\n  overview: string;\n  production_code: string;\n  runtime: number;\n  season_number: number;\n  show_id: number;\n  still_path: string | null;\n  vote_average: number;\n  vote_count: number;\n  crew: any[];\n  guest_stars: any[];\n}\n\nexport interface TMDBSeason {\n  _id: string;\n  air_date: string;\n  episodes: TMDBEpisode[];\n  name: string;\n  overview: string;\n  id: number;\n  poster_path: string | null;\n  season_number: number;\n}\n\nexport interface ExternalIdMovieSearchResult {\n  movie_results: {\n    adult: boolean;\n    backdrop_path: string;\n    id: number;\n    title: string;\n    original_language: string;\n    original_title: string;\n    overview: string;\n    poster_path: string;\n    media_type: string;\n    genre_ids: number[];\n    popularity: number;\n    release_date: string;\n    video: boolean;\n    vote_average: number;\n    vote_count: number;\n  }[];\n  person_results: any[];\n  tv_results: any[];\n  tv_episode_results: any[];\n  tv_season_results: any[];\n}\n\nexport interface TMDBMovieSearchResult {\n  adult: boolean;\n  backdrop_path: string;\n  id: number;\n  title: string;\n  original_language: string;\n  original_title: string;\n  overview: string;\n  poster_path: string;\n  media_type: TMDBContentTypes.MOVIE;\n  genre_ids: number[];\n  popularity: number;\n  release_date: string;\n  video: boolean;\n  vote_average: number;\n  vote_count: number;\n}\n\nexport interface TMDBShowSearchResult {\n  adult: boolean;\n  backdrop_path: string;\n  id: number;\n  name: string;\n  original_language: string;\n  original_name: string;\n  overview: string;\n  poster_path: string;\n  media_type: TMDBContentTypes.TV;\n  genre_ids: number[];\n  popularity: number;\n  first_air_date: string;\n  vote_average: number;\n  vote_count: number;\n  origin_country: string[];\n}\n\nexport interface TMDBSearchResult {\n  page: number;\n  results: (TMDBMovieSearchResult | TMDBShowSearchResult)[];\n  total_pages: number;\n  total_results: number;\n}\n\nexport interface TMDBCastMember {\n  id: number;\n  name: string;\n  character: string;\n  profile_path: string | null;\n  order: number;\n}\n\nexport interface TMDBCrewMember {\n  id: number;\n  name: string;\n  job: string;\n  department: string;\n  profile_path: string | null;\n}\n\nexport interface TMDBCredits {\n  id: number;\n  cast: TMDBCastMember[];\n  crew: TMDBCrewMember[];\n}\n\nexport interface TMDBPerson {\n  id: number;\n  name: string;\n  biography: string;\n  birthday: string | null;\n  deathday: string | null;\n  place_of_birth: string | null;\n  profile_path: string | null;\n  known_for_department: string;\n}\n\nexport interface TMDBPersonImage {\n  file_path: string;\n  aspect_ratio: number;\n  height: number;\n  width: number;\n  vote_average: number;\n  vote_count: number;\n}\n\nexport interface TMDBPersonImages {\n  id: number;\n  profiles: TMDBPersonImage[];\n}\n","import { satisfies } from \"semver\";\n\nconst allowedExtensionRange = \"^1.0.2\";\n\nexport function isAllowedExtensionVersion(version: string): boolean {\n  return satisfies(version, allowedExtensionRange);\n}\n","import {\n  MessagesMetadata,\n  sendToBackgroundViaRelay,\n} from \"@plasmohq/messaging\";\n\nimport { isAllowedExtensionVersion } from \"@/backend/extension/compatibility\";\nimport { ExtensionMakeRequestResponse } from \"@/backend/extension/plasmo\";\n\nexport const RULE_IDS = {\n  PREPARE_STREAM: 1,\n  SET_DOMAINS_HLS: 2,\n  SET_DOMAINS_HLS_AUDIO: 3,\n};\n\n// for some reason, about 500 ms is needed after\n// page load before the extension starts responding properly\nconst isExtensionReady = new Promise<void>((resolve) => {\n  setTimeout(() => {\n    resolve();\n  }, 500);\n});\n\nlet activeExtension = false;\n\nasync function sendMessage<MessageKey extends keyof MessagesMetadata>(\n  message: MessageKey,\n  payload: MessagesMetadata[MessageKey][\"req\"] | undefined = undefined,\n  timeout: number = -1,\n) {\n  await isExtensionReady;\n  return new Promise<MessagesMetadata[MessageKey][\"res\"] | null>((resolve) => {\n    if (timeout >= 0) setTimeout(() => resolve(null), timeout);\n    sendToBackgroundViaRelay<\n      MessagesMetadata[MessageKey][\"req\"],\n      MessagesMetadata[MessageKey][\"res\"]\n    >({\n      name: message,\n      body: payload,\n    })\n      .then((res) => {\n        activeExtension = true;\n        resolve(res);\n      })\n      .catch(() => {\n        activeExtension = false;\n        resolve(null);\n      });\n  });\n}\n\nexport async function sendExtensionRequest<T>(\n  ops: MessagesMetadata[\"makeRequest\"][\"req\"],\n): Promise<ExtensionMakeRequestResponse<T> | null> {\n  return sendMessage(\"makeRequest\", ops);\n}\n\nexport async function setDomainRule(\n  ops: MessagesMetadata[\"prepareStream\"][\"req\"],\n): Promise<MessagesMetadata[\"prepareStream\"][\"res\"] | null> {\n  return sendMessage(\"prepareStream\", ops);\n}\n\nexport async function sendPage(\n  ops: MessagesMetadata[\"openPage\"][\"req\"],\n): Promise<MessagesMetadata[\"openPage\"][\"res\"] | null> {\n  return sendMessage(\"openPage\", ops);\n}\n\nexport async function extensionInfo(): Promise<\n  MessagesMetadata[\"hello\"][\"res\"] | null\n> {\n  const message = await sendMessage(\"hello\", undefined, 500);\n  return message;\n}\n\nexport function isExtensionActiveCached(): boolean {\n  return activeExtension;\n}\n\nexport async function isExtensionActive(): Promise<boolean> {\n  const info = await extensionInfo();\n  if (!info?.success) return false;\n  const allowedVersion = isAllowedExtensionVersion(info.version);\n  if (!allowedVersion) return false;\n  return info.allowed && info.hasPermission;\n}\n","import { ScrapeMedia } from \"@movie-web/providers\";\nimport { nanoid } from \"nanoid\";\nimport { ofetch } from \"ofetch\";\nimport { useCallback } from \"react\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { ScrapingItems, ScrapingSegment } from \"@/hooks/useProviderScrape\";\nimport { BACKEND_URL } from \"@/setup/constants\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\n// for anybody who cares - these are anonymous metrics.\n// They are just used for figuring out if providers are broken or not\nconst metricsEndpoint = `${BACKEND_URL}/metrics/providers`;\nconst captchaMetricsEndpoint = `${BACKEND_URL}/metrics/captcha`;\nconst batchId = () => nanoid(32);\n\nexport type ProviderMetric = {\n  tmdbId: string;\n  type: string;\n  title: string;\n  seasonId?: string;\n  episodeId?: string;\n  status: \"failed\" | \"notfound\" | \"success\";\n  providerId: string;\n  embedId?: string;\n  errorMessage?: string;\n  fullError?: string;\n};\n\nexport type ScrapeTool = \"default\" | \"custom-proxy\" | \"extension\";\n\nexport function getScrapeTool(): ScrapeTool {\n  if (isExtensionActiveCached()) return \"extension\";\n  const hasProxySet = !!useAuthStore.getState().proxySet;\n  if (hasProxySet) return \"custom-proxy\";\n  return \"default\";\n}\n\nfunction getStackTrace(error: Error, lines: number) {\n  const topMessage = error.toString();\n  const stackTraceLines = (error.stack ?? \"\").split(\"\\n\", lines + 1);\n  stackTraceLines.pop();\n  return `${topMessage}\\n\\n${stackTraceLines.join(\"\\n\")}`;\n}\n\nexport async function reportProviders(items: ProviderMetric[]): Promise<void> {\n  if (!BACKEND_URL) return;\n  return ofetch(metricsEndpoint, {\n    method: \"POST\",\n    body: {\n      items,\n      tool: getScrapeTool(),\n      batchId: batchId(),\n    },\n  });\n}\n\nconst segmentStatusMap: Record<\n  ScrapingSegment[\"status\"],\n  ProviderMetric[\"status\"] | null\n> = {\n  success: \"success\",\n  notfound: \"notfound\",\n  failure: \"failed\",\n  pending: null,\n  waiting: null,\n};\n\nexport function scrapeSourceOutputToProviderMetric(\n  media: PlayerMeta,\n  providerId: string,\n  embedId: string | null,\n  status: ProviderMetric[\"status\"],\n  err: unknown | null,\n): ProviderMetric {\n  const episodeId = media.episode?.tmdbId;\n  const seasonId = media.season?.tmdbId;\n  let error: undefined | Error;\n  if (err instanceof Error) error = err;\n\n  return {\n    status,\n    providerId,\n    title: media.title,\n    tmdbId: media.tmdbId,\n    type: media.type,\n    embedId: embedId ?? undefined,\n    episodeId,\n    seasonId,\n    errorMessage: error?.message,\n    fullError: error ? getStackTrace(error, 5) : undefined,\n  };\n}\n\nexport function scrapeSegmentToProviderMetric(\n  media: ScrapeMedia,\n  providerId: string,\n  segment: ScrapingSegment,\n): ProviderMetric | null {\n  const status = segmentStatusMap[segment.status];\n  if (!status) return null;\n  let episodeId: string | undefined;\n  let seasonId: string | undefined;\n  if (media.type === \"show\") {\n    episodeId = media.episode.tmdbId;\n    seasonId = media.season.tmdbId;\n  }\n  let error: undefined | Error;\n  if (segment.error instanceof Error) error = segment.error;\n\n  return {\n    status,\n    providerId,\n    title: media.title,\n    tmdbId: media.tmdbId,\n    type: media.type,\n    embedId: segment.embedId,\n    episodeId,\n    seasonId,\n    errorMessage: segment.reason ?? error?.message,\n    fullError: error ? getStackTrace(error, 5) : undefined,\n  };\n}\n\nexport function scrapePartsToProviderMetric(\n  media: ScrapeMedia,\n  order: ScrapingItems[],\n  sources: Record<string, ScrapingSegment>,\n): ProviderMetric[] {\n  const output: ProviderMetric[] = [];\n\n  order.forEach((orderItem) => {\n    const source = sources[orderItem.id];\n    orderItem.children.forEach((embedId) => {\n      const embed = sources[embedId];\n      if (!embed.embedId) return;\n      const metric = scrapeSegmentToProviderMetric(media, source.id, embed);\n      if (!metric) return;\n      output.push(metric);\n    });\n\n    const metric = scrapeSegmentToProviderMetric(media, source.id, source);\n    if (!metric) return;\n    output.push(metric);\n  });\n\n  return output;\n}\n\nexport function useReportProviders() {\n  const report = useCallback((items: ProviderMetric[]) => {\n    if (items.length === 0) return;\n    reportProviders(items).catch(() => {});\n  }, []);\n\n  return { report };\n}\n\nexport function reportCaptchaSolve(success: boolean) {\n  if (!BACKEND_URL) return;\n  ofetch(captchaMetricsEndpoint, {\n    method: \"POST\",\n    body: {\n      success,\n    },\n  }).catch(() => {});\n}\n","import { MetaOutput, NotFoundError, ScrapeMedia } from \"@movie-web/providers\";\nimport { jwtDecode } from \"jwt-decode\";\n\nimport { mwFetch } from \"@/backend/helpers/fetch\";\nimport { getTurnstileToken, isTurnstileInitialized } from \"@/stores/turnstile\";\n\nlet metaDataCache: MetaOutput[] | null = null;\nlet token: null | string = null;\n\nexport function setCachedMetadata(data: MetaOutput[]) {\n  metaDataCache = data;\n}\n\nexport function getCachedMetadata(): MetaOutput[] {\n  return metaDataCache ?? [];\n}\n\nexport function setApiToken(newToken: string) {\n  token = newToken;\n}\n\nfunction getTokenIfValid(): null | string {\n  if (!token) return null;\n  try {\n    const body = jwtDecode(token);\n    if (!body.exp) return `jwt|${token}`;\n    if (Date.now() / 1000 < body.exp) return `jwt|${token}`;\n  } catch (err) {\n    // we dont care about parse errors\n  }\n  return null;\n}\n\nexport async function fetchMetadata(base: string) {\n  if (metaDataCache) return;\n  const data = await mwFetch<MetaOutput[][]>(`${base}/metadata`);\n  metaDataCache = data.flat();\n}\n\nfunction scrapeMediaToQueryMedia(media: ScrapeMedia) {\n  let extra: Record<string, string> = {};\n  if (media.type === \"show\") {\n    extra = {\n      episodeNumber: media.episode.number.toString(),\n      episodeTmdbId: media.episode.tmdbId,\n      seasonNumber: media.season.number.toString(),\n      seasonTmdbId: media.season.tmdbId,\n    };\n  }\n\n  return {\n    type: media.type,\n    releaseYear: media.releaseYear.toString(),\n    imdbId: media.imdbId,\n    tmdbId: media.tmdbId,\n    title: media.title,\n    ...extra,\n  };\n}\n\nfunction addQueryDataToUrl(url: URL, data: Record<string, string | undefined>) {\n  Object.entries(data).forEach((entry) => {\n    if (entry[1]) url.searchParams.set(entry[0], entry[1]);\n  });\n}\n\nexport function makeProviderUrl(base: string) {\n  const makeUrl = (p: string) => new URL(`${base}${p}`);\n  return {\n    scrapeSource(sourceId: string, media: ScrapeMedia) {\n      const url = makeUrl(\"/scrape/source\");\n      addQueryDataToUrl(url, scrapeMediaToQueryMedia(media));\n      addQueryDataToUrl(url, { id: sourceId });\n      return url.toString();\n    },\n    scrapeAll(media: ScrapeMedia) {\n      const url = makeUrl(\"/scrape\");\n      addQueryDataToUrl(url, scrapeMediaToQueryMedia(media));\n      return url.toString();\n    },\n    scrapeEmbed(embedId: string, embedUrl: string) {\n      const url = makeUrl(\"/scrape/embed\");\n      addQueryDataToUrl(url, { id: embedId, url: embedUrl });\n      return url.toString();\n    },\n  };\n}\n\nexport async function getApiToken(): Promise<string | null> {\n  let apiToken = getTokenIfValid();\n  if (!apiToken && isTurnstileInitialized()) {\n    apiToken = `turnstile|${await getTurnstileToken()}`;\n  }\n  return apiToken;\n}\n\nfunction parseEventInput(inp: string): any {\n  if (inp.length === 0) return {};\n  return JSON.parse(inp);\n}\n\nexport async function connectServerSideEvents<T>(\n  url: string,\n  endEvents: string[],\n) {\n  const apiToken = await getApiToken();\n\n  // insert token, if its set\n  const parsedUrl = new URL(url);\n  if (apiToken) parsedUrl.searchParams.set(\"token\", apiToken);\n  const eventSource = new EventSource(parsedUrl.toString());\n\n  let promReject: (reason?: any) => void;\n  let promResolve: (value: T) => void;\n  const promise = new Promise<T>((resolve, reject) => {\n    promResolve = resolve;\n    promReject = reject;\n  });\n\n  endEvents.forEach((evt) => {\n    eventSource.addEventListener(evt, (e) => {\n      eventSource.close();\n      promResolve(parseEventInput(e.data));\n    });\n  });\n\n  eventSource.addEventListener(\"token\", (e) => {\n    setApiToken(parseEventInput(e.data));\n  });\n\n  eventSource.addEventListener(\"error\", (err: MessageEvent<any>) => {\n    eventSource.close();\n    if (err.data) {\n      const data = JSON.parse(err.data);\n      let errObj = new Error(\"scrape error\");\n      if (data.name === NotFoundError.name)\n        errObj = new NotFoundError(\"Notfound from server\");\n      Object.assign(errObj, data);\n      promReject(errObj);\n      return;\n    }\n\n    console.error(\"Failed to connect to SSE\", err);\n    promReject(err);\n  });\n\n  eventSource.addEventListener(\"message\", (ev) => {\n    if (!ev) {\n      eventSource.close();\n      return;\n    }\n    setTimeout(() => {\n      promReject(new Error(\"SSE closed improperly\"));\n    }, 1000);\n  });\n\n  return {\n    promise: () => promise,\n    on<Data>(event: string, cb: (data: Data) => void) {\n      eventSource.addEventListener(event, (e) => cb(JSON.parse(e.data)));\n    },\n  };\n}\n","import { ExtensionMakeRequestBodyType } from \"./plasmo\";\n\nexport function getBodyTypeFromBody(\n  body: unknown,\n): ExtensionMakeRequestBodyType {\n  if (typeof body === \"string\") return \"string\";\n  if (body instanceof FormData) return \"FormData\";\n  if (body instanceof URLSearchParams) return \"URLSearchParams\";\n  return \"object\";\n}\n\nexport function convertBodyToObject(body: unknown): any {\n  if (body instanceof FormData || body instanceof URLSearchParams) {\n    return [...body];\n  }\n  return body;\n}\n","import {\n  Fetcher,\n  makeSimpleProxyFetcher,\n  setM3U8ProxyUrl,\n} from \"@movie-web/providers\";\n\nimport { sendExtensionRequest } from \"@/backend/extension/messaging\";\nimport { getApiToken, setApiToken } from \"@/backend/helpers/providerApi\";\nimport {\n  getM3U8ProxyUrls,\n  getProviderApiUrls,\n  getProxyUrls,\n} from \"@/utils/proxyUrls\";\n\nimport { convertBodyToObject, getBodyTypeFromBody } from \"../extension/request\";\n\nfunction makeLoadbalancedList(getter: () => string[]) {\n  let listIndex = -1;\n  return () => {\n    const fetchers = getter();\n    if (listIndex === -1 || listIndex >= fetchers.length) {\n      listIndex = Math.floor(Math.random() * fetchers.length);\n    }\n    const proxyUrl = fetchers[listIndex];\n    listIndex = (listIndex + 1) % fetchers.length;\n    return proxyUrl;\n  };\n}\n\nexport const getLoadbalancedProxyUrl = makeLoadbalancedList(getProxyUrls);\nexport const getLoadbalancedProviderApiUrl =\n  makeLoadbalancedList(getProviderApiUrls);\nexport const getLoadbalancedM3U8ProxyUrl =\n  makeLoadbalancedList(getM3U8ProxyUrls);\n\nasync function fetchButWithApiTokens(\n  input: RequestInfo | URL,\n  init?: RequestInit | undefined,\n): Promise<Response> {\n  const apiToken = await getApiToken();\n  const headers = new Headers(init?.headers);\n  if (apiToken) headers.set(\"X-Token\", apiToken);\n  const response = await fetch(\n    input,\n    init\n      ? {\n          ...init,\n          headers,\n        }\n      : undefined,\n  );\n  const newApiToken = response.headers.get(\"X-Token\");\n  if (newApiToken) setApiToken(newApiToken);\n  return response;\n}\n\nexport function setupM3U8Proxy() {\n  const proxyUrl = getLoadbalancedM3U8ProxyUrl();\n  if (proxyUrl) {\n    setM3U8ProxyUrl(proxyUrl);\n  }\n}\n\nexport function makeLoadBalancedSimpleProxyFetcher() {\n  const fetcher: Fetcher = async (a, b) => {\n    const currentFetcher = makeSimpleProxyFetcher(\n      getLoadbalancedProxyUrl(),\n      fetchButWithApiTokens,\n    );\n    return currentFetcher(a, b);\n  };\n  return fetcher;\n}\n\nfunction makeFinalHeaders(\n  readHeaders: string[],\n  headers: Record<string, string>,\n): Headers {\n  const lowercasedHeaders = readHeaders.map((v) => v.toLowerCase());\n  return new Headers(\n    Object.entries(headers).filter((entry) =>\n      lowercasedHeaders.includes(entry[0].toLowerCase()),\n    ),\n  );\n}\n\nexport function makeExtensionFetcher() {\n  const fetcher: Fetcher = async (url, ops) => {\n    const result = await sendExtensionRequest<any>({\n      url,\n      ...ops,\n      body: convertBodyToObject(ops.body),\n      bodyType: getBodyTypeFromBody(ops.body),\n    });\n    if (!result?.success) throw new Error(`extension error: ${result?.error}`);\n    const res = result.response;\n    return {\n      body: res.body,\n      finalUrl: res.finalUrl,\n      statusCode: res.statusCode,\n      headers: makeFinalHeaders(ops.readHeaders, res.headers),\n    };\n  };\n  return fetcher;\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getApiToken, setApiToken } from \"@/backend/helpers/providerApi\";\nimport { getLoadbalancedProxyUrl } from \"@/backend/providers/fetchers\";\n\ntype P<T> = Parameters<typeof ofetch<T, any>>;\ntype R<T> = ReturnType<typeof ofetch<T, any>>;\n\nconst baseFetch = ofetch.create({\n  retry: 0,\n});\n\nexport function makeUrl(url: string, data: Record<string, string>) {\n  let parsedUrl: string = url;\n  Object.entries(data).forEach(([k, v]) => {\n    parsedUrl = parsedUrl.replace(`{${k}}`, encodeURIComponent(v));\n  });\n  return parsedUrl;\n}\n\nexport function mwFetch<T>(url: string, ops: P<T>[1] = {}): R<T> {\n  return baseFetch<T>(url, ops);\n}\n\nexport async function singularProxiedFetch<T>(\n  proxyUrl: string,\n  url: string,\n  ops: P<T>[1] = {},\n): R<T> {\n  let combinedUrl = ops?.baseURL ?? \"\";\n  if (\n    combinedUrl.length > 0 &&\n    combinedUrl.endsWith(\"/\") &&\n    url.startsWith(\"/\")\n  )\n    combinedUrl += url.slice(1);\n  else if (\n    combinedUrl.length > 0 &&\n    !combinedUrl.endsWith(\"/\") &&\n    !url.startsWith(\"/\")\n  )\n    combinedUrl += `/${url}`;\n  else combinedUrl += url;\n\n  const parsedUrl = new URL(combinedUrl);\n  Object.entries(ops?.params ?? {}).forEach(([k, v]) => {\n    parsedUrl.searchParams.set(k, v);\n  });\n  Object.entries(ops?.query ?? {}).forEach(([k, v]) => {\n    parsedUrl.searchParams.set(k, v);\n  });\n\n  let headers = ops.headers ?? {};\n  const apiToken = await getApiToken();\n  if (apiToken)\n    headers = {\n      ...headers,\n      \"X-Token\": apiToken,\n    };\n\n  return baseFetch<T>(proxyUrl, {\n    ...ops,\n    baseURL: undefined,\n    params: {\n      destination: parsedUrl.toString(),\n    },\n    query: {},\n    headers,\n    onResponse(context) {\n      const tokenHeader = context.response.headers.get(\"X-Token\");\n      if (tokenHeader) setApiToken(tokenHeader);\n\n      if (Array.isArray(ops.onResponse)) {\n        ops.onResponse.forEach((hook) => hook(context));\n      } else {\n        ops.onResponse?.(context);\n      }\n    },\n  });\n}\n\nexport function proxiedFetch<T>(url: string, ops: P<T>[1] = {}): R<T> {\n  return singularProxiedFetch<T>(getLoadbalancedProxyUrl(), url, ops);\n}\n","import slugify from \"slugify\";\n\nimport { conf } from \"@/setup/config\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport { usePreferencesStore } from \"@/stores/preferences\";\nimport { getTmdbLanguageCode } from \"@/utils/language\";\nimport { MediaItem } from \"@/utils/mediaTypes\";\nimport { getProxyUrls } from \"@/utils/proxyUrls\";\n\nimport { MWMediaMeta, MWMediaType, MWSeasonMeta } from \"./types/mw\";\nimport {\n  ExternalIdMovieSearchResult,\n  TMDBContentTypes,\n  TMDBCredits,\n  TMDBEpisodeShort,\n  TMDBMediaResult,\n  TMDBMovieData,\n  TMDBMovieSearchResult,\n  TMDBPerson,\n  TMDBPersonImages,\n  TMDBSearchResult,\n  TMDBSeason,\n  TMDBSeasonMetaResult,\n  TMDBShowData,\n  TMDBShowSearchResult,\n} from \"./types/tmdb\";\nimport { mwFetch } from \"../helpers/fetch\";\n\nexport function mediaTypeToTMDB(type: MWMediaType): TMDBContentTypes {\n  if (type === MWMediaType.MOVIE) return TMDBContentTypes.MOVIE;\n  if (type === MWMediaType.SERIES) return TMDBContentTypes.TV;\n  throw new Error(\"unsupported type\");\n}\n\nexport function mediaItemTypeToMediaType(type: MediaItem[\"type\"]): MWMediaType {\n  if (type === \"movie\") return MWMediaType.MOVIE;\n  if (type === \"show\") return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function TMDBMediaToMediaType(type: TMDBContentTypes): MWMediaType {\n  if (type === TMDBContentTypes.MOVIE) return MWMediaType.MOVIE;\n  if (type === TMDBContentTypes.TV) return MWMediaType.SERIES;\n  throw new Error(\"unsupported type\");\n}\n\nexport function TMDBMediaToMediaItemType(\n  type: TMDBContentTypes,\n): MediaItem[\"type\"] {\n  if (type === TMDBContentTypes.MOVIE) return \"movie\";\n  if (type === TMDBContentTypes.TV) return \"show\";\n  throw new Error(\"unsupported type\");\n}\n\nexport function formatTMDBMeta(\n  media: TMDBMediaResult,\n  season?: TMDBSeasonMetaResult,\n): MWMediaMeta {\n  const type = TMDBMediaToMediaType(media.object_type);\n  let seasons: undefined | MWSeasonMeta[];\n  if (type === MWMediaType.SERIES) {\n    seasons = media.seasons\n      ?.sort((a, b) => a.season_number - b.season_number)\n      .map(\n        (v): MWSeasonMeta => ({\n          title: v.title,\n          id: v.id.toString(),\n          number: v.season_number,\n        }),\n      );\n  }\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_date?.getFullYear()?.toString(),\n    poster: media.poster,\n    type,\n    seasons: seasons as any,\n    seasonData: season\n      ? {\n          id: season.id.toString(),\n          number: season.season_number,\n          title: season.title,\n          episodes: season.episodes\n            .sort((a, b) => a.episode_number - b.episode_number)\n            .map((v) => ({\n              id: v.id.toString(),\n              number: v.episode_number,\n              title: v.title,\n              air_date: v.air_date,\n              still_path: v.still_path,\n              overview: v.overview,\n            })),\n        }\n      : (undefined as any),\n  };\n}\n\nexport function formatTMDBMetaToMediaItem(media: TMDBMediaResult): MediaItem {\n  const type = TMDBMediaToMediaItemType(media.object_type);\n\n  return {\n    title: media.title,\n    id: media.id.toString(),\n    year: media.original_release_date?.getFullYear() ?? 0,\n    release_date: media.original_release_date,\n    poster: media.poster,\n    type,\n  };\n}\n\nexport function TMDBIdToUrlId(\n  type: MWMediaType,\n  tmdbId: string,\n  title: string,\n) {\n  return [\n    \"tmdb\",\n    mediaTypeToTMDB(type),\n    tmdbId,\n    slugify(title, { lower: true, strict: true }),\n  ].join(\"-\");\n}\n\nexport function TMDBMediaToId(media: MWMediaMeta): string {\n  return TMDBIdToUrlId(media.type, media.id, media.title);\n}\n\nexport function mediaItemToId(media: MediaItem): string {\n  return TMDBIdToUrlId(\n    mediaItemTypeToMediaType(media.type),\n    media.id,\n    media.title,\n  );\n}\n\nexport function decodeTMDBId(\n  paramId: string,\n): { id: string; type: MWMediaType } | null {\n  const [prefix, type, id] = paramId.split(\"-\", 3);\n  if (prefix !== \"tmdb\") return null;\n  let mediaType;\n  try {\n    mediaType = TMDBMediaToMediaType(type as TMDBContentTypes);\n  } catch {\n    return null;\n  }\n  return {\n    type: mediaType,\n    id,\n  };\n}\n\nconst tmdbBaseUrl1 = \"https://api.themoviedb.org/3/\";\nconst tmdbBaseUrl2 = \"https://api.tmdb.org/3/\";\n\nconst apiKey = conf().TMDB_READ_API_KEY;\n\nconst tmdbHeaders = {\n  accept: \"application/json\",\n  Authorization: `Bearer ${apiKey}`,\n};\n\nfunction abortOnTimeout(timeout: number): AbortSignal {\n  const controller = new AbortController();\n  setTimeout(() => controller.abort(), timeout);\n  return controller.signal;\n}\n\nlet proxyRotationIndex = 0;\n\nfunction getNextProxy(proxyUrls: string[]): string | undefined {\n  if (!proxyUrls.length) return undefined;\n  const proxy = proxyUrls[proxyRotationIndex % proxyUrls.length];\n  proxyRotationIndex += 1;\n  return proxy;\n}\n\nexport async function get<T>(url: string, params?: object): Promise<T> {\n  const proxyUrls = getProxyUrls();\n  const proxy = getNextProxy(proxyUrls);\n  const shouldProxyTmdb = usePreferencesStore.getState().proxyTmdb;\n  const userLanguage = useLanguageStore.getState().language;\n  const formattedLanguage = getTmdbLanguageCode(userLanguage);\n\n  if (!apiKey) throw new Error(\"TMDB API key not set\");\n\n  // directly writing parameters, otherwise it will start the first parameter in the proxied request as \"&\" instead of \"?\" because it doesnt understand its proxied\n  const fullUrl = new URL(tmdbBaseUrl1 + url);\n  const allParams = {\n    ...params,\n    language: formattedLanguage,\n  };\n\n  if (allParams) {\n    Object.entries(allParams).forEach(([key, value]) => {\n      fullUrl.searchParams.append(key, String(value));\n    });\n  }\n\n  if (proxy && shouldProxyTmdb) {\n    try {\n      return await mwFetch<T>(\n        `/?destination=${encodeURIComponent(fullUrl.toString())}`,\n        {\n          headers: tmdbHeaders,\n          baseURL: proxy,\n          signal: abortOnTimeout(5000),\n        },\n      );\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  try {\n    return await mwFetch<T>(encodeURI(url), {\n      headers: tmdbHeaders,\n      baseURL: tmdbBaseUrl1,\n      params: allParams,\n      signal: abortOnTimeout(5000),\n    });\n  } catch (err) {\n    return mwFetch<T>(encodeURI(url), {\n      headers: tmdbHeaders,\n      baseURL: tmdbBaseUrl2,\n      params: allParams,\n      signal: abortOnTimeout(30000),\n    });\n  }\n}\n\nexport async function multiSearch(\n  query: string,\n): Promise<(TMDBMovieSearchResult | TMDBShowSearchResult)[]> {\n  const data = await get<TMDBSearchResult>(\"search/multi\", {\n    query,\n    include_adult: false,\n    page: 1,\n  });\n  // filter out results that aren't movies or shows\n  const results = data.results.filter(\n    (r) =>\n      r.media_type === TMDBContentTypes.MOVIE ||\n      r.media_type === TMDBContentTypes.TV,\n  );\n  return results;\n}\n\nexport async function generateQuickSearchMediaUrl(\n  query: string,\n): Promise<string | undefined> {\n  const data = await multiSearch(query);\n  if (data.length === 0) return undefined;\n  const result = data[0];\n  const title =\n    result.media_type === TMDBContentTypes.MOVIE ? result.title : result.name;\n\n  return `/media/${TMDBIdToUrlId(\n    TMDBMediaToMediaType(result.media_type),\n    result.id.toString(),\n    title,\n  )}`;\n}\n\n// Conditional type which for inferring the return type based on the content type\ntype MediaDetailReturn<T extends TMDBContentTypes> =\n  T extends TMDBContentTypes.MOVIE\n    ? TMDBMovieData\n    : T extends TMDBContentTypes.TV\n      ? TMDBShowData\n      : never;\n\nexport async function getMediaDetails<\n  T extends TMDBContentTypes,\n  TReturn = MediaDetailReturn<T>,\n>(id: string, type: T): Promise<TReturn> {\n  if (type === TMDBContentTypes.MOVIE) {\n    return get<TReturn>(`/movie/${id}`, {\n      append_to_response: \"external_ids,credits,release_dates\",\n    });\n  }\n  if (type === TMDBContentTypes.TV) {\n    const showData = await get<TReturn>(`/tv/${id}`, {\n      append_to_response: \"external_ids,credits,content_ratings\",\n    });\n\n    // Fetch episodes for each season\n    const showDetails = showData as TMDBShowData;\n    const episodePromises = showDetails.seasons.map(async (season) => {\n      const seasonData = await get<TMDBSeason>(\n        `/tv/${id}/season/${season.season_number}`,\n      );\n      return seasonData.episodes.map((episode) => ({\n        id: episode.id,\n        name: episode.name,\n        episode_number: episode.episode_number,\n        overview: episode.overview,\n        still_path: episode.still_path,\n        air_date: episode.air_date,\n        season_number: season.season_number,\n      }));\n    });\n\n    const allEpisodes = (await Promise.all(episodePromises)).flat();\n\n    return {\n      ...showData,\n      episodes: allEpisodes,\n    } as TReturn;\n  }\n  throw new Error(\"Invalid media type\");\n}\n\nexport function getMediaBackdrop(\n  backdropPath: string | null,\n): string | undefined {\n  const shouldProxyTmdb = usePreferencesStore.getState().proxyTmdb;\n  const imgUrl = `https://image.tmdb.org/t/p/original${backdropPath}`;\n  const proxyUrl = getProxyUrls()[0];\n  if (proxyUrl && shouldProxyTmdb) {\n    return `${proxyUrl}/?destination=${imgUrl}`;\n  }\n  if (backdropPath) return imgUrl;\n}\n\nexport function getMediaPoster(posterPath: string | null): string | undefined {\n  const shouldProxyTmdb = usePreferencesStore.getState().proxyTmdb;\n  const imgUrl = `https://image.tmdb.org/t/p/w342/${posterPath}`;\n\n  if (shouldProxyTmdb) {\n    const proxyUrls = getProxyUrls();\n    const proxy = getNextProxy(proxyUrls);\n    if (proxy) {\n      return `${proxy}/?destination=${imgUrl}`;\n    }\n  }\n\n  if (posterPath) return imgUrl;\n}\n\nexport async function getEpisodes(\n  id: string,\n  season: number,\n): Promise<TMDBEpisodeShort[]> {\n  const data = await get<TMDBSeason>(`/tv/${id}/season/${season}`);\n  return data.episodes.map((e) => ({\n    id: e.id,\n    episode_number: e.episode_number,\n    title: e.name,\n    air_date: e.air_date,\n    still_path: e.still_path,\n    overview: e.overview,\n  }));\n}\n\nexport async function getMovieFromExternalId(\n  imdbId: string,\n): Promise<string | undefined> {\n  const data = await get<ExternalIdMovieSearchResult>(`/find/${imdbId}`, {\n    external_source: \"imdb_id\",\n  });\n\n  const movie = data.movie_results[0];\n  if (!movie) return undefined;\n\n  return movie.id.toString();\n}\n\nexport function formatTMDBSearchResult(\n  result: TMDBMovieSearchResult | TMDBShowSearchResult,\n  mediatype: TMDBContentTypes,\n): TMDBMediaResult {\n  const type = TMDBMediaToMediaType(mediatype);\n  if (type === MWMediaType.SERIES) {\n    const show = result as TMDBShowSearchResult;\n    return {\n      title: show.name,\n      poster: getMediaPoster(show.poster_path),\n      id: show.id,\n      original_release_date: new Date(show.first_air_date),\n      object_type: mediatype,\n    };\n  }\n\n  const movie = result as TMDBMovieSearchResult;\n\n  return {\n    title: movie.title,\n    poster: getMediaPoster(movie.poster_path),\n    id: movie.id,\n    original_release_date: new Date(movie.release_date),\n    object_type: mediatype,\n  };\n}\n\n/**\n * Fetches the clear logo for a movie or show from TMDB images endpoint.\n */\nexport async function getMediaLogo(\n  id: string,\n  type: TMDBContentTypes,\n  language?: string,\n): Promise<string | undefined> {\n  const userLanguage = language || useLanguageStore.getState().language;\n  const formattedLanguage = getTmdbLanguageCode(userLanguage);\n  const url =\n    type === TMDBContentTypes.MOVIE\n      ? `/movie/${id}/images`\n      : `/tv/${id}/images`;\n  try {\n    const data = await get<any>(url, {\n      include_image_language: `${formattedLanguage},en,null`,\n    });\n    // Try to find a logo in the user's language, then English, then any\n    const logo =\n      data.logos?.find((l: any) => l.iso_639_1 === formattedLanguage) ||\n      data.logos?.find((l: any) => l.iso_639_1 === \"en\") ||\n      data.logos?.[0];\n    if (logo && logo.file_path) {\n      return `https://image.tmdb.org/t/p/original${logo.file_path}`;\n    }\n    return undefined;\n  } catch (err) {\n    console.error(\"Failed to fetch TMDB logo:\", err);\n    return undefined;\n  }\n}\n\nexport async function getMediaCredits(\n  id: string,\n  type: TMDBContentTypes,\n): Promise<TMDBCredits> {\n  const endpoint = type === TMDBContentTypes.MOVIE ? \"movie\" : \"tv\";\n  return get<TMDBCredits>(`/${endpoint}/${id}/credits`);\n}\n\nexport async function getRelatedMedia(\n  id: string,\n  type: TMDBContentTypes,\n  limit: number = 10,\n): Promise<TMDBMovieSearchResult[] | TMDBShowSearchResult[]> {\n  const endpoint = type === TMDBContentTypes.MOVIE ? \"movie\" : \"tv\";\n  const data = await get<{\n    results: TMDBMovieSearchResult[] | TMDBShowSearchResult[];\n  }>(`/${endpoint}/${id}/similar`);\n\n  return data.results.slice(0, limit);\n}\n\nexport async function getPersonDetails(id: string): Promise<TMDBPerson> {\n  return get<TMDBPerson>(`/person/${id}`);\n}\n\nexport async function getPersonImages(id: string): Promise<TMDBPersonImages> {\n  return get<TMDBPersonImages>(`/person/${id}/images`);\n}\n\nexport function getPersonProfileImage(\n  profilePath: string | null,\n): string | undefined {\n  const shouldProxyTmdb = usePreferencesStore.getState().proxyTmdb;\n  const imgUrl = `https://image.tmdb.org/t/p/w185/${profilePath}`;\n\n  if (shouldProxyTmdb) {\n    const proxyUrls = getProxyUrls();\n    const proxy = getNextProxy(proxyUrls);\n    if (proxy) {\n      return `${proxy}/?destination=${imgUrl}`;\n    }\n  }\n\n  if (profilePath) return imgUrl;\n}\n","import { FetchError } from \"ofetch\";\n\nimport { useLanguageStore } from \"@/stores/language\";\nimport { getTmdbLanguageCode } from \"@/utils/language\";\n\nimport { formatJWMeta, mediaTypeToJW } from \"./justwatch\";\nimport {\n  TMDBIdToUrlId,\n  TMDBMediaToMediaType,\n  formatTMDBMeta,\n  getEpisodes,\n  getMediaDetails,\n  getMediaPoster,\n  getMovieFromExternalId,\n  mediaTypeToTMDB,\n} from \"./tmdb\";\nimport {\n  JWDetailedMeta,\n  JWSeasonMetaResult,\n  JW_API_BASE,\n} from \"./types/justwatch\";\nimport { MWMediaMeta, MWMediaType } from \"./types/mw\";\nimport {\n  TMDBContentTypes,\n  TMDBMediaResult,\n  TMDBMovieData,\n  TMDBSeasonMetaResult,\n  TMDBShowData,\n} from \"./types/tmdb\";\nimport { makeUrl, proxiedFetch } from \"../helpers/fetch\";\n\nexport interface DetailedMeta {\n  meta: MWMediaMeta;\n  imdbId?: string;\n  tmdbId?: string;\n}\n\nexport function formatTMDBMetaResult(\n  details: TMDBShowData | TMDBMovieData,\n  type: MWMediaType,\n): TMDBMediaResult {\n  if (type === MWMediaType.MOVIE) {\n    const movie = details as TMDBMovieData;\n    return {\n      id: details.id,\n      title: movie.title,\n      object_type: mediaTypeToTMDB(type),\n      poster: getMediaPoster(movie.poster_path) ?? undefined,\n      original_release_date: new Date(movie.release_date),\n    };\n  }\n  if (type === MWMediaType.SERIES) {\n    const show = details as TMDBShowData;\n    return {\n      id: details.id,\n      title: show.name,\n      object_type: mediaTypeToTMDB(type),\n      seasons: show.seasons.map((v) => ({\n        id: v.id,\n        season_number: v.season_number,\n        title: v.name,\n      })),\n      poster: getMediaPoster(show.poster_path) ?? undefined,\n      original_release_date: new Date(show.first_air_date),\n    };\n  }\n\n  throw new Error(\"unsupported type\");\n}\n\nexport async function getMetaFromId(\n  type: MWMediaType,\n  id: string,\n  seasonId?: string,\n): Promise<DetailedMeta | null> {\n  const details = await getMediaDetails(id, mediaTypeToTMDB(type));\n\n  if (!details) return null;\n\n  const imdbId = details.external_ids.imdb_id ?? undefined;\n\n  let seasonData: TMDBSeasonMetaResult | undefined;\n\n  if (type === MWMediaType.SERIES) {\n    const seasons = (details as TMDBShowData).seasons;\n\n    let selectedSeason = seasons.find((v) => v.id.toString() === seasonId);\n    if (!selectedSeason) {\n      selectedSeason = seasons.find((v) => v.season_number === 1);\n    }\n\n    if (selectedSeason) {\n      const episodes = await getEpisodes(\n        details.id.toString(),\n        selectedSeason.season_number,\n      );\n\n      seasonData = {\n        id: selectedSeason.id.toString(),\n        season_number: selectedSeason.season_number,\n        title: selectedSeason.name,\n        episodes,\n      };\n    }\n  }\n\n  const tmdbmeta = formatTMDBMetaResult(details, type);\n  if (!tmdbmeta) return null;\n  const meta = formatTMDBMeta(tmdbmeta, seasonData);\n  if (!meta) return null;\n\n  return {\n    meta,\n    imdbId,\n    tmdbId: id,\n  };\n}\n\nexport async function getLegacyMetaFromId(\n  type: MWMediaType,\n  id: string,\n  seasonId?: string,\n): Promise<DetailedMeta | null> {\n  const queryType = mediaTypeToJW(type);\n  const userLanguage = useLanguageStore.getState().language;\n  const formattedLanguage = getTmdbLanguageCode(userLanguage);\n  const locale = formattedLanguage.replace(\"-\", \"_\");\n\n  let data: JWDetailedMeta;\n  try {\n    const url = makeUrl(`/content/titles/{type}/{id}/locale/${locale}`, {\n      type: queryType,\n      id,\n    });\n    data = await proxiedFetch<JWDetailedMeta>(url, { baseURL: JW_API_BASE });\n  } catch (err) {\n    if (err instanceof FetchError) {\n      // 400 and 404 are treated as not found\n      if (err.statusCode === 400 || err.statusCode === 404) return null;\n    }\n    throw err;\n  }\n\n  let imdbId = data.external_ids.find(\n    (v) => v.provider === \"imdb_latest\",\n  )?.external_id;\n  if (!imdbId)\n    imdbId = data.external_ids.find((v) => v.provider === \"imdb\")?.external_id;\n\n  let tmdbId = data.external_ids.find(\n    (v) => v.provider === \"tmdb_latest\",\n  )?.external_id;\n  if (!tmdbId)\n    tmdbId = data.external_ids.find((v) => v.provider === \"tmdb\")?.external_id;\n\n  let seasonData: JWSeasonMetaResult | undefined;\n  if (data.object_type === \"show\") {\n    const seasonToScrape = seasonId ?? data.seasons?.[0].id.toString() ?? \"\";\n    const url = makeUrl(`/content/titles/show_season/{id}/locale/${locale}`, {\n      id: seasonToScrape,\n    });\n    seasonData = await proxiedFetch<any>(url, { baseURL: JW_API_BASE });\n  }\n\n  return {\n    meta: formatJWMeta(data, seasonData),\n    imdbId,\n    tmdbId,\n  };\n}\n\nexport function isLegacyUrl(url: string): boolean {\n  if (url.startsWith(\"/media/JW\") || url.startsWith(\"/media/tmdb-show\"))\n    return true;\n  return false;\n}\n\nexport function isLegacyMediaType(url: string): boolean {\n  if (url.startsWith(\"/media/tmdb-show\")) return true;\n  return false;\n}\n\nexport async function convertLegacyUrl(\n  url: string,\n): Promise<string | undefined> {\n  if (!isLegacyUrl(url)) return undefined;\n\n  const urlParts = url.split(\"/\").slice(2);\n  const [, type, id] = urlParts[0].split(\"-\", 3);\n  const suffix = urlParts\n    .slice(1)\n    .map((v) => `/${v}`)\n    .join(\"\");\n\n  if (isLegacyMediaType(url)) {\n    const details = await getMediaDetails(id, TMDBContentTypes.TV);\n    return `/media/${TMDBIdToUrlId(\n      MWMediaType.SERIES,\n      details.id.toString(),\n      details.name,\n    )}${suffix}`;\n  }\n\n  const mediaType = TMDBMediaToMediaType(type as TMDBContentTypes);\n  const meta = await getLegacyMetaFromId(mediaType, id);\n\n  if (!meta) return undefined;\n  const { tmdbId, imdbId } = meta;\n  if (!tmdbId && !imdbId) return undefined;\n\n  // movies always have an imdb id on tmdb\n  if (imdbId && mediaType === MWMediaType.MOVIE) {\n    const movieId = await getMovieFromExternalId(imdbId);\n    if (movieId) {\n      return `/media/${TMDBIdToUrlId(mediaType, movieId, meta.meta.title)}`;\n    }\n\n    if (tmdbId) {\n      return `/media/${TMDBIdToUrlId(mediaType, tmdbId, meta.meta.title)}`;\n    }\n  }\n}\n","export class SimpleCache<Key, Value> {\n  protected readonly INTERVAL_MS = 2 * 60 * 1000; // 2 minutes\n\n  protected _interval: ReturnType<typeof setTimeout> | null = null;\n\n  protected _compare: ((a: Key, b: Key) => boolean) | null = null;\n\n  protected _storage: { key: Key; value: Value; expiry: Date }[] = [];\n\n  /*\n   ** initialize store, will start the interval\n   */\n  public initialize(): void {\n    if (this._interval) throw new Error(\"cache is already initialized\");\n    this._interval = setInterval(() => {\n      const now = new Date();\n      this._storage.filter((val) => {\n        if (val.expiry < now) return false; // remove if expiry date is in the past\n        return true;\n      });\n    }, this.INTERVAL_MS);\n  }\n\n  /*\n   ** destroy cache instance, its not safe to use the instance after calling this\n   */\n  public destroy(): void {\n    if (this._interval) clearInterval(this._interval);\n    this.clear();\n  }\n\n  /*\n   ** Set compare function, function must return true if A & B are equal\n   */\n  public setCompare(compare: (a: Key, b: Key) => boolean): void {\n    this._compare = compare;\n  }\n\n  /*\n   ** check if cache contains the item\n   */\n  public has(key: Key): boolean {\n    return !!this.get(key);\n  }\n\n  /*\n   ** get item from cache\n   */\n  public get(key: Key): Value | undefined {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    const foundValue = this._storage.find(\n      (item) => this._compare && this._compare(item.key, key),\n    );\n    if (!foundValue) return undefined;\n    return foundValue.value;\n  }\n\n  /*\n   ** set item from cache, if it already exists, it will overwrite\n   */\n  public set(key: Key, value: Value, expirySeconds: number): void {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    const foundValue = this._storage.find(\n      (item) => this._compare && this._compare(item.key, key),\n    );\n    const expiry = new Date(new Date().getTime() + expirySeconds * 1000);\n\n    // overwrite old value\n    if (foundValue) {\n      foundValue.key = key;\n      foundValue.value = value;\n      foundValue.expiry = expiry;\n      return;\n    }\n\n    // add new value to storage\n    this._storage.push({\n      key,\n      value,\n      expiry,\n    });\n  }\n\n  /*\n   ** remove item from cache\n   */\n  public remove(key: Key): void {\n    if (!this._compare) throw new Error(\"Compare function not set\");\n    this._storage.filter((val) => {\n      if (this._compare && this._compare(val.key, key)) return false; // remove if compare is success\n      return true;\n    });\n  }\n\n  /*\n   ** clear entire cache storage\n   */\n  public clear(): void {\n    this._storage = [];\n  }\n}\n","import { SimpleCache } from \"@/utils/cache\";\nimport { MediaItem } from \"@/utils/mediaTypes\";\n\nimport {\n  formatTMDBMetaToMediaItem,\n  formatTMDBSearchResult,\n  getMediaDetails,\n  getMediaPoster,\n  multiSearch,\n} from \"./tmdb\";\nimport { TMDBContentTypes } from \"./types/tmdb\";\n\nexport interface MWQuery {\n  searchQuery: string;\n}\n\nconst cache = new SimpleCache<MWQuery, MediaItem[]>();\ncache.setCompare((a, b) => {\n  return a.searchQuery.trim() === b.searchQuery.trim();\n});\ncache.initialize();\n\n// detect \"tmdb:123456\" or \"tmdb:123456:movie\" or \"tmdb:123456:tv\"\nconst tmdbIdPattern = /^tmdb:(\\d+)(?::(movie|tv))?$/i;\n\n// detect \"year:YYYY\"\nconst yearPattern = /(.+?)\\s+year:(\\d{4})$/i;\n\nexport async function searchForMedia(query: MWQuery): Promise<MediaItem[]> {\n  if (cache.has(query)) return cache.get(query) as MediaItem[];\n  const { searchQuery } = query;\n\n  // Check if query is a TMDB ID\n  const tmdbMatch = searchQuery.match(tmdbIdPattern);\n  if (tmdbMatch) {\n    const id = tmdbMatch[1];\n    const type =\n      tmdbMatch[2]?.toLowerCase() === \"tv\"\n        ? TMDBContentTypes.TV\n        : TMDBContentTypes.MOVIE;\n\n    try {\n      const details = await getMediaDetails(id, type);\n      if (details) {\n        // Format the media details to our common format\n        const mediaResult =\n          type === TMDBContentTypes.MOVIE\n            ? {\n                id: details.id,\n                title: (details as any).title,\n                poster: getMediaPoster((details as any).poster_path),\n                object_type: type,\n                original_release_date: new Date((details as any).release_date),\n              }\n            : {\n                id: details.id,\n                title: (details as any).name,\n                poster: getMediaPoster((details as any).poster_path),\n                object_type: type,\n                original_release_date: new Date(\n                  (details as any).first_air_date,\n                ),\n              };\n\n        const mediaItem = formatTMDBMetaToMediaItem(mediaResult);\n        const result = [mediaItem];\n        cache.set(query, result, 3600);\n        return result;\n      }\n    } catch (error) {\n      console.error(\"Error fetching by TMDB ID:\", error);\n    }\n  }\n\n  // year extract logic\n  let yearValue: string | undefined;\n  let queryWithoutYear = searchQuery;\n\n  const yearMatch = searchQuery.match(yearPattern);\n  if (yearMatch && yearMatch[2]) {\n    queryWithoutYear = yearMatch[1].trim();\n    yearValue = yearMatch[2];\n  }\n\n  // normal search\n  const data = await multiSearch(queryWithoutYear);\n  let results = data.map((v) => {\n    const formattedResult = formatTMDBSearchResult(v, v.media_type);\n    return formatTMDBMetaToMediaItem(formattedResult);\n  });\n\n  // filter year\n  if (yearValue) {\n    results = results.filter((item) => {\n      const releaseYear = item.release_date?.getFullYear().toString();\n      return releaseYear === yearValue;\n    });\n  }\n\n  const movieWithPosters = results.filter((movie) => movie.poster);\n  const movieWithoutPosters = results.filter((movie) => !movie.poster);\n\n  const sortedresult = movieWithPosters.concat(movieWithoutPosters);\n\n  // cache results for 1 hour\n  cache.set(query, sortedresult, 3600);\n  return sortedresult;\n}\n","function normalizeTitle(title: string): string {\n  return title\n    .trim()\n    .toLowerCase()\n    .replace(/['\":]/g, \"\")\n    .replace(/[^a-zA-Z0-9]+/g, \"_\");\n}\n\nexport function compareTitle(a: string, b: string): boolean {\n  return normalizeTitle(a) === normalizeTitle(b);\n}\n","import { DetailedMeta, getMetaFromId } from \"@/backend/metadata/getmeta\";\nimport { searchForMedia } from \"@/backend/metadata/search\";\nimport { mediaItemTypeToMediaType } from \"@/backend/metadata/tmdb\";\nimport { MWMediaMeta, MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { compareTitle } from \"@/stores/__old/utils\";\n\nimport { WatchedStoreData, WatchedStoreItem } from \"../types\";\n\ninterface OldMediaBase {\n  mediaId: number;\n  mediaType: MWMediaType;\n  percentage: number;\n  progress: number;\n  providerId: string;\n  title: string;\n  year: number;\n}\n\ninterface OldMovie extends OldMediaBase {\n  mediaType: MWMediaType.MOVIE;\n}\n\ninterface OldSeries extends OldMediaBase {\n  mediaType: MWMediaType.SERIES;\n  episodeId: number;\n  seasonId: number;\n}\n\nexport interface OldData {\n  items: (OldMovie | OldSeries)[];\n}\n\nexport interface OldBookmarks {\n  bookmarks: (OldMovie | OldSeries)[];\n}\n\nasync function getMetas(\n  uniqueMedias: Record<string, any>,\n  oldData?: OldData,\n): Promise<Record<string, Record<string, DetailedMeta | null>> | undefined> {\n  const yearsAreClose = (a: number, b: number) => {\n    return Math.abs(a - b) <= 1;\n  };\n\n  const mediaMetas: Record<string, Record<string, DetailedMeta | null>> = {};\n\n  const relevantItems = await Promise.all(\n    Object.values(uniqueMedias).map(async (item) => {\n      const year = Number(item.year.toString().split(\"-\")[0]);\n      const data = await searchForMedia({\n        searchQuery: `${item.title} ${year}`,\n      });\n      const relevantItem = data.find(\n        (res) =>\n          yearsAreClose(Number(res.year), year) &&\n          compareTitle(res.title, item.title),\n      );\n      if (!relevantItem) {\n        console.error(`No item found for migration: ${item.title}`);\n        return;\n      }\n      return {\n        id: item.mediaId,\n        data: relevantItem,\n      };\n    }),\n  );\n\n  for (const item of relevantItems.filter(Boolean)) {\n    if (!item) continue;\n\n    let keys: (string | null)[][] = [[\"0\", \"0\"]];\n    if (item.data.type === \"show\") {\n      const meta = await getMetaFromId(MWMediaType.SERIES, item.data.id);\n      if (!meta || !meta?.meta.seasons) return;\n      const seasonNumbers = [\n        ...new Set(\n          oldData?.items\n            ? oldData.items\n                .filter((watchedEntry: any) => watchedEntry.mediaId === item.id)\n                .map((watchedEntry: any) => watchedEntry.seasonId)\n            : [\"0\"],\n        ),\n      ];\n      const seasons = seasonNumbers.map((num) => ({\n        num,\n        season: meta.meta?.seasons?.[Math.max(0, (num as number) - 1)],\n      }));\n      keys = seasons\n        .map((season) => (season ? [season.num, season?.season?.id] : []))\n        .filter((entry) => entry.length > 0);\n    }\n\n    if (!mediaMetas[item.id]) mediaMetas[item.id] = {};\n    await Promise.all(\n      keys.map(async ([key, id]) => {\n        if (!key) return;\n        mediaMetas[item.id][key] = await getMetaFromId(\n          mediaItemTypeToMediaType(item.data.type),\n          item.data.id,\n          id === \"0\" || id === null ? undefined : id,\n        );\n      }),\n    );\n  }\n\n  return mediaMetas;\n}\n\nexport async function migrateV1Bookmarks(old: OldBookmarks) {\n  const oldData = old;\n  if (!oldData) return;\n\n  const uniqueMedias: Record<string, any> = {};\n  oldData.bookmarks.forEach((item: any) => {\n    if (uniqueMedias[item.mediaId]) return;\n    uniqueMedias[item.mediaId] = item;\n  });\n\n  const mediaMetas = await getMetas(uniqueMedias);\n  if (!mediaMetas) return;\n\n  const bookmarks = Object.keys(mediaMetas)\n    .map((key) => mediaMetas[key][\"0\"])\n    .map((t) => t?.meta)\n    .filter(Boolean);\n\n  return {\n    bookmarks,\n  };\n}\n\nexport async function migrateV2Videos(old: OldData) {\n  const oldData = old;\n  if (!oldData) return;\n\n  const uniqueMedias: Record<string, any> = {};\n  oldData.items.forEach((item: any) => {\n    if (uniqueMedias[item.mediaId]) return;\n    uniqueMedias[item.mediaId] = item;\n  });\n\n  const mediaMetas = await getMetas(uniqueMedias, oldData);\n  if (!mediaMetas) return;\n\n  // We've got all the metadata you can dream of now\n  // Now let's convert stuff into the new format.\n  const newData: WatchedStoreData = {\n    ...oldData,\n    items: [],\n  };\n\n  const now = Date.now();\n\n  for (const oldWatched of oldData.items) {\n    if (oldWatched.mediaType === \"movie\") {\n      if (!mediaMetas[oldWatched.mediaId][\"0\"]?.meta) continue;\n\n      const newItem: WatchedStoreItem = {\n        item: {\n          meta: mediaMetas[oldWatched.mediaId][\"0\"]?.meta as MWMediaMeta,\n        },\n        progress: oldWatched.progress,\n        percentage: oldWatched.percentage,\n        watchedAt: Date.now(), // There was no watchedAt in V2\n      };\n\n      oldData.items = oldData.items.filter(\n        (item) => JSON.stringify(item) !== JSON.stringify(oldWatched),\n      );\n      newData.items.push(newItem);\n    } else if (oldWatched.mediaType === \"series\") {\n      if (!mediaMetas[oldWatched.mediaId][oldWatched.seasonId]?.meta) continue;\n\n      const meta = mediaMetas[oldWatched.mediaId][oldWatched.seasonId]\n        ?.meta as MWMediaMeta;\n\n      if (meta.type !== \"series\") return;\n\n      const newItem: WatchedStoreItem = {\n        item: {\n          meta,\n          series: {\n            episode: Number(oldWatched.episodeId),\n            season: Number(oldWatched.seasonId),\n            seasonId: meta.seasonData.id,\n            episodeId:\n              meta.seasonData.episodes[Number(oldWatched.episodeId) - 1].id,\n          },\n        },\n        progress: oldWatched.progress,\n        percentage: oldWatched.percentage,\n        watchedAt:\n          now +\n          Number(oldWatched.seasonId) * 1000 +\n          Number(oldWatched.episodeId), // There was no watchedAt in V2\n        // JANK ALERT: Put watchedAt in the future to show last episode as most recently\n      };\n\n      if (\n        newData.items.find(\n          (item) =>\n            item.item.meta.id === newItem.item.meta.id &&\n            item.item.series?.episodeId === newItem.item.series?.episodeId,\n        )\n      )\n        continue;\n\n      oldData.items = oldData.items.filter(\n        (item) => JSON.stringify(item) !== JSON.stringify(oldWatched),\n      );\n      newData.items.push(newItem);\n    }\n  }\n\n  return newData;\n}\n","export function isNotNull<T>(obj: T | null): obj is T {\n  return obj != null;\n}\n\nexport type ValuesOf<T> = T[keyof T];\n","import { getLegacyMetaFromId } from \"@/backend/metadata/getmeta\";\nimport {\n  getEpisodes,\n  getMediaDetails,\n  getMovieFromExternalId,\n} from \"@/backend/metadata/tmdb\";\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { TMDBContentTypes } from \"@/backend/metadata/types/tmdb\";\nimport { BookmarkStoreData } from \"@/stores/__old/bookmark/types\";\nimport { isNotNull } from \"@/utils/typeguard\";\n\nimport { WatchedStoreData } from \"../types\";\n\nasync function migrateId(\n  id: string,\n  type: MWMediaType,\n): Promise<string | undefined> {\n  const meta = await getLegacyMetaFromId(type, id);\n\n  if (!meta) return undefined;\n  const { tmdbId, imdbId } = meta;\n  if (!tmdbId && !imdbId) return undefined;\n\n  // movies always have an imdb id on tmdb\n  if (imdbId && type === MWMediaType.MOVIE) {\n    const movieId = await getMovieFromExternalId(imdbId);\n    if (movieId) return movieId;\n  }\n\n  if (tmdbId) {\n    return tmdbId;\n  }\n}\n\nexport async function migrateV2Bookmarks(old: BookmarkStoreData) {\n  const updatedBookmarks = old.bookmarks.map(async (item) => ({\n    ...item,\n    id: await migrateId(item.id, item.type).catch(() => undefined),\n  }));\n\n  return {\n    bookmarks: (await Promise.all(updatedBookmarks)).filter((item) => item.id),\n  };\n}\n\nexport async function migrateV3Videos(\n  old: WatchedStoreData,\n): Promise<WatchedStoreData> {\n  const updatedItems = await Promise.all(\n    old.items.map(async (progress) => {\n      try {\n        const migratedId = await migrateId(\n          progress.item.meta.id,\n          progress.item.meta.type,\n        );\n\n        if (!migratedId) return null;\n\n        const clone = structuredClone(progress);\n        clone.item.meta.id = migratedId;\n        if (clone.item.series) {\n          const series = clone.item.series;\n          const details = await getMediaDetails(\n            migratedId,\n            TMDBContentTypes.TV,\n          );\n\n          const season = details.seasons.find(\n            (v) => v.season_number === series.season,\n          );\n          if (!season) return null;\n\n          const episodes = await getEpisodes(migratedId, season.season_number);\n          const episode = episodes.find(\n            (v) => v.episode_number === series.episode,\n          );\n          if (!episode) return null;\n\n          clone.item.series.episodeId = episode.id.toString();\n          clone.item.series.seasonId = season.id.toString();\n        }\n\n        return clone;\n      } catch (err) {\n        return null;\n      }\n    }),\n  );\n\n  return {\n    items: updatedItems.filter(isNotNull),\n  };\n}\n","import { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { BookmarkMediaItem, useBookmarkStore } from \"@/stores/bookmarks\";\n\nimport { BookmarkStoreData } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\nimport { OldBookmarks, migrateV1Bookmarks } from \"../watched/migrations/v2\";\nimport { migrateV2Bookmarks } from \"../watched/migrations/v3\";\n\nconst typeMap: Record<MWMediaType, \"show\" | \"movie\" | null> = {\n  [MWMediaType.ANIME]: null,\n  [MWMediaType.MOVIE]: \"movie\",\n  [MWMediaType.SERIES]: \"show\",\n};\n\nexport const BookmarkStore = createVersionedStore<BookmarkStoreData>()\n  .setKey(\"mw-bookmarks\")\n  .addVersion({\n    version: 0,\n    migrate(oldBookmarks: OldBookmarks) {\n      return migrateV1Bookmarks(oldBookmarks);\n    },\n  })\n  .addVersion({\n    version: 1,\n    migrate(old: BookmarkStoreData) {\n      return migrateV2Bookmarks(old);\n    },\n  })\n  .addVersion({\n    version: 2,\n    migrate(old: BookmarkStoreData): BookmarkStoreData {\n      const newItems: Record<string, BookmarkMediaItem> = {};\n\n      for (const oldBookmark of old.bookmarks) {\n        const type = typeMap[oldBookmark.type];\n        if (!type) continue;\n        newItems[oldBookmark.id] = {\n          title: oldBookmark.title,\n          year: oldBookmark.year ? Number(oldBookmark.year) : undefined,\n          poster: oldBookmark.poster,\n          type,\n          updatedAt: Date.now(),\n        };\n      }\n\n      useBookmarkStore.getState().replaceBookmarks(newItems);\n\n      return { bookmarks: [] };\n    },\n  })\n  .addVersion({\n    version: 3,\n    create() {\n      return {\n        bookmarks: [],\n      };\n    },\n  })\n  .build();\n","import merge from \"lodash.merge\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface SubtitleStyling {\n  /**\n   * Text color of subtitles, hex string\n   */\n  color: string;\n\n  /**\n   * size percentage, ranges between 0.01 and 2\n   */\n  size: number;\n\n  /**\n   * background opacity, ranges between 0 and 1\n   */\n  backgroundOpacity: number;\n\n  /**\n   * background blur, ranges between 0 and 1\n   */\n  backgroundBlur: number;\n\n  /**\n   * bold, boolean\n   */\n  bold: boolean;\n\n  /**\n   * vertical position percentage, ranges between 1 and 3 (rem)\n   */\n  verticalPosition: number;\n\n  /**\n   * font style for text rendering\n   * \"default\" | \"raised\" | \"depressed\" | \"uniform\" | \"dropShadow\"\n   */\n  fontStyle: string;\n}\n\nexport interface SubtitleStore {\n  lastSync: {\n    lastSelectedLanguage: string | null;\n  };\n  enabled: boolean;\n  lastSelectedLanguage: string | null;\n  isOpenSubtitles: boolean;\n  styling: SubtitleStyling;\n  overrideCasing: boolean;\n  delay: number;\n  showDelayIndicator: boolean;\n  updateStyling(newStyling: Partial<SubtitleStyling>): void;\n  resetStyling(): void;\n  setLanguage(language: string | null): void;\n  setIsOpenSubtitles(isOpenSubtitles: boolean): void;\n  setCustomSubs(): void;\n  setOverrideCasing(enabled: boolean): void;\n  setDelay(delay: number): void;\n  importSubtitleLanguage(lang: string | null): void;\n  resetSubtitleSpecificSettings(): void;\n  setShowDelayIndicator: (show: boolean) => void;\n}\n\nexport const useSubtitleStore = create(\n  persist(\n    immer<SubtitleStore>((set) => ({\n      enabled: false,\n      lastSync: {\n        lastSelectedLanguage: null,\n      },\n      lastSelectedLanguage: null,\n      isOpenSubtitles: false,\n      overrideCasing: false,\n      delay: 0,\n      styling: {\n        color: \"#ffffff\",\n        backgroundOpacity: 0.5,\n        size: 1,\n        backgroundBlur: 0.5,\n        bold: false,\n        verticalPosition: 3,\n        fontStyle: \"default\",\n      },\n      showDelayIndicator: false,\n      resetSubtitleSpecificSettings() {\n        set((s) => {\n          s.delay = 0;\n          s.overrideCasing = false;\n        });\n      },\n      updateStyling(newStyling) {\n        set((s) => {\n          if (newStyling.backgroundOpacity !== undefined)\n            s.styling.backgroundOpacity = Math.min(\n              1,\n              Math.max(0, newStyling.backgroundOpacity),\n            );\n          if (newStyling.backgroundBlur !== undefined)\n            s.styling.backgroundBlur = Math.min(\n              1,\n              Math.max(0, newStyling.backgroundBlur),\n            );\n          if (newStyling.color !== undefined)\n            s.styling.color = newStyling.color.toLowerCase();\n          if (newStyling.size !== undefined)\n            s.styling.size = Math.min(10, Math.max(0.01, newStyling.size));\n          if (newStyling.bold !== undefined) s.styling.bold = newStyling.bold;\n          if (newStyling.verticalPosition !== undefined)\n            s.styling.verticalPosition = Math.min(\n              100,\n              Math.max(0, newStyling.verticalPosition),\n            );\n          if (newStyling.fontStyle !== undefined)\n            s.styling.fontStyle = newStyling.fontStyle;\n        });\n      },\n      resetStyling() {\n        set((s) => {\n          s.styling = {\n            color: \"#ffffff\",\n            backgroundOpacity: 0.5,\n            size: 1,\n            backgroundBlur: 0.5,\n            bold: false,\n            verticalPosition: 3,\n            fontStyle: \"default\",\n          };\n        });\n      },\n      setLanguage(lang) {\n        set((s) => {\n          s.enabled = !!lang;\n          if (lang) s.lastSelectedLanguage = lang;\n        });\n      },\n      setIsOpenSubtitles(isOpenSubtitles) {\n        set((s) => {\n          s.isOpenSubtitles = isOpenSubtitles;\n        });\n      },\n      setCustomSubs() {\n        set((s) => {\n          s.enabled = true;\n          s.lastSelectedLanguage = null;\n        });\n      },\n      setOverrideCasing(enabled) {\n        set((s) => {\n          s.overrideCasing = enabled;\n        });\n      },\n      setDelay(delay) {\n        set((s) => {\n          s.delay = Math.max(Math.min(500, delay), -500);\n        });\n      },\n      importSubtitleLanguage(lang) {\n        set((s) => {\n          s.lastSelectedLanguage = lang;\n          s.lastSync.lastSelectedLanguage = lang;\n        });\n      },\n      setShowDelayIndicator(show: boolean) {\n        set((s) => {\n          s.showDelayIndicator = show;\n        });\n      },\n    })),\n    {\n      name: \"__MW::subtitles\",\n      merge: (persisted, current) => merge({}, current, persisted),\n    },\n  ),\n);\n","import { useLanguageStore } from \"@/stores/language\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\n\nimport { MWSettingsData, MWSettingsDataV1 } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\n\nexport const SettingsStore = createVersionedStore<Record<never, never>>()\n  .setKey(\"mw-settings\")\n  .addVersion({\n    version: 0,\n    create(): MWSettingsDataV1 {\n      return {\n        language: \"en\",\n        captionSettings: {\n          delay: 0,\n          style: {\n            color: \"#ffffff\",\n            fontSize: 25,\n            backgroundColor: \"#00000096\",\n          },\n        },\n      };\n    },\n    migrate(data: MWSettingsDataV1): MWSettingsData {\n      return {\n        language: data.language,\n        captionSettings: {\n          language: \"none\",\n          ...data.captionSettings,\n        },\n      };\n    },\n  })\n  .addVersion({\n    version: 1,\n    migrate(old: MWSettingsData): Record<never, never> {\n      const langStore = useLanguageStore.getState();\n      const subtitleStore = useSubtitleStore.getState();\n\n      const backgroundColor = old.captionSettings.style.backgroundColor;\n      let backgroundOpacity = 0.5;\n      if (backgroundColor.length === 9) {\n        const opacitySplit = backgroundColor.slice(7); // '#' + 6 digits\n        backgroundOpacity = parseInt(opacitySplit, 16) / 255; // read as hex;\n      }\n\n      langStore.setLanguage(old.language);\n      subtitleStore.updateStyling({\n        backgroundOpacity,\n        color: old.captionSettings.style.color,\n        size: old.captionSettings.style.fontSize / 25,\n      });\n      subtitleStore.importSubtitleLanguage(\n        old.captionSettings.language === \"none\"\n          ? null\n          : old.captionSettings.language,\n      );\n\n      return {};\n    },\n  })\n  .addVersion({\n    version: 2,\n    create(): Record<never, never> {\n      return {};\n    },\n  })\n  .build();\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface VolumeStore {\n  volume: number;\n  setVolume(v: number): void;\n}\n\nexport interface EmpheralVolumeStore {\n  showVolume: boolean;\n  setShowVolume(v: boolean): void;\n}\n\nexport const useVolumeStore = create(\n  persist(\n    immer<VolumeStore>((set) => ({\n      volume: 1,\n      setVolume(v: number) {\n        set((s) => {\n          s.volume = v;\n        });\n      },\n    })),\n    {\n      name: \"__MW::volume\",\n    },\n  ),\n);\n\nexport const useEmpheralVolumeStore = create(\n  immer<EmpheralVolumeStore>((set) => ({\n    showVolume: false,\n    setShowVolume(bool: boolean) {\n      set((s) => {\n        s.showVolume = bool;\n      });\n    },\n  })),\n);\n","import { useVolumeStore } from \"@/stores/volume\";\n\nimport { createVersionedStore } from \"../migrations\";\n\ninterface VolumeStoreData {\n  volume: number;\n}\n\nexport const volumeStore = createVersionedStore<Record<never, never>>()\n  .setKey(\"mw-volume\")\n  .addVersion({\n    version: 0,\n    create() {\n      return {\n        volume: 1,\n      };\n    },\n    migrate(data: VolumeStoreData): Record<never, never> {\n      useVolumeStore.getState().setVolume(data.volume);\n      return {};\n    },\n  })\n  .addVersion({\n    version: 1,\n    create() {\n      return {};\n    },\n  })\n  .build();\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { PlayerMeta } from \"@/stores/player/slices/source\";\n\nexport interface ProgressItem {\n  watched: number;\n  duration: number;\n}\n\nexport interface ProgressSeasonItem {\n  title: string;\n  number: number;\n  id: string;\n}\n\nexport interface ProgressEpisodeItem {\n  title: string;\n  number: number;\n  id: string;\n  seasonId: string;\n  updatedAt: number;\n  progress: ProgressItem;\n}\n\nexport interface ProgressMediaItem {\n  title: string;\n  year?: number;\n  poster?: string;\n  type: \"show\" | \"movie\";\n  progress?: ProgressItem;\n  updatedAt: number;\n  seasons: Record<string, ProgressSeasonItem>;\n  episodes: Record<string, ProgressEpisodeItem>;\n}\n\nexport interface ProgressUpdateItem {\n  title?: string;\n  year?: number;\n  poster?: string;\n  type?: \"show\" | \"movie\";\n  progress?: ProgressItem;\n  tmdbId: string;\n  id: string;\n  episodeId?: string;\n  seasonId?: string;\n  episodeNumber?: number;\n  seasonNumber?: number;\n  action: \"upsert\" | \"delete\";\n}\n\nexport interface UpdateItemOptions {\n  meta: PlayerMeta;\n  progress: ProgressItem;\n}\n\nexport interface ProgressStore {\n  items: Record<string, ProgressMediaItem>;\n  updateQueue: ProgressUpdateItem[];\n  updateItem(ops: UpdateItemOptions): void;\n  removeItem(id: string): void;\n  replaceItems(items: Record<string, ProgressMediaItem>): void;\n  clear(): void;\n  clearUpdateQueue(): void;\n  removeUpdateItem(id: string): void;\n}\n\nlet updateId = 0;\n\nexport const useProgressStore = create(\n  persist(\n    immer<ProgressStore>((set) => ({\n      items: {},\n      updateQueue: [],\n      removeItem(id) {\n        set((s) => {\n          updateId += 1;\n          s.updateQueue.push({\n            id: updateId.toString(),\n            action: \"delete\",\n            tmdbId: id,\n          });\n\n          delete s.items[id];\n        });\n      },\n      replaceItems(items: Record<string, ProgressMediaItem>) {\n        set((s) => {\n          s.items = items;\n        });\n      },\n      updateItem({ meta, progress }) {\n        set((s) => {\n          // add to updateQueue\n          updateId += 1;\n          s.updateQueue.push({\n            tmdbId: meta.tmdbId,\n            title: meta.title,\n            year: meta.releaseYear,\n            poster: meta.poster,\n            type: meta.type,\n            progress: { ...progress },\n            id: updateId.toString(),\n            episodeId: meta.episode?.tmdbId,\n            seasonId: meta.season?.tmdbId,\n            seasonNumber: meta.season?.number,\n            episodeNumber: meta.episode?.number,\n            action: \"upsert\",\n          });\n\n          // add to progress store\n          if (!s.items[meta.tmdbId])\n            s.items[meta.tmdbId] = {\n              type: meta.type,\n              episodes: {},\n              seasons: {},\n              updatedAt: 0,\n              title: meta.title,\n              year: meta.releaseYear,\n              poster: meta.poster,\n            };\n          const item = s.items[meta.tmdbId];\n          item.updatedAt = Date.now();\n\n          if (meta.type === \"movie\") {\n            if (!item.progress)\n              item.progress = {\n                duration: 0,\n                watched: 0,\n              };\n            item.progress = { ...progress };\n            return;\n          }\n\n          if (!meta.episode || !meta.season) return;\n\n          if (!item.seasons[meta.season.tmdbId])\n            item.seasons[meta.season.tmdbId] = {\n              id: meta.season.tmdbId,\n              number: meta.season.number,\n              title: meta.season.title,\n            };\n\n          if (!item.episodes[meta.episode.tmdbId])\n            item.episodes[meta.episode.tmdbId] = {\n              id: meta.episode.tmdbId,\n              number: meta.episode.number,\n              title: meta.episode.title,\n              seasonId: meta.season.tmdbId,\n              updatedAt: Date.now(),\n              progress: {\n                duration: 0,\n                watched: 0,\n              },\n            };\n\n          item.episodes[meta.episode.tmdbId].progress = { ...progress };\n        });\n      },\n      clear() {\n        set((s) => {\n          s.items = {};\n        });\n      },\n      clearUpdateQueue() {\n        set((s) => {\n          s.updateQueue = [];\n        });\n      },\n      removeUpdateItem(id: string) {\n        set((s) => {\n          s.updateQueue = [...s.updateQueue.filter((v) => v.id !== id)];\n        });\n      },\n    })),\n    {\n      name: \"__MW::progress\",\n    },\n  ),\n);\n","import { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nimport { WatchedStoreData } from \"../types\";\n\nexport function migrateV4Videos(old: WatchedStoreData) {\n  // Convert items\n  const newItems: Record<string, ProgressMediaItem> = {};\n\n  for (const oldItem of old.items) {\n    if (oldItem.item.meta.type === MWMediaType.SERIES) {\n      // Upsert\n      if (!newItems[oldItem.item.meta.id]) {\n        newItems[oldItem.item.meta.id] = {\n          type: \"show\",\n          episodes: {},\n          seasons: {},\n          title: oldItem.item.meta.title,\n          updatedAt: oldItem.watchedAt,\n          poster: oldItem.item.meta.poster,\n          year: Number(oldItem.item.meta.year),\n        };\n      }\n\n      // Add episodes\n      if (\n        oldItem.item.series &&\n        !newItems[oldItem.item.meta.id].episodes[oldItem.item.series.episodeId]\n      ) {\n        // Find episode ID (barely ever works)\n        const episodeTitle = oldItem.item.meta.seasonData.episodes.find(\n          (ep) => ep.number === oldItem.item.series?.episode,\n        )?.title;\n\n        // Add season to season data\n        newItems[oldItem.item.meta.id].seasons[oldItem.item.series.seasonId] = {\n          id: oldItem.item.series.seasonId,\n          number: oldItem.item.series.season,\n          title:\n            oldItem.item.meta.seasons.find(\n              (s) => s.number === oldItem.item.series?.season,\n            )?.title || \"Unknown season\",\n        };\n\n        // Populate episode data\n        newItems[oldItem.item.meta.id].episodes[oldItem.item.series.episodeId] =\n          {\n            title: episodeTitle || \"Unknown\",\n            id: oldItem.item.series.episodeId,\n            number: oldItem.item.series.episode,\n            seasonId: oldItem.item.series.seasonId,\n            updatedAt: oldItem.watchedAt,\n            progress: {\n              duration: (100 / oldItem.percentage) * oldItem.progress,\n              watched: oldItem.progress,\n            },\n          };\n      }\n    } else {\n      newItems[oldItem.item.meta.id] = {\n        type: \"movie\",\n        episodes: {},\n        seasons: {},\n        title: oldItem.item.meta.title,\n        updatedAt: oldItem.watchedAt,\n        year: Number(oldItem.item.meta.year),\n        poster: oldItem.item.meta.poster,\n        progress: {\n          duration: (100 / oldItem.percentage) * oldItem.progress,\n          watched: oldItem.progress,\n        },\n      };\n    }\n  }\n\n  return newItems;\n}\n","import { useProgressStore } from \"@/stores/progress\";\n\nimport { OldData, migrateV2Videos } from \"./migrations/v2\";\nimport { migrateV3Videos } from \"./migrations/v3\";\nimport { migrateV4Videos } from \"./migrations/v4\";\nimport { WatchedStoreData } from \"./types\";\nimport { createVersionedStore } from \"../migrations\";\n\nexport const VideoProgressStore = createVersionedStore<WatchedStoreData>()\n  .setKey(\"video-progress\")\n  .addVersion({\n    version: 0,\n    migrate() {\n      return {\n        items: [], // dont migrate from version 0 to version 1, unmigratable\n      };\n    },\n  })\n  .addVersion({\n    version: 1,\n    async migrate(old: OldData) {\n      return migrateV2Videos(old);\n    },\n  })\n  .addVersion({\n    version: 2,\n    migrate(old: WatchedStoreData) {\n      return migrateV3Videos(old);\n    },\n  })\n  .addVersion({\n    version: 3,\n    migrate(old: WatchedStoreData): WatchedStoreData {\n      useProgressStore.getState().replaceItems(migrateV4Videos(old));\n\n      return {\n        items: [],\n      };\n    },\n  })\n  .addVersion({\n    version: 4,\n    create() {\n      return {\n        items: [],\n      };\n    },\n  })\n  .build();\n","import { ofetch } from \"ofetch\";\n\nexport interface SessionResponse {\n  id: string;\n  userId: string;\n  createdAt: string;\n  accessedAt: string;\n  device: string;\n  userAgent: string;\n}\nexport interface LoginResponse {\n  session: SessionResponse;\n  token: string;\n}\n\nexport function getAuthHeaders(token: string): Record<string, string> {\n  return {\n    authorization: `Bearer ${token}`,\n  };\n}\n\nexport async function accountLogin(\n  url: string,\n  id: string,\n  deviceName: string,\n): Promise<LoginResponse> {\n  return ofetch<LoginResponse>(\"/auth/login\", {\n    method: \"POST\",\n    body: {\n      id,\n      device: deviceName,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { BookmarkResponse } from \"@/backend/accounts/user\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\n\nexport interface BookmarkMetaInput {\n  title: string;\n  year: number;\n  poster?: string;\n  type: string;\n}\n\nexport interface BookmarkInput {\n  tmdbId: string;\n  meta: BookmarkMetaInput;\n}\n\nexport function bookmarkMediaToInput(\n  tmdbId: string,\n  item: BookmarkMediaItem,\n): BookmarkInput {\n  return {\n    meta: {\n      title: item.title,\n      type: item.type,\n      poster: item.poster,\n      year: item.year ?? 0,\n    },\n    tmdbId,\n  };\n}\n\nexport async function addBookmark(\n  url: string,\n  account: AccountWithToken,\n  input: BookmarkInput,\n) {\n  return ofetch<BookmarkResponse>(\n    `/users/${account.userId}/bookmarks/${input.tmdbId}`,\n    {\n      method: \"POST\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n      body: input,\n    },\n  );\n}\n\nexport async function removeBookmark(\n  url: string,\n  account: AccountWithToken,\n  id: string,\n) {\n  return ofetch<{ tmdbId: string }>(\n    `/users/${account.userId}/bookmarks/${id}`,\n    {\n      method: \"DELETE\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n    },\n  );\n}\n","import { pbkdf2Async } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { generateMnemonic, validateMnemonic } from \"@scure/bip39\";\nimport { wordlist } from \"@scure/bip39/wordlists/english\";\nimport forge from \"node-forge\";\n\ntype Keys = {\n  privateKey: Uint8Array;\n  publicKey: Uint8Array;\n  seed: Uint8Array;\n};\n\nfunction uint8ArrayToBuffer(array: Uint8Array): forge.util.ByteStringBuffer {\n  return forge.util.createBuffer(\n    Array.from(array)\n      .map((byte) => String.fromCharCode(byte))\n      .join(\"\"),\n  );\n}\n\nasync function seedFromMnemonic(mnemonic: string) {\n  return pbkdf2Async(sha256, mnemonic, \"mnemonic\", {\n    c: 2048,\n    dkLen: 32,\n  });\n}\n\nexport function verifyValidMnemonic(mnemonic: string) {\n  return validateMnemonic(mnemonic, wordlist);\n}\n\nexport async function keysFromSeed(seed: Uint8Array): Promise<Keys> {\n  const { privateKey, publicKey } = forge.pki.ed25519.generateKeyPair({\n    seed,\n  });\n\n  return {\n    privateKey: new Uint8Array(privateKey),\n    publicKey: new Uint8Array(publicKey),\n    seed,\n  };\n}\n\nexport async function keysFromMnemonic(mnemonic: string): Promise<Keys> {\n  const seed = await seedFromMnemonic(mnemonic);\n\n  return keysFromSeed(seed);\n}\n\nexport function genMnemonic(): string {\n  return generateMnemonic(wordlist);\n}\n\nexport async function signCode(\n  code: string,\n  privateKey: Uint8Array,\n): Promise<Uint8Array> {\n  const signature = forge.pki.ed25519.sign({\n    encoding: \"utf8\",\n    message: code,\n    privateKey: uint8ArrayToBuffer(privateKey),\n  });\n  return new Uint8Array(signature);\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  return forge.util.encode64(String.fromCodePoint(...bytes));\n}\n\nexport function bytesToBase64Url(bytes: Uint8Array): string {\n  return bytesToBase64(bytes)\n    .replace(/\\//g, \"_\")\n    .replace(/\\+/g, \"-\")\n    .replace(/=+$/, \"\");\n}\n\nexport async function signChallenge(keys: Keys, challengeCode: string) {\n  const signature = await signCode(challengeCode, keys.privateKey);\n  return bytesToBase64Url(signature);\n}\n\nexport function base64ToBuffer(data: string) {\n  return forge.util.binary.base64.decode(data);\n}\n\nexport function base64ToStringBuffer(data: string) {\n  const decoded = base64ToBuffer(data);\n\n  return uint8ArrayToBuffer(decoded);\n}\n\nexport function stringBufferToBase64(buffer: forge.util.ByteStringBuffer) {\n  return forge.util.encode64(buffer.getBytes());\n}\n\nexport async function encryptData(data: string, secret: Uint8Array) {\n  if (secret.byteLength !== 32)\n    throw new Error(\"Secret must be at least 256-bit\");\n\n  const iv = await new Promise<string>((resolve, reject) => {\n    forge.random.getBytes(16, (err, bytes) => {\n      if (err) reject(err);\n      resolve(bytes);\n    });\n  });\n\n  const cipher = forge.cipher.createCipher(\n    \"AES-GCM\",\n    uint8ArrayToBuffer(secret),\n  );\n  cipher.start({\n    iv,\n    tagLength: 128,\n  });\n  cipher.update(forge.util.createBuffer(data, \"utf8\"));\n  cipher.finish();\n\n  const encryptedData = cipher.output;\n  const tag = cipher.mode.tag;\n\n  return `${forge.util.encode64(iv)}.${stringBufferToBase64(\n    encryptedData,\n  )}.${stringBufferToBase64(tag)}` as const;\n}\n\nexport function decryptData(data: string, secret: Uint8Array) {\n  if (secret.byteLength !== 32) throw new Error(\"Secret must be 256-bit\");\n\n  const [iv, encryptedData, tag] = data.split(\".\");\n\n  const decipher = forge.cipher.createDecipher(\n    \"AES-GCM\",\n    uint8ArrayToBuffer(secret),\n  );\n  decipher.start({\n    iv: base64ToStringBuffer(iv),\n    tag: base64ToStringBuffer(tag),\n    tagLength: 128,\n  });\n  decipher.update(base64ToStringBuffer(encryptedData));\n  const pass = decipher.finish();\n\n  if (!pass) throw new Error(\"Error decrypting data\");\n\n  return decipher.output.toString();\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nimport { BookmarkInput } from \"./bookmarks\";\nimport { ProgressInput } from \"./progress\";\n\nexport function importProgress(\n  url: string,\n  account: AccountWithToken,\n  progressItems: ProgressInput[],\n) {\n  return ofetch<void>(`/users/${account.userId}/progress/import`, {\n    method: \"PUT\",\n    body: progressItems,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n\nexport function importBookmarks(\n  url: string,\n  account: AccountWithToken,\n  bookmarks: BookmarkInput[],\n) {\n  return ofetch<void>(`/users/${account.userId}/bookmarks`, {\n    method: \"PUT\",\n    body: bookmarks,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\n\nexport interface ChallengeTokenResponse {\n  challenge: string;\n}\n\nexport async function getLoginChallengeToken(\n  url: string,\n  publicKey: string,\n): Promise<ChallengeTokenResponse> {\n  return ofetch<ChallengeTokenResponse>(\"/auth/login/start\", {\n    method: \"POST\",\n    body: {\n      publicKey,\n    },\n    baseURL: url,\n  });\n}\n\nexport interface LoginResponse {\n  session: SessionResponse;\n  token: string;\n}\n\nexport interface LoginInput {\n  publicKey: string;\n  challenge: {\n    code: string;\n    signature: string;\n  };\n  device: string;\n}\n\nexport async function loginAccount(\n  url: string,\n  data: LoginInput,\n): Promise<LoginResponse> {\n  return ofetch<LoginResponse>(\"/auth/login/complete\", {\n    method: \"POST\",\n    body: {\n      namespace: \"movie-web\",\n      ...data,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { ProgressResponse } from \"@/backend/accounts/user\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { ProgressMediaItem, ProgressUpdateItem } from \"@/stores/progress\";\n\nexport interface ProgressInput {\n  meta?: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: string;\n  };\n  tmdbId: string;\n  watched: number;\n  duration: number;\n  seasonId?: string;\n  episodeId?: string;\n  seasonNumber?: number;\n  episodeNumber?: number;\n  updatedAt?: string;\n}\n\nexport function progressUpdateItemToInput(\n  item: ProgressUpdateItem,\n): ProgressInput {\n  return {\n    duration: item.progress?.duration ?? 0,\n    watched: item.progress?.watched ?? 0,\n    tmdbId: item.tmdbId,\n    meta: {\n      title: item.title ?? \"\",\n      type: item.type ?? \"\",\n      year: item.year ?? NaN,\n      poster: item.poster,\n    },\n    episodeId: item.episodeId,\n    seasonId: item.seasonId,\n    episodeNumber: item.episodeNumber,\n    seasonNumber: item.seasonNumber,\n  };\n}\n\nexport function progressMediaItemToInputs(\n  tmdbId: string,\n  item: ProgressMediaItem,\n): ProgressInput[] {\n  if (item.type === \"show\") {\n    return Object.entries(item.episodes).flatMap(([_, episode]) => ({\n      duration: item.progress?.duration ?? episode.progress.duration,\n      watched: item.progress?.watched ?? episode.progress.watched,\n      tmdbId,\n      meta: {\n        title: item.title ?? \"\",\n        type: item.type ?? \"\",\n        year: item.year ?? NaN,\n        poster: item.poster,\n      },\n      episodeId: episode.id,\n      seasonId: episode.seasonId,\n      episodeNumber: episode.number,\n      seasonNumber: item.seasons[episode.seasonId].number,\n      updatedAt: new Date(episode.updatedAt).toISOString(),\n    }));\n  }\n  return [\n    {\n      duration: item.progress?.duration ?? 0,\n      watched: item.progress?.watched ?? 0,\n      tmdbId,\n      updatedAt: new Date(item.updatedAt).toISOString(),\n      meta: {\n        title: item.title ?? \"\",\n        type: item.type ?? \"\",\n        year: item.year ?? NaN,\n        poster: item.poster,\n      },\n    },\n  ];\n}\n\nexport async function setProgress(\n  url: string,\n  account: AccountWithToken,\n  input: ProgressInput,\n) {\n  return ofetch<ProgressResponse>(\n    `/users/${account.userId}/progress/${input.tmdbId}`,\n    {\n      method: \"PUT\",\n      headers: getAuthHeaders(account.token),\n      baseURL: url,\n      body: input,\n    },\n  );\n}\n\nexport async function removeProgress(\n  url: string,\n  account: AccountWithToken,\n  id: string,\n  episodeId?: string,\n  seasonId?: string,\n) {\n  await ofetch(`/users/${account.userId}/progress/${id}`, {\n    method: \"DELETE\",\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n    body: {\n      episodeId,\n      seasonId,\n    },\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\nimport { UserResponse } from \"@/backend/accounts/user\";\n\nexport interface ChallengeTokenResponse {\n  challenge: string;\n}\n\nexport async function getRegisterChallengeToken(\n  url: string,\n  captchaToken?: string,\n): Promise<ChallengeTokenResponse> {\n  return ofetch<ChallengeTokenResponse>(\"/auth/register/start\", {\n    method: \"POST\",\n    body: {\n      captchaToken,\n    },\n    baseURL: url,\n  });\n}\n\nexport interface RegisterResponse {\n  user: UserResponse;\n  session: SessionResponse;\n  token: string;\n}\n\nexport interface RegisterInput {\n  publicKey: string;\n  challenge: {\n    code: string;\n    signature: string;\n  };\n  device: string;\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport async function registerAccount(\n  url: string,\n  data: RegisterInput,\n): Promise<RegisterResponse> {\n  return ofetch<RegisterResponse>(\"/auth/register/complete\", {\n    method: \"POST\",\n    body: {\n      namespace: \"movie-web\",\n      ...data,\n    },\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nexport interface SessionResponse {\n  id: string;\n  userId: string;\n  createdAt: string;\n  accessedAt: string;\n  device: string;\n  userAgent: string;\n}\n\nexport interface SessionUpdate {\n  deviceName: string;\n}\n\nexport async function getSessions(url: string, account: AccountWithToken) {\n  return ofetch<SessionResponse[]>(`/users/${account.userId}/sessions`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function updateSession(\n  url: string,\n  account: AccountWithToken,\n  update: SessionUpdate,\n) {\n  return ofetch<SessionResponse[]>(`/sessions/${account.sessionId}`, {\n    method: \"PATCH\",\n    headers: getAuthHeaders(account.token),\n    body: update,\n    baseURL: url,\n  });\n}\n\nexport async function removeSession(\n  url: string,\n  token: string,\n  sessionId: string,\n) {\n  return ofetch<SessionResponse[]>(`/sessions/${sessionId}`, {\n    method: \"DELETE\",\n    headers: getAuthHeaders(token),\n    baseURL: url,\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\n\nexport interface SettingsInput {\n  applicationLanguage?: string;\n  applicationTheme?: string | null;\n  defaultSubtitleLanguage?: string;\n  proxyUrls?: string[] | null;\n  febboxKey?: string | null;\n  realDebridKey?: string | null;\n  enableThumbnails?: boolean;\n  enableAutoplay?: boolean;\n  enableSkipCredits?: boolean;\n  enableDiscover?: boolean;\n  enableFeatured?: boolean;\n  enableDetailsModal?: boolean;\n  enableImageLogos?: boolean;\n  enableCarouselView?: boolean;\n  forceCompactEpisodeView?: boolean;\n  sourceOrder?: string[];\n  enableSourceOrder?: boolean;\n  proxyTmdb?: boolean;\n  enableLowPerformanceMode?: boolean;\n  enableNativeSubtitles?: boolean;\n}\n\nexport interface SettingsResponse {\n  applicationTheme?: string | null;\n  applicationLanguage?: string | null;\n  defaultSubtitleLanguage?: string | null;\n  proxyUrls?: string[] | null;\n  febboxKey?: string | null;\n  realDebridKey?: string | null;\n  enableThumbnails?: boolean;\n  enableAutoplay?: boolean;\n  enableSkipCredits?: boolean;\n  enableDiscover?: boolean;\n  enableFeatured?: boolean;\n  enableDetailsModal?: boolean;\n  enableImageLogos?: boolean;\n  enableCarouselView?: boolean;\n  sourceOrder?: string[];\n  enableSourceOrder?: boolean;\n  proxyTmdb?: boolean;\n  enableLowPerformanceMode?: boolean;\n  enableNativeSubtitles?: boolean;\n}\n\nexport function updateSettings(\n  url: string,\n  account: AccountWithToken,\n  settings: SettingsInput,\n) {\n  return ofetch<SettingsResponse>(`/users/${account.userId}/settings`, {\n    method: \"PUT\",\n    body: settings,\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n\nexport function getSettings(url: string, account: AccountWithToken) {\n  return ofetch<SettingsResponse>(`/users/${account.userId}/settings`, {\n    method: \"GET\",\n    baseURL: url,\n    headers: getAuthHeaders(account.token),\n  });\n}\n","import { ofetch } from \"ofetch\";\n\nimport { SessionResponse, getAuthHeaders } from \"@/backend/accounts/auth\";\nimport { AccountWithToken } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nexport interface UserResponse {\n  id: string;\n  namespace: string;\n  name: string;\n  roles: string[];\n  createdAt: string;\n  profile: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport interface UserEdit {\n  profile?: {\n    colorA: string;\n    colorB: string;\n    icon: string;\n  };\n}\n\nexport interface BookmarkResponse {\n  tmdbId: string;\n  meta: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: \"show\" | \"movie\";\n  };\n  updatedAt: string;\n}\n\nexport interface ProgressResponse {\n  tmdbId: string;\n  season: {\n    id?: string;\n    number?: number;\n  };\n  episode: {\n    id?: string;\n    number?: number;\n  };\n  meta: {\n    title: string;\n    year: number;\n    poster?: string;\n    type: \"show\" | \"movie\";\n  };\n  duration: string;\n  watched: string;\n  updatedAt: string;\n}\n\nexport function bookmarkResponsesToEntries(responses: BookmarkResponse[]) {\n  const entries = responses.map((bookmark) => {\n    const item: BookmarkMediaItem = {\n      ...bookmark.meta,\n      updatedAt: new Date(bookmark.updatedAt).getTime(),\n    };\n    return [bookmark.tmdbId, item] as const;\n  });\n\n  return Object.fromEntries(entries);\n}\n\nexport function progressResponsesToEntries(responses: ProgressResponse[]) {\n  const items: Record<string, ProgressMediaItem> = {};\n\n  responses.forEach((v) => {\n    if (!items[v.tmdbId]) {\n      items[v.tmdbId] = {\n        title: v.meta.title,\n        poster: v.meta.poster,\n        type: v.meta.type,\n        updatedAt: new Date(v.updatedAt).getTime(),\n        episodes: {},\n        seasons: {},\n        year: v.meta.year,\n      };\n    }\n\n    const item = items[v.tmdbId];\n\n    // Since each watched episode is a single array entry but with the same tmdbId, the root item updatedAt will only have the first episode's timestamp (which is not the newest).\n    // Here, we are setting it explicitly so the updatedAt always has the highest updatedAt from the episodes.\n    if (new Date(v.updatedAt).getTime() > item.updatedAt) {\n      item.updatedAt = new Date(v.updatedAt).getTime();\n    }\n\n    if (item.type === \"movie\") {\n      item.progress = {\n        duration: Number(v.duration),\n        watched: Number(v.watched),\n      };\n    }\n\n    if (item.type === \"show\" && v.season.id && v.episode.id) {\n      item.seasons[v.season.id] = {\n        id: v.season.id,\n        number: v.season.number ?? 0,\n        title: \"\",\n      };\n      item.episodes[v.episode.id] = {\n        id: v.episode.id,\n        number: v.episode.number ?? 0,\n        title: \"\",\n        progress: {\n          duration: Number(v.duration),\n          watched: Number(v.watched),\n        },\n        seasonId: v.season.id,\n        updatedAt: new Date(v.updatedAt).getTime(),\n      };\n    }\n  });\n\n  return items;\n}\n\nexport async function getUser(\n  url: string,\n  token: string,\n): Promise<{ user: UserResponse; session: SessionResponse }> {\n  return ofetch<{ user: UserResponse; session: SessionResponse }>(\n    \"/users/@me\",\n    {\n      headers: getAuthHeaders(token),\n      baseURL: url,\n    },\n  );\n}\n\nexport async function editUser(\n  url: string,\n  account: AccountWithToken,\n  object: UserEdit,\n): Promise<{ user: UserResponse; session: SessionResponse }> {\n  return ofetch<{ user: UserResponse; session: SessionResponse }>(\n    `/users/${account.userId}`,\n    {\n      method: \"PATCH\",\n      headers: getAuthHeaders(account.token),\n      body: object,\n      baseURL: url,\n    },\n  );\n}\n\nexport async function deleteUser(\n  url: string,\n  account: AccountWithToken,\n): Promise<UserResponse> {\n  return ofetch<UserResponse>(`/users/${account.userId}`, {\n    method: \"DELETE\",\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function getBookmarks(url: string, account: AccountWithToken) {\n  return ofetch<BookmarkResponse[]>(`/users/${account.userId}/bookmarks`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n\nexport async function getProgress(url: string, account: AccountWithToken) {\n  return ofetch<ProgressResponse[]>(`/users/${account.userId}/progress`, {\n    headers: getAuthHeaders(account.token),\n    baseURL: url,\n  });\n}\n","import { useCallback } from \"react\";\n\nimport { LoginResponse, SessionResponse } from \"@/backend/accounts/auth\";\nimport { SettingsResponse } from \"@/backend/accounts/settings\";\nimport {\n  BookmarkResponse,\n  ProgressResponse,\n  UserResponse,\n  bookmarkResponsesToEntries,\n  progressResponsesToEntries,\n} from \"@/backend/accounts/user\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { useBookmarkStore } from \"@/stores/bookmarks\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport { usePreferencesStore } from \"@/stores/preferences\";\nimport { useProgressStore } from \"@/stores/progress\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\nimport { useThemeStore } from \"@/stores/theme\";\n\nexport function useAuthData() {\n  const loggedIn = !!useAuthStore((s) => s.account);\n  const setAccount = useAuthStore((s) => s.setAccount);\n  const removeAccount = useAuthStore((s) => s.removeAccount);\n  const setProxySet = useAuthStore((s) => s.setProxySet);\n  const clearBookmarks = useBookmarkStore((s) => s.clear);\n  const clearProgress = useProgressStore((s) => s.clear);\n  const setTheme = useThemeStore((s) => s.setTheme);\n  const setAppLanguage = useLanguageStore((s) => s.setLanguage);\n  const importSubtitleLanguage = useSubtitleStore(\n    (s) => s.importSubtitleLanguage,\n  );\n  const setFebboxKey = usePreferencesStore((s) => s.setFebboxKey);\n\n  const replaceBookmarks = useBookmarkStore((s) => s.replaceBookmarks);\n  const replaceItems = useProgressStore((s) => s.replaceItems);\n\n  const setEnableThumbnails = usePreferencesStore((s) => s.setEnableThumbnails);\n  const setEnableAutoplay = usePreferencesStore((s) => s.setEnableAutoplay);\n  const setEnableSkipCredits = usePreferencesStore(\n    (s) => s.setEnableSkipCredits,\n  );\n  const setEnableDiscover = usePreferencesStore((s) => s.setEnableDiscover);\n  const setEnableFeatured = usePreferencesStore((s) => s.setEnableFeatured);\n  const setEnableDetailsModal = usePreferencesStore(\n    (s) => s.setEnableDetailsModal,\n  );\n  const setEnableImageLogos = usePreferencesStore((s) => s.setEnableImageLogos);\n  const setEnableCarouselView = usePreferencesStore(\n    (s) => s.setEnableCarouselView,\n  );\n  const setSourceOrder = usePreferencesStore((s) => s.setSourceOrder);\n  const setEnableSourceOrder = usePreferencesStore(\n    (s) => s.setEnableSourceOrder,\n  );\n  const setProxyTmdb = usePreferencesStore((s) => s.setProxyTmdb);\n\n  const setEnableLowPerformanceMode = usePreferencesStore(\n    (s) => s.setEnableLowPerformanceMode,\n  );\n  const setEnableNativeSubtitles = usePreferencesStore(\n    (s) => s.setEnableNativeSubtitles,\n  );\n\n  const login = useCallback(\n    async (\n      loginResponse: LoginResponse,\n      user: UserResponse,\n      session: SessionResponse,\n      seed: string,\n    ) => {\n      const account = {\n        token: loginResponse.token,\n        userId: user.id,\n        sessionId: loginResponse.session.id,\n        deviceName: session.device,\n        profile: user.profile,\n        seed,\n      };\n      setAccount(account);\n      return account;\n    },\n    [setAccount],\n  );\n\n  const logout = useCallback(async () => {\n    removeAccount();\n    clearBookmarks();\n    clearProgress();\n    setFebboxKey(null);\n  }, [removeAccount, clearBookmarks, clearProgress, setFebboxKey]);\n\n  const syncData = useCallback(\n    async (\n      _user: UserResponse,\n      _session: SessionResponse,\n      progress: ProgressResponse[],\n      bookmarks: BookmarkResponse[],\n      settings: SettingsResponse,\n    ) => {\n      replaceBookmarks(bookmarkResponsesToEntries(bookmarks));\n      replaceItems(progressResponsesToEntries(progress));\n\n      if (settings.applicationLanguage) {\n        setAppLanguage(settings.applicationLanguage);\n      }\n\n      if (settings.defaultSubtitleLanguage) {\n        importSubtitleLanguage(settings.defaultSubtitleLanguage);\n      }\n\n      if (settings.applicationTheme) {\n        setTheme(settings.applicationTheme);\n      }\n\n      if (settings.proxyUrls) {\n        setProxySet(settings.proxyUrls);\n      }\n\n      if (settings.enableThumbnails !== undefined) {\n        setEnableThumbnails(settings.enableThumbnails);\n      }\n\n      if (settings.enableAutoplay !== undefined) {\n        setEnableAutoplay(settings.enableAutoplay);\n      }\n\n      if (settings.enableSkipCredits !== undefined) {\n        setEnableSkipCredits(settings.enableSkipCredits);\n      }\n\n      if (settings.enableDiscover !== undefined) {\n        setEnableDiscover(settings.enableDiscover);\n      }\n\n      if (settings.enableFeatured !== undefined) {\n        setEnableFeatured(settings.enableFeatured);\n      }\n\n      if (settings.enableDetailsModal !== undefined) {\n        setEnableDetailsModal(settings.enableDetailsModal);\n      }\n\n      if (settings.enableImageLogos !== undefined) {\n        setEnableImageLogos(settings.enableImageLogos);\n      }\n\n      if (settings.enableCarouselView !== undefined) {\n        setEnableCarouselView(settings.enableCarouselView);\n      }\n\n      if (settings.sourceOrder !== undefined) {\n        setSourceOrder(settings.sourceOrder);\n      }\n\n      if (settings.enableSourceOrder !== undefined) {\n        setEnableSourceOrder(settings.enableSourceOrder);\n      }\n\n      if (settings.proxyTmdb !== undefined) {\n        setProxyTmdb(settings.proxyTmdb);\n      }\n\n      if (settings.febboxKey !== undefined) {\n        setFebboxKey(settings.febboxKey);\n      }\n\n      if (settings.enableLowPerformanceMode !== undefined) {\n        setEnableLowPerformanceMode(settings.enableLowPerformanceMode);\n      }\n\n      if (settings.enableNativeSubtitles !== undefined) {\n        setEnableNativeSubtitles(settings.enableNativeSubtitles);\n      }\n    },\n    [\n      replaceBookmarks,\n      replaceItems,\n      setAppLanguage,\n      importSubtitleLanguage,\n      setTheme,\n      setProxySet,\n      setEnableThumbnails,\n      setEnableAutoplay,\n      setEnableSkipCredits,\n      setEnableDiscover,\n      setEnableFeatured,\n      setEnableDetailsModal,\n      setEnableImageLogos,\n      setEnableCarouselView,\n      setSourceOrder,\n      setEnableSourceOrder,\n      setProxyTmdb,\n      setFebboxKey,\n      setEnableLowPerformanceMode,\n      setEnableNativeSubtitles,\n    ],\n  );\n\n  return {\n    loggedIn,\n    login,\n    logout,\n    syncData,\n  };\n}\n","import { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nexport function useBackendUrl(): string | null {\n  const backendUrl = useAuthStore((s) => s.backendUrl);\n  return backendUrl ?? conf().BACKEND_URL;\n}\n","import { useCallback } from \"react\";\n\nimport { SessionResponse } from \"@/backend/accounts/auth\";\nimport { bookmarkMediaToInput } from \"@/backend/accounts/bookmarks\";\nimport {\n  bytesToBase64,\n  bytesToBase64Url,\n  encryptData,\n  keysFromMnemonic,\n  signChallenge,\n} from \"@/backend/accounts/crypto\";\nimport { importBookmarks, importProgress } from \"@/backend/accounts/import\";\nimport { getLoginChallengeToken, loginAccount } from \"@/backend/accounts/login\";\nimport { progressMediaItemToInputs } from \"@/backend/accounts/progress\";\nimport {\n  getRegisterChallengeToken,\n  registerAccount,\n} from \"@/backend/accounts/register\";\nimport { removeSession } from \"@/backend/accounts/sessions\";\nimport { getSettings } from \"@/backend/accounts/settings\";\nimport {\n  UserResponse,\n  getBookmarks,\n  getProgress,\n  getUser,\n} from \"@/backend/accounts/user\";\nimport { useAuthData } from \"@/hooks/auth/useAuthData\";\nimport { useBackendUrl } from \"@/hooks/auth/useBackendUrl\";\nimport { AccountWithToken, useAuthStore } from \"@/stores/auth\";\nimport { BookmarkMediaItem } from \"@/stores/bookmarks\";\nimport { ProgressMediaItem } from \"@/stores/progress\";\n\nexport interface RegistrationData {\n  recaptchaToken?: string;\n  mnemonic: string;\n  userData: {\n    device: string;\n    profile: {\n      colorA: string;\n      colorB: string;\n      icon: string;\n    };\n  };\n}\n\nexport interface LoginData {\n  mnemonic: string;\n  userData: {\n    device: string;\n  };\n}\n\nexport function useAuth() {\n  const currentAccount = useAuthStore((s) => s.account);\n  const profile = useAuthStore((s) => s.account?.profile);\n  const loggedIn = !!useAuthStore((s) => s.account);\n  const backendUrl = useBackendUrl();\n  const {\n    logout: userDataLogout,\n    login: userDataLogin,\n    syncData,\n  } = useAuthData();\n\n  const login = useCallback(\n    async (loginData: LoginData) => {\n      if (!backendUrl) return;\n      const keys = await keysFromMnemonic(loginData.mnemonic);\n      const publicKeyBase64Url = bytesToBase64Url(keys.publicKey);\n      const { challenge } = await getLoginChallengeToken(\n        backendUrl,\n        publicKeyBase64Url,\n      );\n      const signature = await signChallenge(keys, challenge);\n      const loginResult = await loginAccount(backendUrl, {\n        challenge: {\n          code: challenge,\n          signature,\n        },\n        publicKey: publicKeyBase64Url,\n        device: await encryptData(loginData.userData.device, keys.seed),\n      });\n\n      const user = await getUser(backendUrl, loginResult.token);\n      const seedBase64 = bytesToBase64(keys.seed);\n      return userDataLogin(loginResult, user.user, user.session, seedBase64);\n    },\n    [userDataLogin, backendUrl],\n  );\n\n  const logout = useCallback(async () => {\n    if (!currentAccount || !backendUrl) return;\n    try {\n      await removeSession(\n        backendUrl,\n        currentAccount.token,\n        currentAccount.sessionId,\n      );\n    } catch {\n      // we dont care about failing to delete session\n    }\n    await userDataLogout();\n  }, [userDataLogout, backendUrl, currentAccount]);\n\n  const register = useCallback(\n    async (registerData: RegistrationData) => {\n      if (!backendUrl) return;\n      const { challenge } = await getRegisterChallengeToken(\n        backendUrl,\n        registerData.recaptchaToken,\n      );\n      const keys = await keysFromMnemonic(registerData.mnemonic);\n      const signature = await signChallenge(keys, challenge);\n      const registerResult = await registerAccount(backendUrl, {\n        challenge: {\n          code: challenge,\n          signature,\n        },\n        publicKey: bytesToBase64Url(keys.publicKey),\n        device: await encryptData(registerData.userData.device, keys.seed),\n        profile: registerData.userData.profile,\n      });\n\n      return userDataLogin(\n        registerResult,\n        registerResult.user,\n        registerResult.session,\n        bytesToBase64(keys.seed),\n      );\n    },\n    [backendUrl, userDataLogin],\n  );\n\n  const importData = useCallback(\n    async (\n      account: AccountWithToken,\n      progressItems: Record<string, ProgressMediaItem>,\n      bookmarks: Record<string, BookmarkMediaItem>,\n    ) => {\n      if (!backendUrl) return;\n      if (\n        Object.keys(progressItems).length === 0 &&\n        Object.keys(bookmarks).length === 0\n      ) {\n        return;\n      }\n\n      const progressInputs = Object.entries(progressItems).flatMap(\n        ([tmdbId, item]) => progressMediaItemToInputs(tmdbId, item),\n      );\n\n      const bookmarkInputs = Object.entries(bookmarks).map(([tmdbId, item]) =>\n        bookmarkMediaToInput(tmdbId, item),\n      );\n\n      await Promise.all([\n        importProgress(backendUrl, account, progressInputs),\n        importBookmarks(backendUrl, account, bookmarkInputs),\n      ]);\n    },\n    [backendUrl],\n  );\n\n  const restore = useCallback(\n    async (account: AccountWithToken) => {\n      if (!backendUrl) return;\n      let user: { user: UserResponse; session: SessionResponse };\n      try {\n        user = await getUser(backendUrl, account.token);\n      } catch (err) {\n        const anyError: any = err;\n        if (\n          anyError?.response?.status === 401 ||\n          anyError?.response?.status === 403 ||\n          anyError?.response?.status === 400\n        ) {\n          await logout();\n          return;\n        }\n        console.error(err);\n        throw err;\n      }\n\n      const [bookmarks, progress, settings] = await Promise.all([\n        getBookmarks(backendUrl, account),\n        getProgress(backendUrl, account),\n        getSettings(backendUrl, account),\n      ]);\n\n      syncData(user.user, user.session, progress, bookmarks, settings);\n    },\n    [backendUrl, syncData, logout],\n  );\n\n  return {\n    loggedIn,\n    profile,\n    login,\n    logout,\n    register,\n    restore,\n    importData,\n  };\n}\n","import { useRef } from \"react\";\nimport { useAsync, useInterval } from \"react-use\";\n\nimport { useAuth } from \"@/hooks/auth/useAuth\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nconst AUTH_CHECK_INTERVAL = 12 * 60 * 60 * 1000;\n\nexport function useAuthRestore() {\n  const { account } = useAuthStore();\n  const { restore } = useAuth();\n  const hasRestored = useRef(false);\n\n  useInterval(() => {\n    if (account) restore(account);\n  }, AUTH_CHECK_INTERVAL);\n\n  const result = useAsync(async () => {\n    if (hasRestored.current || !account) return;\n    await restore(account).finally(() => {\n      hasRestored.current = true;\n    });\n  }, []); // no deps because we don't want to it ever rerun after the first time\n\n  return result;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nexport function useQueryParams() {\n  const loc = useLocation();\n\n  const queryParams = useMemo(() => {\n    const obj: Record<string, string> = Object.fromEntries(\n      new URLSearchParams(loc.search).entries(),\n    );\n\n    return obj;\n  }, [loc.search]);\n\n  return queryParams;\n}\n\nexport function useQueryParam(\n  param: string,\n): [string | null, (a: string | null) => void] {\n  const params = useQueryParams();\n  const location = useLocation();\n  const navigate = useNavigate();\n  const currentValue = params[param] ?? null;\n\n  const set = useCallback(\n    (value: string | null) => {\n      const parsed = new URLSearchParams(location.search);\n      if (value) parsed.set(param, value);\n      else parsed.delete(param);\n      navigate({\n        search: parsed.toString(),\n      });\n    },\n    [param, location.search, navigate],\n  );\n\n  return [currentValue, set];\n}\n","import { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\nexport interface OverlayTransition {\n  from: string;\n  to: string;\n}\n\nexport interface OverlayRoute {\n  id: string;\n  height: number;\n  width: number;\n}\n\nexport interface ActiveAnchorPoint {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\ninterface OverlayStore {\n  transition: null | OverlayTransition;\n  routes: Record<string, OverlayRoute>;\n  anchorPoint: ActiveAnchorPoint | null;\n  setTransition(newTrans: OverlayTransition | null): void;\n  registerRoute(route: OverlayRoute): void;\n  setAnchorPoint(point: ActiveAnchorPoint | null): void;\n}\n\nexport const useOverlayStore = create(\n  immer<OverlayStore>((set) => ({\n    transition: null,\n    routes: {},\n    anchorPoint: null,\n    setTransition(newTrans) {\n      set((s) => {\n        s.transition = newTrans;\n      });\n    },\n    registerRoute(route) {\n      set((s) => {\n        s.routes[route.id] = route;\n      });\n    },\n    setAnchorPoint(point) {\n      set((s) => {\n        s.anchorPoint = point;\n      });\n    },\n  })),\n);\n","import { useCallback, useEffect, useMemo } from \"react\";\n\nimport { useQueryParam } from \"@/hooks/useQueryParams\";\nimport { useOverlayStore } from \"@/stores/overlay/store\";\n\nfunction splitPath(path: string, prefix?: string): string[] {\n  const parts = [prefix ?? \"\", ...path.split(\"/\")];\n  return parts.filter((v) => v.length > 0);\n}\n\nfunction joinPath(path: string[]): string {\n  return `/${path.join(\"/\")}`;\n}\n\nexport function useRouterAnchorUpdate(id: string) {\n  const [route] = useQueryParam(\"r\");\n  const setAnchorPoint = useOverlayStore((s) => s.setAnchorPoint);\n  const routerActive = useMemo(\n    () => !!route && route.startsWith(`/${id}`),\n    [route, id],\n  );\n\n  const update = useCallback(() => {\n    if (!routerActive) return;\n    const anchor = document.getElementById(`__overlayRouter::${id}`);\n    if (anchor) {\n      const rect = anchor.getBoundingClientRect();\n      setAnchorPoint({\n        h: rect.height,\n        w: rect.width,\n        x: rect.x,\n        y: rect.y,\n      });\n    }\n  }, [routerActive, setAnchorPoint, id]);\n\n  useEffect(() => {\n    update();\n  }, [routerActive, update]);\n\n  useEffect(() => {\n    function resizeEvent() {\n      update();\n    }\n    window.addEventListener(\"resize\", resizeEvent);\n    return () => {\n      window.removeEventListener(\"resize\", resizeEvent);\n    };\n  }, [update]);\n}\n\nexport function useInternalOverlayRouter(id: string) {\n  const [route, setRoute] = useQueryParam(\"r\");\n  const transition = useOverlayStore((s) => s.transition);\n  const setTransition = useOverlayStore((s) => s.setTransition);\n  const routerActive = !!route && route.startsWith(`/${id}`);\n\n  function makePath(path: string) {\n    return joinPath(splitPath(path, id));\n  }\n\n  function navigate(path: string) {\n    const oldRoute = route;\n    const newRoute = joinPath(splitPath(path, id));\n    setTransition({\n      from: oldRoute ?? \"/\",\n      to: newRoute,\n    });\n    setRoute(newRoute);\n  }\n\n  function showBackwardsTransition(path: string) {\n    if (!transition) return \"none\";\n    const current = joinPath(splitPath(path, id));\n\n    if (current === transition.to && transition.from.startsWith(transition.to))\n      return \"yes\";\n    if (\n      current === transition.from &&\n      transition.to.startsWith(transition.from)\n    )\n      return \"yes\";\n    return \"no\";\n  }\n\n  function isCurrentPage(path: string) {\n    return routerActive && route === joinPath(splitPath(path, id));\n  }\n\n  function isOverlayActive() {\n    return routerActive;\n  }\n\n  const close = useCallback(\n    (preventRouteClear?: boolean) => {\n      if (route && !preventRouteClear) setRoute(null);\n      setTransition(null);\n    },\n    [setRoute, route, setTransition],\n  );\n\n  const open = useCallback(\n    (defaultRoute = \"/\") => {\n      setTransition(null);\n      setRoute(joinPath(splitPath(defaultRoute, id)));\n    },\n    [id, setRoute, setTransition],\n  );\n\n  const activeRoute = routerActive\n    ? joinPath(splitPath(route.slice(`/${id}`.length)))\n    : \"/\";\n\n  return {\n    activeRoute,\n    showBackwardsTransition,\n    isCurrentPage,\n    isOverlayActive,\n    navigate,\n    close,\n    open,\n    makePath,\n    currentRoute: route,\n  };\n}\n\nexport function useOverlayRouter(id: string) {\n  const router = useInternalOverlayRouter(id);\n  return {\n    id,\n    route: router.activeRoute,\n    isRouterActive: router.isOverlayActive(),\n    open: router.open,\n    close: router.close,\n    navigate: router.navigate,\n  };\n}\n","import { useEffect, useRef, useState } from \"react\";\n\nexport function useIsMobile(horizontal?: boolean) {\n  const [isMobile, setIsMobile] = useState(false);\n  const isMobileCurrent = useRef<boolean | null>(false);\n\n  useEffect(() => {\n    function onResize() {\n      const value = horizontal\n        ? window.innerHeight < 600\n        : window.innerWidth < 1024;\n      const isChanged = isMobileCurrent.current !== value;\n      if (!isChanged) return;\n\n      isMobileCurrent.current = value;\n      setIsMobile(value);\n    }\n\n    onResize();\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [horizontal]);\n\n  return {\n    isMobile,\n  };\n}\n","import { AccountWithToken } from \"@/stores/auth\";\n\ninterface PlayerState {\n  isPlaying: boolean;\n  isPaused: boolean;\n  isLoading: boolean;\n  hasPlayedOnce: boolean;\n  time: number;\n  duration: number;\n  volume?: number;\n  playbackRate: number;\n  buffered: number;\n}\n\ninterface ContentInfo {\n  title: string;\n  type: string;\n  tmdbId?: number;\n  seasonNumber?: number;\n  episodeNumber?: number;\n  seasonId?: number;\n  episodeId?: number;\n}\n\ninterface PlayerStatusRequest {\n  userId: string;\n  roomCode: string;\n  isHost: boolean;\n  content: ContentInfo;\n  player: PlayerState;\n}\n\ninterface PlayerStatusResponse {\n  success: boolean;\n  timestamp: number;\n}\n\ninterface UserStatusResponse {\n  userId: string;\n  roomCode: string;\n  statuses: Array<{\n    userId: string;\n    roomCode: string;\n    isHost: boolean;\n    content: ContentInfo;\n    player: PlayerState;\n    timestamp: number;\n  }>;\n}\n\ninterface RoomStatusesResponse {\n  roomCode: string;\n  users: Record<\n    string,\n    Array<{\n      userId: string;\n      roomCode: string;\n      isHost: boolean;\n      content: ContentInfo;\n      player: PlayerState;\n      timestamp: number;\n    }>\n  >;\n}\n\n/**\n * Send player status update to the backend\n */\nexport async function sendPlayerStatus(\n  backendUrl: string | null,\n  account: AccountWithToken | null,\n  data: PlayerStatusRequest,\n): Promise<PlayerStatusResponse> {\n  if (!backendUrl) {\n    throw new Error(\"Backend URL not set\");\n  }\n\n  const response = await fetch(`${backendUrl}/api/player/status`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...(account ? { Authorization: `Bearer ${account.token}` } : {}),\n    },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send player status: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Get player status for a specific user in a room\n */\nexport async function getUserPlayerStatus(\n  backendUrl: string | null,\n  account: AccountWithToken | null,\n  userId: string,\n  roomCode: string,\n): Promise<UserStatusResponse> {\n  if (!backendUrl) {\n    throw new Error(\"Backend URL not set\");\n  }\n\n  const response = await fetch(\n    `${backendUrl}/api/player/status?userId=${encodeURIComponent(\n      userId,\n    )}&roomCode=${encodeURIComponent(roomCode)}`,\n    {\n      headers: account ? { Authorization: `Bearer ${account.token}` } : {},\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(`Failed to get user player status: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Get status for all users in a room\n */\nexport async function getRoomStatuses(\n  backendUrl: string | null,\n  account: AccountWithToken | null,\n  roomCode: string,\n): Promise<RoomStatusesResponse> {\n  if (!backendUrl) {\n    throw new Error(\"Backend URL not set\");\n  }\n\n  const response = await fetch(\n    `${backendUrl}/api/player/status?roomCode=${encodeURIComponent(roomCode)}`,\n    {\n      headers: account ? { Authorization: `Bearer ${account.token}` } : {},\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(`Failed to get room statuses: ${response.statusText}`);\n  }\n\n  return response.json();\n}\n","import { useEffect } from \"react\";\nimport { useMeasure } from \"react-use\";\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\ninterface BannerInstance {\n  id: string;\n  height: number;\n}\n\ninterface BannerStore {\n  banners: BannerInstance[];\n  isOnline: boolean;\n  isTurnstile: boolean;\n  location: string | null;\n  ignoredBannerIds: string[];\n  updateHeight(id: string, height: number): void;\n  showBanner(id: string): void;\n  hideBanner(id: string, force?: boolean): void;\n  setLocation(loc: string | null): void;\n  updateOnline(isOnline: boolean): void;\n  updateTurnstile(isTurnstile: boolean): void;\n}\n\nexport const useBannerStore = create(\n  immer<BannerStore>((set) => ({\n    banners: [],\n    isOnline: true,\n    isTurnstile: false,\n    location: null,\n    ignoredBannerIds: [],\n    updateOnline(isOnline) {\n      set((s) => {\n        s.isOnline = isOnline;\n      });\n    },\n    updateTurnstile(isTurnstile) {\n      set((s) => {\n        s.isTurnstile = isTurnstile;\n      });\n    },\n    setLocation(loc) {\n      set((s) => {\n        s.location = loc;\n      });\n    },\n    showBanner(id) {\n      set((s) => {\n        if (s.banners.find((v) => v.id === id)) return;\n        if (s.ignoredBannerIds.includes(id)) return;\n        s.banners.push({\n          id,\n          height: 0,\n        });\n      });\n    },\n    hideBanner(id, force = false) {\n      set((s) => {\n        if (force) s.ignoredBannerIds.push(id);\n        s.banners = s.banners.filter((v) => v.id !== id);\n      });\n    },\n    updateHeight(id, height) {\n      set((s) => {\n        const found = s.banners.find((v) => v.id === id);\n        if (found) found.height = height;\n      });\n    },\n  })),\n);\n\nexport function useBannerSize(location?: string) {\n  const loc = location ?? null;\n  const banners = useBannerStore((s) => s.banners);\n  const currentLocation = useBannerStore((s) => s.location);\n\n  const size = banners.reduce((a, v) => a + v.height, 0);\n  if (loc !== currentLocation) return 0;\n  return size;\n}\n\nexport function useRegisterBanner<T extends Element>(id: string) {\n  const [ref, { height }] = useMeasure<T>();\n  const updateHeight = useBannerStore((s) => s.updateHeight);\n  const showBanner = useBannerStore((s) => s.showBanner);\n  const hideBanner = useBannerStore((s) => s.hideBanner);\n\n  useEffect(() => {\n    showBanner(id);\n    return () => {\n      hideBanner(id);\n    };\n  }, [showBanner, hideBanner, id]);\n\n  useEffect(() => {\n    updateHeight(id, height);\n  }, [height, id, updateHeight]);\n\n  return [ref];\n}\n","import { useEffect, useRef } from \"react\";\n\nimport { useBannerStore } from \"@/stores/banner\";\n\nexport function useOnlineListener() {\n  const updateOnline = useBannerStore((s) => s.updateOnline);\n  const ref = useRef<boolean>(true);\n\n  useEffect(() => {\n    let counter = 0;\n\n    let abort: null | AbortController = null;\n    const interval = setInterval(() => {\n      // if online try once every 10 iterations intead of every iteration\n      counter += 1;\n      if (ref.current) {\n        if (counter < 10) return;\n      }\n      counter = 0;\n\n      if (abort) abort.abort();\n      abort = new AbortController();\n      const signal = abort.signal;\n      fetch(\"/ping.txt\", { signal })\n        .then(() => {\n          updateOnline(true);\n          ref.current = true;\n        })\n        .catch((err) => {\n          if (err.name === \"AbortError\") return;\n          updateOnline(false);\n          ref.current = false;\n        });\n    }, 5000);\n\n    return () => {\n      clearInterval(interval);\n      if (abort) abort.abort();\n    };\n  }, [updateOnline]);\n}\n","import { ofetch } from \"ofetch\";\n\nexport interface MetaResponse {\n  version: string;\n  name: string;\n  description?: string;\n  hasCaptcha: boolean;\n  captchaClientKey?: string;\n}\n\nexport async function getBackendMeta(url: string): Promise<MetaResponse> {\n  return ofetch<MetaResponse>(\"/meta\", {\n    baseURL: url,\n  });\n}\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface CastingSlice {\n  casting: {\n    instance: cast.framework.CastContext | null;\n    player: cast.framework.RemotePlayer | null;\n    controller: cast.framework.RemotePlayerController | null;\n    setInstance(instance: cast.framework.CastContext): void;\n    setPlayer(player: cast.framework.RemotePlayer): void;\n    setController(controller: cast.framework.RemotePlayerController): void;\n    setIsCasting(isCasting: boolean): void;\n    clear(): void;\n  };\n}\n\nexport const createCastingSlice: MakeSlice<CastingSlice> = (set) => ({\n  casting: {\n    instance: null,\n    player: null,\n    controller: null,\n    setInstance(instance) {\n      set((s) => {\n        s.casting.instance = instance;\n      });\n    },\n    setPlayer(player) {\n      set((s) => {\n        s.casting.player = player;\n      });\n    },\n    setController(controller) {\n      set((s) => {\n        s.casting.controller = controller;\n      });\n    },\n    setIsCasting(isCasting) {\n      set((s) => {\n        s.interface.isCasting = isCasting;\n      });\n    },\n    clear() {\n      set((s) => {\n        s.casting.instance = null;\n      });\n    },\n  },\n});\n","import { Qualities, Stream } from \"@movie-web/providers\";\n\nimport { QualityStore } from \"@/stores/quality\";\n\nexport type SourceQuality = Qualities;\n\nexport type StreamType = \"hls\" | \"mp4\";\n\nexport type SourceFileStream = {\n  type: \"mp4\";\n  url: string;\n};\n\nexport type LoadableSource = {\n  type: StreamType;\n  url: string;\n  headers?: Stream[\"headers\"];\n  preferredHeaders?: Stream[\"preferredHeaders\"];\n};\n\nexport type SourceSliceSource =\n  | {\n      type: \"file\";\n      qualities: Partial<Record<SourceQuality, SourceFileStream>>;\n      headers?: Stream[\"headers\"];\n      preferredHeaders?: Stream[\"preferredHeaders\"];\n    }\n  | {\n      type: \"hls\";\n      url: string;\n      headers?: Stream[\"headers\"];\n      preferredHeaders?: Stream[\"preferredHeaders\"];\n    };\n\nconst qualitySorting: Record<SourceQuality, number> = {\n  unknown: 0,\n  \"360\": 10,\n  \"480\": 20,\n  \"720\": 30,\n  \"1080\": 40,\n  \"4k\": 35, // 4k has lower priority, you need faster internet for it\n};\nconst sortedQualities: SourceQuality[] = Object.entries(qualitySorting)\n  .sort((a, b) => b[1] - a[1])\n  .map<SourceQuality>((v) => v[0] as SourceQuality);\n\nexport function getPreferredQuality(\n  availableQualites: SourceQuality[],\n  qualityPreferences: QualityStore[\"quality\"],\n) {\n  if (\n    qualityPreferences.automaticQuality ||\n    qualityPreferences.lastChosenQuality === null ||\n    qualityPreferences.lastChosenQuality === \"unknown\"\n  ) {\n    // For automatic quality, select the best available quality\n    // Sort by our quality preference order and pick the first (best) available\n    return sortedQualities.find((v) => availableQualites.includes(v));\n  }\n\n  // get preferred quality - not automatic or unknown\n  const chosenQualityIndex = sortedQualities.indexOf(\n    qualityPreferences.lastChosenQuality,\n  );\n  let nearestChoseQuality: undefined | SourceQuality;\n\n  // check chosen quality or lower\n  for (let i = chosenQualityIndex; i < sortedQualities.length; i += 1) {\n    if (availableQualites.includes(sortedQualities[i])) {\n      nearestChoseQuality = sortedQualities[i];\n      break;\n    }\n  }\n  if (nearestChoseQuality) return nearestChoseQuality;\n\n  // chosen quality or lower doesn't exist, try higher\n  for (let i = chosenQualityIndex; i >= 0; i -= 1) {\n    if (availableQualites.includes(sortedQualities[i])) {\n      nearestChoseQuality = sortedQualities[i];\n      break;\n    }\n  }\n  return nearestChoseQuality;\n}\n\nexport function selectQuality(\n  source: SourceSliceSource,\n  qualityPreferences: QualityStore[\"quality\"],\n): {\n  stream: LoadableSource;\n  quality: null | SourceQuality;\n} {\n  if (source.type === \"hls\")\n    return {\n      stream: source,\n      quality: null,\n    };\n  if (source.type === \"file\") {\n    const availableQualities = Object.entries(source.qualities)\n      .filter((entry) => (entry[1].url.length ?? 0) > 0)\n      .map((entry) => entry[0]) as SourceQuality[];\n    const quality = getPreferredQuality(availableQualities, qualityPreferences);\n    if (quality) {\n      const stream = source.qualities[quality];\n      if (stream) {\n        return { stream, quality };\n      }\n    }\n  }\n  throw new Error(\"couldn't select quality\");\n}\n\nconst qualityNameMap: Record<SourceQuality, string> = {\n  \"4k\": \"4K\",\n  \"1080\": \"1080p\",\n  \"360\": \"360p\",\n  \"480\": \"480p\",\n  \"720\": \"720p\",\n  unknown: \"unknown\",\n};\n\nexport const allQualities = Object.keys(qualityNameMap) as SourceQuality[];\n\nexport function qualityToString(quality: SourceQuality): string {\n  return qualityNameMap[quality];\n}\n","import merge from \"lodash.merge\";\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { SourceQuality } from \"@/stores/player/utils/qualities\";\n\nexport interface QualityStore {\n  quality: {\n    lastChosenQuality: SourceQuality | null;\n    automaticQuality: boolean;\n  };\n  setLastChosenQuality(v: SourceQuality | null): void;\n  setAutomaticQuality(v: boolean): void;\n}\n\nexport const useQualityStore = create(\n  persist(\n    immer<QualityStore>((set) => ({\n      quality: {\n        automaticQuality: true,\n        lastChosenQuality: null,\n      },\n      setLastChosenQuality(v) {\n        set((s) => {\n          s.quality.lastChosenQuality = v;\n        });\n      },\n      setAutomaticQuality(v) {\n        set((s) => {\n          s.quality.automaticQuality = v;\n        });\n      },\n    })),\n    {\n      name: \"__MW::quality\",\n      merge: (persisted, current) => merge({}, current, persisted),\n    },\n  ),\n);\n","import { ScrapeMedia } from \"@movie-web/providers\";\n\nimport { MakeSlice } from \"@/stores/player/slices/types\";\nimport {\n  SourceQuality,\n  SourceSliceSource,\n  selectQuality,\n} from \"@/stores/player/utils/qualities\";\nimport { useQualityStore } from \"@/stores/quality\";\nimport { ValuesOf } from \"@/utils/typeguard\";\n\nexport const playerStatus = {\n  IDLE: \"idle\",\n  SCRAPING: \"scraping\",\n  PLAYING: \"playing\",\n  SCRAPE_NOT_FOUND: \"scrapeNotFound\",\n  PLAYBACK_ERROR: \"playbackError\",\n} as const;\n\nexport type PlayerStatus = ValuesOf<typeof playerStatus>;\n\nexport interface PlayerMetaEpisode {\n  number: number;\n  tmdbId: string;\n  title: string;\n  air_date?: string;\n}\n\nexport interface PlayerMeta {\n  type: \"movie\" | \"show\";\n  title: string;\n  tmdbId: string;\n  imdbId?: string;\n  releaseYear: number;\n  poster?: string;\n  episodes?: PlayerMetaEpisode[];\n  episode?: PlayerMetaEpisode;\n  season?: {\n    number: number;\n    tmdbId: string;\n    title: string;\n  };\n}\n\nexport interface Caption {\n  id: string;\n  language: string;\n  url?: string;\n  srtData: string;\n}\n\nexport interface CaptionListItem {\n  id: string;\n  language: string;\n  url: string;\n  needsProxy: boolean;\n  hls?: boolean;\n  opensubtitles?: boolean;\n}\n\nexport interface AudioTrack {\n  id: string;\n  label: string;\n  language: string;\n}\n\nexport interface SourceSlice {\n  status: PlayerStatus;\n  source: SourceSliceSource | null;\n  sourceId: string | null;\n  qualities: SourceQuality[];\n  audioTracks: AudioTrack[];\n  currentQuality: SourceQuality | null;\n  currentAudioTrack: AudioTrack | null;\n  captionList: CaptionListItem[];\n  caption: {\n    selected: Caption | null;\n    asTrack: boolean;\n  };\n  meta: PlayerMeta | null;\n  setStatus(status: PlayerStatus): void;\n  setSource(\n    stream: SourceSliceSource,\n    captions: CaptionListItem[],\n    startAt: number,\n  ): void;\n  switchQuality(quality: SourceQuality): void;\n  setMeta(meta: PlayerMeta, status?: PlayerStatus): void;\n  setCaption(caption: Caption | null): void;\n  setSourceId(id: string | null): void;\n  enableAutomaticQuality(): void;\n  redisplaySource(startAt: number): void;\n  setCaptionAsTrack(asTrack: boolean): void;\n}\n\nexport function metaToScrapeMedia(meta: PlayerMeta): ScrapeMedia {\n  if (meta.type === \"show\") {\n    if (!meta.episode || !meta.season) throw new Error(\"missing show data\");\n    return {\n      title: meta.title,\n      releaseYear: meta.releaseYear,\n      tmdbId: meta.tmdbId,\n      type: \"show\",\n      imdbId: meta.imdbId,\n      episode: meta.episode,\n      season: meta.season,\n    };\n  }\n\n  return {\n    title: meta.title,\n    releaseYear: meta.releaseYear,\n    tmdbId: meta.tmdbId,\n    type: \"movie\",\n    imdbId: meta.imdbId,\n  };\n}\n\nexport const createSourceSlice: MakeSlice<SourceSlice> = (set, get) => ({\n  source: null,\n  sourceId: null,\n  qualities: [],\n  audioTracks: [],\n  captionList: [],\n  currentQuality: null,\n  currentAudioTrack: null,\n  status: playerStatus.IDLE,\n  meta: null,\n  caption: {\n    selected: null,\n    asTrack: false,\n  },\n  setSourceId(id) {\n    set((s) => {\n      s.status = playerStatus.PLAYING;\n      s.sourceId = id;\n    });\n  },\n  setStatus(status: PlayerStatus) {\n    set((s) => {\n      s.status = status;\n    });\n  },\n  setMeta(meta, newStatus) {\n    set((s) => {\n      s.meta = meta;\n      s.interface.hideNextEpisodeBtn = false;\n      if (newStatus) s.status = newStatus;\n    });\n  },\n  setCaption(caption) {\n    const store = get();\n    store.display?.setCaption(caption);\n    set((s) => {\n      s.caption.selected = caption;\n    });\n  },\n  setSource(\n    stream: SourceSliceSource,\n    captions: CaptionListItem[],\n    startAt: number,\n  ) {\n    let qualities: string[] = [];\n    if (stream.type === \"file\") qualities = Object.keys(stream.qualities);\n    const qualityPreferences = useQualityStore.getState();\n    const loadableStream = selectQuality(stream, qualityPreferences.quality);\n\n    set((s) => {\n      s.source = stream;\n      s.qualities = qualities as SourceQuality[];\n      s.currentQuality = loadableStream.quality;\n      s.captionList = captions;\n      s.interface.error = undefined;\n      s.status = playerStatus.PLAYING;\n      s.audioTracks = [];\n      s.currentAudioTrack = null;\n    });\n    const store = get();\n    store.redisplaySource(startAt);\n  },\n  redisplaySource(startAt: number) {\n    const store = get();\n    const quality = store.currentQuality;\n    if (!store.source) return;\n    const qualityPreferences = useQualityStore.getState();\n    const loadableStream = selectQuality(store.source, {\n      automaticQuality: qualityPreferences.quality.automaticQuality,\n      lastChosenQuality: quality,\n    });\n    set((s) => {\n      s.interface.error = undefined;\n      s.status = playerStatus.PLAYING;\n    });\n    store.display?.load({\n      source: loadableStream.stream,\n      startAt,\n      automaticQuality: qualityPreferences.quality.automaticQuality,\n      preferredQuality: qualityPreferences.quality.lastChosenQuality,\n    });\n  },\n  switchQuality(quality) {\n    const store = get();\n    if (!store.source) return;\n    if (store.source.type === \"file\") {\n      const selectedQuality = store.source.qualities[quality];\n      if (!selectedQuality) return;\n      set((s) => {\n        s.currentQuality = quality;\n        s.status = playerStatus.PLAYING;\n        s.interface.error = undefined;\n      });\n      store.display?.load({\n        source: selectedQuality,\n        startAt: store.progress.time,\n        automaticQuality: false,\n        preferredQuality: quality,\n      });\n    } else if (store.source.type === \"hls\") {\n      store.display?.changeQuality(false, quality);\n    }\n  },\n  enableAutomaticQuality() {\n    const store = get();\n    store.display?.changeQuality(true, null);\n  },\n  setCaptionAsTrack(asTrack: boolean) {\n    set((s) => {\n      s.caption.asTrack = asTrack;\n    });\n  },\n});\n","import { DisplayInterface } from \"@/components/player/display/displayInterface\";\nimport { playerStatus } from \"@/stores/player/slices/source\";\nimport { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface DisplaySlice {\n  display: DisplayInterface | null;\n  setDisplay(display: DisplayInterface | null): void;\n  reset(): void;\n}\n\nexport const createDisplaySlice: MakeSlice<DisplaySlice> = (set, get) => ({\n  display: null,\n  setDisplay(newDisplay: DisplayInterface | null) {\n    const display = get().display;\n    if (display) display.destroy();\n\n    if (!newDisplay) {\n      set((s) => {\n        s.display = null;\n      });\n      return;\n    }\n\n    // make display events update the state\n    newDisplay.on(\"pause\", () =>\n      set((s) => {\n        s.mediaPlaying.isPaused = true;\n        s.mediaPlaying.isPlaying = false;\n      }),\n    );\n    newDisplay.on(\"play\", () =>\n      set((s) => {\n        s.mediaPlaying.hasPlayedOnce = true;\n        s.mediaPlaying.isPaused = false;\n        s.mediaPlaying.isPlaying = true;\n      }),\n    );\n    newDisplay.on(\"fullscreen\", (isFullscreen) =>\n      set((s) => {\n        s.interface.isFullscreen = isFullscreen;\n      }),\n    );\n    newDisplay.on(\"time\", (time) =>\n      set((s) => {\n        s.progress.time = time;\n      }),\n    );\n    newDisplay.on(\"volumechange\", (vol) =>\n      set((s) => {\n        s.mediaPlaying.volume = vol;\n      }),\n    );\n    newDisplay.on(\"duration\", (duration) =>\n      set((s) => {\n        s.progress.duration = duration;\n      }),\n    );\n    newDisplay.on(\"buffered\", (buffered) =>\n      set((s) => {\n        s.progress.buffered = buffered;\n      }),\n    );\n    newDisplay.on(\"loading\", (isLoading) =>\n      set((s) => {\n        s.mediaPlaying.isLoading = isLoading;\n      }),\n    );\n    newDisplay.on(\"qualities\", (qualities) => {\n      set((s) => {\n        s.qualities = qualities;\n      });\n    });\n    newDisplay.on(\"changedquality\", (quality) => {\n      set((s) => {\n        s.currentQuality = quality;\n      });\n    });\n    newDisplay.on(\"audiotracks\", (audioTracks) => {\n      set((s) => {\n        s.audioTracks = audioTracks;\n      });\n    });\n    newDisplay.on(\"changedaudiotrack\", (audioTrack) => {\n      set((s) => {\n        s.currentAudioTrack = audioTrack;\n      });\n    });\n    newDisplay.on(\"needstrack\", (needsTrack) => {\n      set((s) => {\n        s.caption.asTrack = needsTrack;\n      });\n    });\n    newDisplay.on(\"canairplay\", (canAirplay) => {\n      set((s) => {\n        s.interface.canAirplay = canAirplay;\n      });\n    });\n    newDisplay.on(\"playbackrate\", (rate) => {\n      set((s) => {\n        s.mediaPlaying.playbackRate = rate;\n      });\n    });\n    newDisplay.on(\"error\", (err) => {\n      set((s) => {\n        s.status = playerStatus.PLAYBACK_ERROR;\n        s.interface.error = err;\n      });\n    });\n\n    set((s) => {\n      s.display = newDisplay;\n    });\n  },\n  reset() {\n    get().display?.load({\n      source: null,\n      startAt: 0,\n      automaticQuality: false,\n      preferredQuality: null,\n    });\n    set((s) => {\n      s.status = playerStatus.IDLE;\n      s.meta = null;\n      s.thumbnails.images = [];\n      s.progress.time = 0;\n      s.progress.duration = 0;\n    });\n  },\n});\n","import { DisplayError } from \"@/components/player/display/displayInterface\";\nimport { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport enum VideoPlayerTimeFormat {\n  REGULAR = 0,\n  REMAINING = 1,\n}\n\nexport enum PlayerHoverState {\n  NOT_HOVERING = \"not_hovering\",\n  MOUSE_HOVER = \"mouse_hover\",\n  MOBILE_TAPPED = \"mobile_tapped\",\n}\n\nexport interface InterfaceSlice {\n  interface: {\n    isFullscreen: boolean;\n    isSeeking: boolean;\n    lastVolume: number;\n    hasOpenOverlay: boolean;\n    hovering: PlayerHoverState;\n    lastHoveringState: PlayerHoverState;\n    canAirplay: boolean;\n    isCasting: boolean;\n    hideNextEpisodeBtn: boolean;\n    shouldStartFromBeginning: boolean;\n    error?: DisplayError;\n\n    volumeChangedWithKeybind: boolean; // has the volume recently been adjusted with the up/down arrows recently?\n    volumeChangedWithKeybindDebounce: NodeJS.Timeout | null; // debounce for the duration of the \"volume changed thingamajig\"\n\n    leftControlHovering: boolean; // is the cursor hovered over the left side of player controls\n    isHoveringControls: boolean; // is the cursor hovered over any controls?\n    timeFormat: VideoPlayerTimeFormat; // Time format of the video player\n  };\n  updateInterfaceHovering(newState: PlayerHoverState): void;\n  setSeeking(seeking: boolean): void;\n  setTimeFormat(format: VideoPlayerTimeFormat): void;\n  setHoveringLeftControls(state: boolean): void;\n  setHoveringAnyControls(state: boolean): void;\n  setHasOpenOverlay(state: boolean): void;\n  setLastVolume(state: number): void;\n  hideNextEpisodeButton(): void;\n  setShouldStartFromBeginning(val: boolean): void;\n}\n\nexport const createInterfaceSlice: MakeSlice<InterfaceSlice> = (set, get) => ({\n  interface: {\n    isCasting: false,\n    hasOpenOverlay: false,\n    isFullscreen: false,\n    isSeeking: false,\n    lastVolume: 0,\n    leftControlHovering: false,\n    isHoveringControls: false,\n    hovering: PlayerHoverState.NOT_HOVERING,\n    lastHoveringState: PlayerHoverState.NOT_HOVERING,\n    volumeChangedWithKeybind: false,\n    volumeChangedWithKeybindDebounce: null,\n    timeFormat: VideoPlayerTimeFormat.REGULAR,\n    canAirplay: false,\n    hideNextEpisodeBtn: false,\n    shouldStartFromBeginning: false,\n  },\n\n  setShouldStartFromBeginning(val) {\n    set((s) => {\n      s.interface.shouldStartFromBeginning = val;\n    });\n  },\n  setLastVolume(state) {\n    set((s) => {\n      s.interface.lastVolume = state;\n    });\n  },\n  setHasOpenOverlay(state) {\n    set((s) => {\n      s.interface.hasOpenOverlay = state;\n    });\n  },\n  setTimeFormat(format) {\n    set((s) => {\n      s.interface.timeFormat = format;\n    });\n  },\n  updateInterfaceHovering(newState: PlayerHoverState) {\n    set((s) => {\n      if (newState !== PlayerHoverState.NOT_HOVERING)\n        s.interface.lastHoveringState = newState;\n      s.interface.hovering = newState;\n    });\n  },\n  setSeeking(seeking) {\n    const display = get().display;\n    display?.setSeeking(seeking);\n    set((s) => {\n      s.interface.isSeeking = seeking;\n    });\n  },\n  setHoveringLeftControls(state) {\n    set((s) => {\n      s.interface.leftControlHovering = state;\n    });\n  },\n  setHoveringAnyControls(state) {\n    set((s) => {\n      s.interface.isHoveringControls = state;\n    });\n  },\n  hideNextEpisodeButton() {\n    set((s) => {\n      s.interface.hideNextEpisodeBtn = true;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface PlayingSlice {\n  mediaPlaying: {\n    isPlaying: boolean;\n    isPaused: boolean;\n    isSeeking: boolean; // seeking with progress bar\n    isDragSeeking: boolean; // is seeking for our custom progress bar\n    isLoading: boolean; // buffering or not\n    hasPlayedOnce: boolean; // has the video played at all?\n    volume: number;\n    playbackRate: number;\n  };\n  play(): void;\n  pause(): void;\n}\n\nexport const createPlayingSlice: MakeSlice<PlayingSlice> = (set) => ({\n  mediaPlaying: {\n    isPlaying: false,\n    isPaused: true,\n    isLoading: false,\n    isSeeking: false,\n    isDragSeeking: false,\n    hasPlayedOnce: false,\n    volume: 1,\n    playbackRate: 1,\n  },\n  play() {\n    set((state) => {\n      state.mediaPlaying.isPlaying = true;\n      state.mediaPlaying.isPaused = false;\n    });\n  },\n  pause() {\n    set((state) => {\n      state.mediaPlaying.isPlaying = false;\n      state.mediaPlaying.isPaused = false;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface ProgressSlice {\n  progress: {\n    time: number; // current time of video\n    duration: number; // length of video\n    buffered: number; // how much is buffered\n    draggingTime: number; // when dragging, time thats at the cursor\n  };\n  setDraggingTime(draggingTime: number): void;\n}\n\nexport const createProgressSlice: MakeSlice<ProgressSlice> = (set) => ({\n  progress: {\n    time: 0,\n    duration: 0,\n    buffered: 0,\n    draggingTime: 0,\n  },\n  setDraggingTime(draggingTime: number) {\n    set((s) => {\n      s.progress.draggingTime = draggingTime;\n    });\n  },\n});\n","import { MakeSlice } from \"@/stores/player/slices/types\";\n\nexport interface ThumbnailImage {\n  at: number;\n  data: string;\n}\n\nexport interface ThumbnailSlice {\n  thumbnails: {\n    images: ThumbnailImage[];\n    addImage(img: ThumbnailImage): void;\n    resetImages(): void;\n  };\n}\n\nexport interface ThumbnailImagePosition {\n  index: number;\n  image: ThumbnailImage;\n}\n\n/**\n * get nearest image at the timestamp provided\n * @param images images, must be sorted\n */\nexport function nearestImageAt(\n  images: ThumbnailImage[],\n  at: number,\n): ThumbnailImagePosition | null {\n  // no images, early return\n  if (images.length === 0) return null;\n\n  const indexPastTimestamp = images.findIndex((v) => v.at > at);\n\n  // no image found past timestamp, so last image must be closest\n  if (indexPastTimestamp === -1)\n    return {\n      index: images.length - 1,\n      image: images[images.length - 1],\n    };\n\n  const imagePastTimestamp = images[indexPastTimestamp];\n\n  // if past timestamp is first image, just return that image\n  if (indexPastTimestamp === 0)\n    return {\n      index: indexPastTimestamp,\n      image: imagePastTimestamp,\n    };\n\n  //             distance before             distance past\n  //                    |                          |\n  //  [before] --------------------- [at] --------------------- [past]\n  const imageBeforeTimestamp = images[indexPastTimestamp - 1];\n  const distanceBefore = at - imageBeforeTimestamp.at;\n  const distancePast = imagePastTimestamp.at - at;\n\n  // if distance of before timestamp is smaller than the distance past\n  // before is closer, return that\n  //  [before] --X-------------- [past]\n  if (distanceBefore < distancePast)\n    return {\n      index: indexPastTimestamp - 1,\n      image: imageBeforeTimestamp,\n    };\n\n  // must be closer to past here, return past\n  //  [before] --------------X-- [past]\n  return {\n    index: indexPastTimestamp,\n    image: imagePastTimestamp,\n  };\n}\n\nexport const createThumbnailSlice: MakeSlice<ThumbnailSlice> = (set, get) => ({\n  thumbnails: {\n    images: [],\n    resetImages() {\n      set((s) => {\n        s.thumbnails.images = [];\n      });\n    },\n    addImage(img) {\n      const store = get();\n      const exactOrPastImageIndex = store.thumbnails.images.findIndex(\n        (v) => v.at >= img.at,\n      );\n\n      // not found past or exact, so just append to the end\n      if (exactOrPastImageIndex === -1) {\n        set((s) => {\n          s.thumbnails.images.push(img);\n          s.thumbnails.images = [...s.thumbnails.images];\n        });\n        return;\n      }\n\n      const exactOrPastImage = store.thumbnails.images[exactOrPastImageIndex];\n\n      // found exact, replace data\n      if (exactOrPastImage.at === img.at) {\n        set((s) => {\n          s.thumbnails.images[exactOrPastImageIndex] = img;\n          s.thumbnails.images = [...s.thumbnails.images];\n        });\n        return;\n      }\n\n      // found one past, insert right before it\n      set((s) => {\n        s.thumbnails.images.splice(exactOrPastImageIndex, 0, img);\n        s.thumbnails.images = [...s.thumbnails.images];\n      });\n    },\n  },\n});\n","import { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\nimport { createCastingSlice } from \"@/stores/player/slices/casting\";\nimport { createDisplaySlice } from \"@/stores/player/slices/display\";\nimport { createInterfaceSlice } from \"@/stores/player/slices/interface\";\nimport { createPlayingSlice } from \"@/stores/player/slices/playing\";\nimport { createProgressSlice } from \"@/stores/player/slices/progress\";\nimport { createSourceSlice } from \"@/stores/player/slices/source\";\nimport { createThumbnailSlice } from \"@/stores/player/slices/thumbnails\";\nimport { AllSlices } from \"@/stores/player/slices/types\";\n\nexport const usePlayerStore = create(\n  immer<AllSlices>((...a) => ({\n    ...createInterfaceSlice(...a),\n    ...createProgressSlice(...a),\n    ...createPlayingSlice(...a),\n    ...createSourceSlice(...a),\n    ...createDisplaySlice(...a),\n    ...createCastingSlice(...a),\n    ...createThumbnailSlice(...a),\n  })),\n);\n","import { RunOutput } from \"@movie-web/providers\";\nimport DOMPurify from \"dompurify\";\nimport { convert, detect, parse } from \"subsrt-ts\";\nimport { ContentCaption } from \"subsrt-ts/dist/types/handler\";\n\nimport { CaptionListItem } from \"@/stores/player/slices/source\";\n\nexport type CaptionCueType = ContentCaption;\nexport const sanitize = DOMPurify.sanitize;\n\nexport function captionIsVisible(\n  start: number,\n  end: number,\n  delay: number,\n  currentTime: number,\n) {\n  const delayedStart = start / 1000 + delay;\n  const delayedEnd = end / 1000 + delay;\n  return (\n    Math.max(0, delayedStart) <= currentTime &&\n    Math.max(0, delayedEnd) >= currentTime\n  );\n}\n\nexport function makeQueId(index: number, start: number, end: number): string {\n  return `${index}-${start}-${end}`;\n}\n\nexport function convertSubtitlesToVtt(text: string): string {\n  const textTrimmed = text.trim();\n  if (textTrimmed === \"\") {\n    throw new Error(\"Given text is empty\");\n  }\n  const vtt = convert(textTrimmed, \"vtt\");\n  if (detect(vtt) === \"\") {\n    throw new Error(\"Invalid subtitle format\");\n  }\n  return vtt;\n}\n\nexport function convertSubtitlesToSrt(text: string): string {\n  const textTrimmed = text.trim();\n  if (textTrimmed === \"\") {\n    throw new Error(\"Given text is empty\");\n  }\n  const srt = convert(textTrimmed, \"srt\");\n  if (detect(srt) === \"\") {\n    throw new Error(\"Invalid subtitle format\");\n  }\n  return srt;\n}\n\nexport function filterDuplicateCaptionCues(cues: ContentCaption[]) {\n  return cues.reduce((acc: ContentCaption[], cap: ContentCaption) => {\n    const lastCap = acc[acc.length - 1];\n    const isSameAsLast =\n      lastCap?.start === cap.start &&\n      lastCap?.end === cap.end &&\n      lastCap?.content === cap.content;\n    if (lastCap === undefined || !isSameAsLast) {\n      acc.push(cap);\n    }\n    return acc;\n  }, []);\n}\n\nexport function parseVttSubtitles(vtt: string) {\n  return parse(vtt).filter((cue) => cue.type === \"caption\") as CaptionCueType[];\n}\n\nexport function parseSubtitles(\n  text: string,\n  _language?: string,\n): CaptionCueType[] {\n  const vtt = convertSubtitlesToVtt(text);\n  return parseVttSubtitles(vtt);\n}\n\nfunction stringToBase64(input: string): string {\n  return btoa(String.fromCodePoint(...new TextEncoder().encode(input)));\n}\n\nexport function convertSubtitlesToSrtDataurl(text: string): string {\n  return `data:application/x-subrip;base64,${stringToBase64(\n    convertSubtitlesToSrt(text),\n  )}`;\n}\n\nexport function convertSubtitlesToObjectUrl(text: string): string {\n  return URL.createObjectURL(\n    new Blob([convertSubtitlesToVtt(text)], {\n      type: \"text/vtt\",\n    }),\n  );\n}\n\nexport function convertProviderCaption(\n  captions: RunOutput[\"stream\"][\"captions\"],\n): CaptionListItem[] {\n  return captions.map((v) => ({\n    id: v.id,\n    language: v.language,\n    url: v.url,\n    needsProxy: v.hasCorsRestrictions,\n    opensubtitles: v.opensubtitles,\n  }));\n}\n","import { list } from \"subsrt-ts\";\n\nimport { proxiedFetch } from \"@/backend/helpers/fetch\";\nimport { convertSubtitlesToSrt } from \"@/components/player/utils/captions\";\nimport { CaptionListItem } from \"@/stores/player/slices/source\";\nimport { SimpleCache } from \"@/utils/cache\";\n\nimport {\n  isExtensionActiveCached,\n  sendExtensionRequest,\n} from \"../extension/messaging\";\n\nexport const subtitleTypeList = list().map((type) => `.${type}`);\nconst downloadCache = new SimpleCache<string, string>();\ndownloadCache.setCompare((a, b) => a === b);\nconst expirySeconds = 24 * 60 * 60;\n\n/**\n * Always returns SRT\n */\nexport async function downloadCaption(\n  caption: CaptionListItem,\n): Promise<string> {\n  const cached = downloadCache.get(caption.url);\n  if (cached) return cached;\n\n  let data: string | undefined;\n  if (caption.needsProxy) {\n    if (isExtensionActiveCached()) {\n      const extensionResponse = await sendExtensionRequest({\n        url: caption.url,\n        method: \"GET\",\n      });\n      if (\n        !extensionResponse?.success ||\n        typeof extensionResponse.response.body !== \"string\"\n      ) {\n        throw new Error(\"failed to get caption data from extension\");\n      }\n\n      data = extensionResponse.response.body;\n    } else {\n      data = await proxiedFetch<string>(caption.url, {\n        responseType: \"text\",\n        headers: {\n          \"Accept-Charset\": \"utf-8\",\n        },\n      });\n    }\n  } else {\n    const response = await fetch(caption.url);\n    const contentType = response.headers.get(\"content-type\") || \"\";\n    const charset = contentType.includes(\"charset=\")\n      ? contentType.split(\"charset=\")[1].toLowerCase()\n      : \"utf-8\";\n\n    // Get the raw bytes\n    const buffer = await response.arrayBuffer();\n    // Decode using the detected charset, defaulting to UTF-8\n    const decoder = new TextDecoder(charset);\n    data = decoder.decode(buffer);\n  }\n  if (!data) throw new Error(\"failed to get caption data\");\n\n  // Ensure the data is in UTF-8\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder(\"utf-8\");\n  const utf8Bytes = encoder.encode(data);\n  const utf8Data = decoder.decode(utf8Bytes);\n\n  const output = convertSubtitlesToSrt(utf8Data);\n  downloadCache.set(caption.url, output, expirySeconds);\n  return output;\n}\n\n/**\n * Downloads the WebVTT content. No different than a simple\n * get request with a cache.\n */\nexport async function downloadWebVTT(url: string): Promise<string> {\n  const cached = downloadCache.get(url);\n  if (cached) return cached;\n\n  const response = await fetch(url);\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  const charset = contentType.includes(\"charset=\")\n    ? contentType.split(\"charset=\")[1].toLowerCase()\n    : \"utf-8\";\n\n  // Get the raw bytes\n  const buffer = await response.arrayBuffer();\n  // Decode using the detected charset, defaulting to UTF-8\n  const decoder = new TextDecoder(charset);\n  const data = decoder.decode(buffer);\n\n  // Ensure the data is in UTF-8\n  const encoder = new TextEncoder();\n  const utf8Bytes = encoder.encode(data);\n  const utf8Data = decoder.decode(utf8Bytes);\n\n  downloadCache.set(url, utf8Data, expirySeconds);\n  return utf8Data;\n}\n","import { useCallback, useMemo } from \"react\";\nimport subsrt from \"subsrt-ts\";\n\nimport { downloadCaption, downloadWebVTT } from \"@/backend/helpers/subs\";\nimport { Caption } from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { useSubtitleStore } from \"@/stores/subtitles\";\n\nimport {\n  filterDuplicateCaptionCues,\n  parseVttSubtitles,\n} from \"../utils/captions\";\n\nexport function useCaptions() {\n  const setLanguage = useSubtitleStore((s) => s.setLanguage);\n  const enabled = useSubtitleStore((s) => s.enabled);\n  const resetSubtitleSpecificSettings = useSubtitleStore(\n    (s) => s.resetSubtitleSpecificSettings,\n  );\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const lastSelectedLanguage = useSubtitleStore((s) => s.lastSelectedLanguage);\n  const setIsOpenSubtitles = useSubtitleStore((s) => s.setIsOpenSubtitles);\n\n  const captionList = usePlayerStore((s) => s.captionList);\n  const getHlsCaptionList = usePlayerStore((s) => s.display?.getCaptionList);\n\n  const getSubtitleTracks = usePlayerStore((s) => s.display?.getSubtitleTracks);\n  const setSubtitlePreference = usePlayerStore(\n    (s) => s.display?.setSubtitlePreference,\n  );\n\n  const captions = useMemo(\n    () =>\n      captionList.length !== 0 ? captionList : (getHlsCaptionList?.() ?? []),\n    [captionList, getHlsCaptionList],\n  );\n\n  const selectCaptionById = useCallback(\n    async (captionId: string) => {\n      const caption = captions.find((v) => v.id === captionId);\n      if (!caption) return;\n\n      const captionToSet: Caption = {\n        id: caption.id,\n        language: caption.language,\n        url: caption.url,\n        srtData: \"\",\n      };\n\n      if (!caption.hls) {\n        const srtData = await downloadCaption(caption);\n        captionToSet.srtData = srtData;\n      } else {\n        // request a language change to hls, so it can load the subtitles\n        await setSubtitlePreference?.(caption.language);\n        const track = getSubtitleTracks?.().find(\n          (t) => t.id.toString() === caption.id && t.details !== undefined,\n        );\n        if (!track) return;\n\n        const fragments =\n          track.details?.fragments?.filter(\n            (frag) => frag !== null && frag.url !== null,\n          ) ?? [];\n\n        const vttCaptions = (\n          await Promise.all(\n            fragments.map(async (frag) => {\n              const vtt = await downloadWebVTT(frag.url);\n              return parseVttSubtitles(vtt);\n            }),\n          )\n        ).flat();\n\n        const filtered = filterDuplicateCaptionCues(vttCaptions);\n\n        const srtData = subsrt.build(filtered, { format: \"srt\" });\n        captionToSet.srtData = srtData;\n      }\n\n      setIsOpenSubtitles(!!caption.opensubtitles);\n      setCaption(captionToSet);\n      resetSubtitleSpecificSettings();\n      setLanguage(caption.language);\n    },\n    [\n      setIsOpenSubtitles,\n      setLanguage,\n      captions,\n      setCaption,\n      resetSubtitleSpecificSettings,\n      getSubtitleTracks,\n      setSubtitlePreference,\n    ],\n  );\n\n  const selectLanguage = useCallback(\n    async (language: string) => {\n      const caption = captions.find((v) => v.language === language);\n      if (!caption) return;\n      return selectCaptionById(caption.id);\n    },\n    [captions, selectCaptionById],\n  );\n\n  const disable = useCallback(async () => {\n    setIsOpenSubtitles(false);\n    setCaption(null);\n    setLanguage(null);\n  }, [setCaption, setLanguage, setIsOpenSubtitles]);\n\n  const selectLastUsedLanguage = useCallback(async () => {\n    const language = lastSelectedLanguage ?? \"en\";\n    await selectLanguage(language);\n    return true;\n  }, [lastSelectedLanguage, selectLanguage]);\n\n  const toggleLastUsed = useCallback(async () => {\n    if (enabled) disable();\n    else await selectLastUsedLanguage();\n  }, [selectLastUsedLanguage, disable, enabled]);\n\n  const selectLastUsedLanguageIfEnabled = useCallback(async () => {\n    if (enabled) await selectLastUsedLanguage();\n  }, [selectLastUsedLanguage, enabled]);\n\n  return {\n    selectLanguage,\n    disable,\n    selectLastUsedLanguage,\n    toggleLastUsed,\n    selectLastUsedLanguageIfEnabled,\n    selectCaptionById,\n  };\n}\n","import { useCallback, useEffect, useMemo, useRef } from \"react\";\n\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { useVolumeStore } from \"@/stores/volume\";\n\nimport { useCaptions } from \"./useCaptions\";\n\nexport function useInitializePlayer() {\n  const display = usePlayerStore((s) => s.display);\n  const volume = useVolumeStore((s) => s.volume);\n\n  const init = useCallback(() => {\n    display?.setVolume(volume);\n  }, [display, volume]);\n\n  return {\n    init,\n  };\n}\n\nexport function useInitializeSource() {\n  const source = usePlayerStore((s) => s.source);\n  const sourceIdentifier = useMemo(\n    () => (source ? JSON.stringify(source) : null),\n    [source],\n  );\n  const { selectLastUsedLanguageIfEnabled } = useCaptions();\n\n  const funRef = useRef(selectLastUsedLanguageIfEnabled);\n  useEffect(() => {\n    funRef.current = selectLastUsedLanguageIfEnabled;\n  }, [selectLastUsedLanguageIfEnabled]);\n\n  useEffect(() => {\n    if (sourceIdentifier) funRef.current();\n  }, [sourceIdentifier]);\n}\n","import { useInitializePlayer } from \"@/components/player/hooks/useInitializePlayer\";\nimport {\n  CaptionListItem,\n  PlayerMeta,\n  PlayerStatus,\n  playerStatus,\n} from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { SourceSliceSource } from \"@/stores/player/utils/qualities\";\nimport { ProgressMediaItem, useProgressStore } from \"@/stores/progress\";\n\nexport interface Source {\n  url: string;\n  type: \"hls\" | \"mp4\";\n}\n\nfunction getProgress(\n  items: Record<string, ProgressMediaItem>,\n  meta: PlayerMeta | null,\n): number {\n  const item = items[meta?.tmdbId ?? \"\"];\n  if (!item || !meta) return 0;\n  if (meta.type === \"movie\") {\n    if (!item.progress) return 0;\n    return item.progress.watched;\n  }\n\n  const ep = item.episodes[meta.episode?.tmdbId ?? \"\"];\n  if (!ep) return 0;\n  return ep.progress.watched;\n}\n\nexport function usePlayer() {\n  const setStatus = usePlayerStore((s) => s.setStatus);\n  const setMeta = usePlayerStore((s) => s.setMeta);\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const status = usePlayerStore((s) => s.status);\n  const shouldStartFromBeginning = usePlayerStore(\n    (s) => s.interface.shouldStartFromBeginning,\n  );\n  const setShouldStartFromBeginning = usePlayerStore(\n    (s) => s.setShouldStartFromBeginning,\n  );\n  const reset = usePlayerStore((s) => s.reset);\n  const meta = usePlayerStore((s) => s.meta);\n  const { init } = useInitializePlayer();\n  const progressStore = useProgressStore();\n\n  return {\n    meta,\n    reset,\n    status,\n    shouldStartFromBeginning,\n    setShouldStartFromBeginning,\n    setMeta(m: PlayerMeta, newStatus?: PlayerStatus) {\n      setMeta(m, newStatus);\n    },\n    playMedia(\n      source: SourceSliceSource,\n      captions: CaptionListItem[],\n      sourceId: string | null,\n      startAtOverride?: number,\n    ) {\n      const start = startAtOverride ?? getProgress(progressStore.items, meta);\n      setCaption(null);\n      setSource(source, captions, start);\n      setSourceId(sourceId);\n      setStatus(playerStatus.PLAYING);\n      init();\n    },\n    setScrapeStatus() {\n      setStatus(playerStatus.SCRAPING);\n    },\n    setScrapeNotFound() {\n      setStatus(playerStatus.SCRAPE_NOT_FOUND);\n    },\n  };\n}\n","import { detect } from \"detect-browser\";\nimport fscreen from \"fscreen\";\nimport Hls from \"hls.js\";\n\nexport const isSafari = /^((?!chrome|android).)*safari/i.test(\n  navigator.userAgent,\n);\n\nlet cachedVolumeResult: boolean | null = null;\nexport async function canChangeVolume(): Promise<boolean> {\n  if (cachedVolumeResult === null) {\n    const timeoutPromise = new Promise<false>((resolve) => {\n      setTimeout(() => resolve(false), 1e3);\n    });\n    const promise = new Promise<true>((resolve) => {\n      const video = document.createElement(\"video\");\n      const handler = () => {\n        video.removeEventListener(\"volumechange\", handler);\n        resolve(true);\n      };\n\n      video.addEventListener(\"volumechange\", handler);\n\n      video.volume = 0.5;\n    });\n\n    cachedVolumeResult = await Promise.race([promise, timeoutPromise]);\n  }\n  return cachedVolumeResult;\n}\n\nexport function canFullscreenAnyElement(): boolean {\n  return fscreen.fullscreenEnabled;\n}\n\nexport function canWebkitFullscreen(): boolean {\n  return canFullscreenAnyElement() || isSafari;\n}\n\nexport function canFullscreen(): boolean {\n  return canFullscreenAnyElement() || canWebkitFullscreen();\n}\n\nexport function canPictureInPicture(): boolean {\n  return \"pictureInPictureEnabled\" in document;\n}\n\nexport function canWebkitPictureInPicture(): boolean {\n  return \"webkitSupportsPresentationMode\" in document.createElement(\"video\");\n}\n\nexport function canPlayHlsNatively(video: HTMLVideoElement): boolean {\n  if (Hls.isSupported()) return false; // no need to play natively\n  return !!video.canPlayType(\"application/vnd.apple.mpegurl\");\n}\n\nexport type ExtensionDetectionResult =\n  | \"unknown\" // unknown detection or weird browser\n  | \"firefox\" // firefox extensions\n  | \"chrome\" // chrome extension (could be chromium, but still works with chrome extensions)\n  | \"ios\"; // ios, no extensions\n\nexport function detectExtensionInstall(): ExtensionDetectionResult {\n  const res = detect();\n\n  // not a browser or failed to detect\n  if (res?.type !== \"browser\") return \"unknown\";\n\n  if (res.name === \"ios\" || res.name === \"ios-webview\") return \"ios\";\n  if (\n    res.name === \"chrome\" ||\n    res.name === \"chromium-webview\" ||\n    res.name === \"edge-chromium\" ||\n    res.name === \"opera\"\n  )\n    return \"chrome\";\n  if (res.name === \"firefox\") return \"firefox\";\n  return \"unknown\";\n}\n","import React, { RefObject, useCallback, useEffect, useState } from \"react\";\n\nexport type MouseActivity = React.MouseEvent<HTMLElement> | MouseEvent;\n\ntype ActivityEvent = MouseActivity | React.TouchEvent<HTMLElement> | TouchEvent;\n\nexport function makePercentageString(num: number) {\n  return `${num.toFixed(2)}%`;\n}\n\nexport function makePercentage(num: number) {\n  return Number(Math.max(0, Math.min(num, 100)).toFixed(2));\n}\n\nfunction isClickEvent(\n  evt: ActivityEvent,\n): evt is React.MouseEvent<HTMLElement> | MouseEvent {\n  return (\n    evt.type === \"mousedown\" ||\n    evt.type === \"mouseup\" ||\n    evt.type === \"mousemove\"\n  );\n}\n\nconst getEventX = (evt: ActivityEvent) => {\n  return isClickEvent(evt) ? evt.pageX : evt.changedTouches[0].pageX;\n};\n\nexport function useProgressBar(\n  barRef: RefObject<HTMLElement>,\n  commit: (percentage: number) => void,\n  commitImmediately = false,\n) {\n  const [mouseDown, setMouseDown] = useState<boolean>(false);\n  const [progress, setProgress] = useState<number>(0);\n\n  useEffect(() => {\n    function mouseMove(ev: ActivityEvent) {\n      if (!mouseDown || !barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos = (getEventX(ev) - rect.left) / barRef.current.offsetWidth;\n      setProgress(pos * 100);\n      if (commitImmediately) commit(pos);\n    }\n\n    function mouseUp(ev: ActivityEvent) {\n      if (!mouseDown) return;\n      setMouseDown(false);\n      document.body.removeAttribute(\"data-no-select\");\n\n      if (!barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos = (getEventX(ev) - rect.left) / barRef.current.offsetWidth;\n      commit(pos);\n    }\n\n    document.addEventListener(\"mousemove\", mouseMove);\n    document.addEventListener(\"touchmove\", mouseMove);\n    document.addEventListener(\"mouseup\", mouseUp);\n    document.addEventListener(\"touchend\", mouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", mouseMove);\n      document.removeEventListener(\"touchmove\", mouseMove);\n      document.removeEventListener(\"mouseup\", mouseUp);\n      document.removeEventListener(\"touchend\", mouseUp);\n    };\n  }, [mouseDown, barRef, commit, commitImmediately]);\n\n  const dragMouseDown = useCallback(\n    (ev: ActivityEvent) => {\n      setMouseDown(true);\n      document.body.setAttribute(\"data-no-select\", \"true\");\n\n      if (!barRef.current) return;\n      const rect = barRef.current.getBoundingClientRect();\n      const pos =\n        ((getEventX(ev) - rect.left) / barRef.current.offsetWidth) * 100;\n      setProgress(pos);\n    },\n    [setProgress, barRef],\n  );\n\n  return {\n    dragging: mouseDown,\n    dragPercentage: progress,\n    dragMouseDown,\n  };\n}\n","export function formatSeconds(secs: number, showHours = false): string {\n  if (Number.isNaN(secs)) {\n    if (showHours) return \"0:00:00\";\n    return \"0:00\";\n  }\n\n  let time = secs;\n  const seconds = Math.floor(time % 60);\n\n  time /= 60;\n  const minutes = Math.floor(time % 60);\n\n  time /= 60;\n  const hours = Math.floor(time);\n\n  const paddedSecs = seconds.toString().padStart(2, \"0\");\n  const paddedMins = minutes.toString().padStart(2, \"0\");\n\n  if (!showHours) return [paddedMins, paddedSecs].join(\":\");\n  return [hours, paddedMins, paddedSecs].join(\":\");\n}\n\nexport function durationExceedsHour(secs: number): boolean {\n  return secs > 60 * 60;\n}\n","import { usePlayerStore } from \"@/stores/player/store\";\nimport { useVolumeStore } from \"@/stores/volume\";\n\nexport function useVolume() {\n  const volume = usePlayerStore((s) => s.mediaPlaying.volume);\n  const lastVolume = usePlayerStore((s) => s.interface.lastVolume);\n  const setLastVolume = usePlayerStore((s) => s.setLastVolume);\n  const display = usePlayerStore((s) => s.display);\n  const setStoredVolume = useVolumeStore((s) => s.setVolume);\n\n  const toggleVolume = () => {\n    let newVolume = 0;\n\n    if (volume > 0) {\n      newVolume = 0;\n      setLastVolume(volume);\n    } else if (lastVolume > 0) newVolume = lastVolume;\n    else newVolume = 1;\n\n    display?.setVolume(newVolume);\n    setStoredVolume(newVolume);\n  };\n\n  return {\n    toggleMute() {\n      toggleVolume();\n    },\n    setVolume(vol: number) {\n      setStoredVolume(vol);\n      setLastVolume(vol);\n      display?.setVolume(vol);\n    },\n  };\n}\n","import { Stream } from \"@movie-web/providers\";\n\nimport { RULE_IDS, setDomainRule } from \"@/backend/extension/messaging\";\n\nfunction extractDomain(url: string): string | null {\n  try {\n    const u = new URL(url);\n    return u.hostname;\n  } catch {\n    return null;\n  }\n}\n\nfunction extractDomainsFromStream(stream: Stream): string[] {\n  if (stream.type === \"hls\") {\n    return [extractDomain(stream.playlist)].filter((v): v is string => !!v);\n  }\n  if (stream.type === \"file\") {\n    return Object.values(stream.qualities)\n      .map((v) => extractDomain(v.url))\n      .filter((v): v is string => !!v);\n  }\n  return [];\n}\n\nfunction buildHeadersFromStream(stream: Stream): Record<string, string> {\n  const headers: Record<string, string> = {};\n  Object.entries(stream.headers ?? {}).forEach((entry) => {\n    headers[entry[0]] = entry[1];\n  });\n  Object.entries(stream.preferredHeaders ?? {}).forEach((entry) => {\n    headers[entry[0]] = entry[1];\n  });\n  return headers;\n}\n\nexport async function prepareStream(stream: Stream) {\n  await setDomainRule({\n    ruleId: RULE_IDS.PREPARE_STREAM,\n    targetDomains: extractDomainsFromStream(stream),\n    requestHeaders: buildHeadersFromStream(stream),\n  });\n}\n","import {\n  makeProviders,\n  makeStandardFetcher,\n  targets,\n} from \"@movie-web/providers\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport {\n  makeExtensionFetcher,\n  makeLoadBalancedSimpleProxyFetcher,\n  setupM3U8Proxy,\n} from \"@/backend/providers/fetchers\";\n\n// Initialize M3U8 proxy on module load\nsetupM3U8Proxy();\n\nexport function getProviders() {\n  if (isExtensionActiveCached()) {\n    return makeProviders({\n      fetcher: makeStandardFetcher(fetch),\n      proxiedFetcher: makeExtensionFetcher(),\n      target: targets.BROWSER_EXTENSION,\n      consistentIpForRequests: true,\n    });\n  }\n\n  setupM3U8Proxy();\n\n  return makeProviders({\n    fetcher: makeStandardFetcher(fetch),\n    proxiedFetcher: makeLoadBalancedSimpleProxyFetcher(),\n    target: targets.BROWSER,\n  });\n}\n\nexport function getAllProviders() {\n  return makeProviders({\n    fetcher: makeStandardFetcher(fetch),\n    target: targets.BROWSER_EXTENSION,\n    consistentIpForRequests: true,\n  });\n}\n","import { Stream } from \"@movie-web/providers\";\n\nimport {\n  SourceFileStream,\n  SourceQuality,\n  SourceSliceSource,\n} from \"@/stores/player/utils/qualities\";\n\nconst allowedQualitiesMap: Record<SourceQuality, SourceQuality> = {\n  \"4k\": \"4k\",\n  \"1080\": \"1080\",\n  \"480\": \"480\",\n  \"360\": \"360\",\n  \"720\": \"720\",\n  unknown: \"unknown\",\n};\nconst allowedQualities = Object.keys(allowedQualitiesMap);\nconst allowedFileTypes = [\"mp4\"];\n\nfunction isAllowedQuality(inp: string): inp is SourceQuality {\n  return allowedQualities.includes(inp);\n}\n\nexport function convertRunoutputToSource(out: {\n  stream: Stream;\n}): SourceSliceSource {\n  if (out.stream.type === \"hls\") {\n    return {\n      type: \"hls\",\n      url: out.stream.playlist,\n      headers: out.stream.headers,\n      preferredHeaders: out.stream.preferredHeaders,\n    };\n  }\n  if (out.stream.type === \"file\") {\n    const qualities: Partial<Record<SourceQuality, SourceFileStream>> = {};\n    Object.entries(out.stream.qualities).forEach((entry) => {\n      if (!isAllowedQuality(entry[0])) {\n        console.warn(`unrecognized quality: ${entry[0]}`);\n        return;\n      }\n      if (!allowedFileTypes.includes(entry[1].type)) {\n        console.warn(`unrecognized file type: ${entry[1].type}`);\n        return;\n      }\n      qualities[entry[0]] = {\n        type: entry[1].type,\n        url: entry[1].url,\n      };\n    });\n    return {\n      type: \"file\",\n      qualities,\n      headers: out.stream.headers,\n      preferredHeaders: out.stream.preferredHeaders,\n    };\n  }\n  throw new Error(\"unrecognized type\");\n}\n","import {\n  EmbedOutput,\n  NotFoundError,\n  SourcererOutput,\n} from \"@movie-web/providers\";\nimport { useAsyncFn } from \"react-use\";\n\nimport { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { prepareStream } from \"@/backend/extension/streams\";\nimport {\n  connectServerSideEvents,\n  makeProviderUrl,\n} from \"@/backend/helpers/providerApi\";\nimport {\n  scrapeSourceOutputToProviderMetric,\n  useReportProviders,\n} from \"@/backend/helpers/report\";\nimport { getLoadbalancedProviderApiUrl } from \"@/backend/providers/fetchers\";\nimport { getProviders } from \"@/backend/providers/providers\";\nimport { convertProviderCaption } from \"@/components/player/utils/captions\";\nimport { convertRunoutputToSource } from \"@/components/player/utils/convertRunoutputToSource\";\nimport { useOverlayRouter } from \"@/hooks/useOverlayRouter\";\nimport { metaToScrapeMedia } from \"@/stores/player/slices/source\";\nimport { usePlayerStore } from \"@/stores/player/store\";\n\nexport function useEmbedScraping(\n  routerId: string,\n  sourceId: string,\n  url: string,\n  embedId: string,\n) {\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const progress = usePlayerStore((s) => s.progress.time);\n  const meta = usePlayerStore((s) => s.meta);\n  const router = useOverlayRouter(routerId);\n  const { report } = useReportProviders();\n\n  const [request, run] = useAsyncFn(async () => {\n    const providerApiUrl = getLoadbalancedProviderApiUrl();\n    let result: EmbedOutput | undefined;\n    if (!meta) return;\n    try {\n      if (providerApiUrl && !isExtensionActiveCached()) {\n        const baseUrlMaker = makeProviderUrl(providerApiUrl);\n        const conn = await connectServerSideEvents<EmbedOutput>(\n          baseUrlMaker.scrapeEmbed(embedId, url),\n          [\"completed\", \"noOutput\"],\n        );\n        result = await conn.promise();\n      } else {\n        result = await getProviders().runEmbedScraper({\n          id: embedId,\n          url,\n        });\n      }\n    } catch (err) {\n      console.error(`Failed to scrape ${embedId}`, err);\n      const notFound = err instanceof NotFoundError;\n      const status = notFound ? \"notfound\" : \"failed\";\n      report([\n        scrapeSourceOutputToProviderMetric(\n          meta,\n          sourceId,\n          embedId,\n          status,\n          err,\n        ),\n      ]);\n      throw err;\n    }\n    report([\n      scrapeSourceOutputToProviderMetric(meta, sourceId, null, \"success\", null),\n    ]);\n    if (isExtensionActiveCached()) await prepareStream(result.stream[0]);\n    setSourceId(sourceId);\n    setCaption(null);\n    setSource(\n      convertRunoutputToSource({ stream: result.stream[0] }),\n      convertProviderCaption(result.stream[0].captions),\n      progress,\n    );\n    router.close();\n  }, [embedId, sourceId, meta, router, report, setCaption]);\n\n  return {\n    run,\n    loading: request.loading,\n    errored: !!request.error,\n  };\n}\n\nexport function useSourceScraping(sourceId: string | null, routerId: string) {\n  const meta = usePlayerStore((s) => s.meta);\n  const setSource = usePlayerStore((s) => s.setSource);\n  const setCaption = usePlayerStore((s) => s.setCaption);\n  const setSourceId = usePlayerStore((s) => s.setSourceId);\n  const progress = usePlayerStore((s) => s.progress.time);\n  const router = useOverlayRouter(routerId);\n  const { report } = useReportProviders();\n\n  const [request, run] = useAsyncFn(async () => {\n    if (!sourceId || !meta) return null;\n    const scrapeMedia = metaToScrapeMedia(meta);\n    const providerApiUrl = getLoadbalancedProviderApiUrl();\n\n    let result: SourcererOutput | undefined;\n    try {\n      if (providerApiUrl && !isExtensionActiveCached()) {\n        const baseUrlMaker = makeProviderUrl(providerApiUrl);\n        const conn = await connectServerSideEvents<SourcererOutput>(\n          baseUrlMaker.scrapeSource(sourceId, scrapeMedia),\n          [\"completed\", \"noOutput\"],\n        );\n        result = await conn.promise();\n      } else {\n        result = await getProviders().runSourceScraper({\n          id: sourceId,\n          media: scrapeMedia,\n        });\n      }\n    } catch (err) {\n      console.error(`Failed to scrape ${sourceId}`, err);\n      const notFound = err instanceof NotFoundError;\n      const status = notFound ? \"notfound\" : \"failed\";\n      report([\n        scrapeSourceOutputToProviderMetric(meta, sourceId, null, status, err),\n      ]);\n      throw err;\n    }\n    report([\n      scrapeSourceOutputToProviderMetric(meta, sourceId, null, \"success\", null),\n    ]);\n\n    if (result.stream) {\n      if (isExtensionActiveCached()) await prepareStream(result.stream[0]);\n      setCaption(null);\n      setSource(\n        convertRunoutputToSource({ stream: result.stream[0] }),\n        convertProviderCaption(result.stream[0].captions),\n        progress,\n      );\n      setSourceId(sourceId);\n      router.close();\n      return null;\n    }\n    if (result.embeds.length === 1) {\n      let embedResult: EmbedOutput | undefined;\n      if (!meta) return;\n      try {\n        if (providerApiUrl && !isExtensionActiveCached()) {\n          const baseUrlMaker = makeProviderUrl(providerApiUrl);\n          const conn = await connectServerSideEvents<EmbedOutput>(\n            baseUrlMaker.scrapeEmbed(\n              result.embeds[0].embedId,\n              result.embeds[0].url,\n            ),\n            [\"completed\", \"noOutput\"],\n          );\n          embedResult = await conn.promise();\n        } else {\n          embedResult = await getProviders().runEmbedScraper({\n            id: result.embeds[0].embedId,\n            url: result.embeds[0].url,\n          });\n        }\n      } catch (err) {\n        console.error(`Failed to scrape ${result.embeds[0].embedId}`, err);\n        const notFound = err instanceof NotFoundError;\n        const status = notFound ? \"notfound\" : \"failed\";\n        report([\n          scrapeSourceOutputToProviderMetric(\n            meta,\n            sourceId,\n            result.embeds[0].embedId,\n            status,\n            err,\n          ),\n        ]);\n        throw err;\n      }\n      report([\n        scrapeSourceOutputToProviderMetric(\n          meta,\n          sourceId,\n          result.embeds[0].embedId,\n          \"success\",\n          null,\n        ),\n      ]);\n      setSourceId(sourceId);\n      setCaption(null);\n      if (isExtensionActiveCached()) await prepareStream(embedResult.stream[0]);\n      setSource(\n        convertRunoutputToSource({ stream: embedResult.stream[0] }),\n        convertProviderCaption(embedResult.stream[0].captions),\n        progress,\n      );\n      router.close();\n    }\n    return result.embeds;\n  }, [sourceId, meta, router, setCaption]);\n\n  return {\n    run,\n    watching: (request.value ?? null) === null,\n    loading: request.loading,\n    items: request.value,\n    notfound: !!(request.error instanceof NotFoundError),\n    errored: !!request.error,\n  };\n}\n","import * as Cards from \"./Cards\";\nimport * as Links from \"./Links\";\nimport * as Misc from \"./Misc\";\nimport * as Sections from \"./Sections\";\n\nexport const Menu = {\n  ...Cards,\n  ...Links,\n  ...Sections,\n  ...Misc,\n};\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\nimport { usePlayerStore } from \"@/stores/player/store\";\n\ninterface WatchPartyStore {\n  // Whether the watch party feature is enabled\n  enabled: boolean;\n  // The room code for the watch party (4 digits)\n  roomCode: string | null;\n  // If the user is hosting (true) or joining (false)\n  isHost: boolean;\n  // Whether to show the status overlay on the player\n  showStatusOverlay: boolean;\n  // Enable watch party with a new room code\n  enableAsHost(): void;\n  // Enable watch party by joining an existing room\n  enableAsGuest(code: string): void;\n  // Update the room code\n  updateRoomCode(code: string): void;\n  // Disable watch party\n  disable(): void;\n  // Set status overlay visibility\n  setShowStatusOverlay(show: boolean): void;\n}\n\n// Generate a random 4-digit code\nconst generateRoomCode = (): string => {\n  return Math.floor(1000 + Math.random() * 9000).toString();\n};\n\n// Helper function to reset playback rate to 1x\nconst resetPlaybackRate = () => {\n  const display = usePlayerStore.getState().display;\n  if (display) {\n    display.setPlaybackRate(1);\n  }\n};\n\nexport const useWatchPartyStore = create<WatchPartyStore>()(\n  persist(\n    (set) => ({\n      enabled: false,\n      roomCode: null,\n      isHost: false,\n      showStatusOverlay: false,\n\n      enableAsHost: () => {\n        resetPlaybackRate();\n        set(() => ({\n          enabled: true,\n          roomCode: generateRoomCode(),\n          isHost: true,\n        }));\n      },\n\n      enableAsGuest: (code: string) => {\n        resetPlaybackRate();\n        set(() => ({\n          enabled: true,\n          roomCode: code,\n          isHost: false,\n        }));\n      },\n\n      updateRoomCode: (code: string) =>\n        set((state) => ({\n          ...state,\n          roomCode: code,\n        })),\n\n      disable: () =>\n        set(() => ({\n          enabled: false,\n          roomCode: null,\n        })),\n\n      setShowStatusOverlay: (show: boolean) =>\n        set(() => ({\n          showStatusOverlay: show,\n        })),\n    }),\n    {\n      name: \"watch-party-storage\",\n    },\n  ),\n);\n","import { isExtensionActiveCached } from \"@/backend/extension/messaging\";\nimport { conf } from \"@/setup/config\";\nimport { useAuthStore } from \"@/stores/auth\";\n\nexport function isAutoplayAllowed() {\n  return Boolean(\n    conf().ALLOW_AUTOPLAY ||\n      isExtensionActiveCached() ||\n      useAuthStore.getState().proxySet,\n  );\n}\n","/* eslint-disable no-console */\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n// import { getRoomStatuses, getUserPlayerStatus } from \"@/backend/player/status\";\nimport { getRoomStatuses } from \"@/backend/player/status\";\nimport { useBackendUrl } from \"@/hooks/auth/useBackendUrl\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { usePlayerStore } from \"@/stores/player/store\";\nimport { useWatchPartyStore } from \"@/stores/watchParty\";\n\ninterface RoomUser {\n  userId: string;\n  isHost: boolean;\n  lastUpdate: number;\n  player: {\n    isPlaying: boolean;\n    isPaused: boolean;\n    time: number;\n    duration: number;\n  };\n  content: {\n    title: string;\n    type: string;\n    tmdbId?: number;\n    seasonId?: number;\n    episodeId?: number;\n    seasonNumber?: number;\n    episodeNumber?: number;\n  };\n}\n\ninterface WatchPartySyncResult {\n  // All users in the room\n  roomUsers: RoomUser[];\n  // The host user (if any)\n  hostUser: RoomUser | null;\n  // Whether our player is behind the host\n  isBehindHost: boolean;\n  // Whether our player is ahead of the host\n  isAheadOfHost: boolean;\n  // Seconds difference from host (positive means ahead, negative means behind)\n  timeDifferenceFromHost: number;\n  // Function to sync with host\n  syncWithHost: () => void;\n  // Whether we are currently syncing\n  isSyncing: boolean;\n  // Manually refresh room data\n  refreshRoomData: () => Promise<void>;\n  // Current user count in room\n  userCount: number;\n}\n\n/**\n * Hook for syncing with other users in a watch party room\n */\nexport function useWatchPartySync(\n  syncThresholdSeconds = 5,\n): WatchPartySyncResult {\n  const [roomUsers, setRoomUsers] = useState<RoomUser[]>([]);\n  const [isSyncing, setIsSyncing] = useState(false);\n  const [userCount, setUserCount] = useState(1);\n\n  // Refs for tracking state\n  const syncStateRef = useRef({\n    lastUserCount: 1,\n    previousHostPlaying: null as boolean | null,\n    previousHostTime: null as number | null,\n    lastSyncTime: 0,\n    syncInProgress: false,\n    checkedUrlParams: false,\n    prevRoomUsers: [] as RoomUser[],\n  });\n\n  // Get our auth and backend info\n  const account = useAuthStore((s) => s.account);\n  const backendUrl = useBackendUrl();\n\n  // Get player store functions\n  const display = usePlayerStore((s) => s.display);\n  const currentTime = usePlayerStore((s) => s.progress.time);\n  const isPlaying = usePlayerStore((s) => s.mediaPlaying.isPlaying);\n  // Get watch party state\n  const { roomCode, isHost, enabled, enableAsGuest } = useWatchPartyStore();\n\n  // Check URL parameters for watch party code\n  useEffect(() => {\n    if (syncStateRef.current.checkedUrlParams) return;\n\n    try {\n      const params = new URLSearchParams(window.location.search);\n      const watchPartyCode = params.get(\"watchparty\");\n\n      if (watchPartyCode && !enabled && watchPartyCode.length > 0) {\n        enableAsGuest(watchPartyCode);\n      }\n\n      syncStateRef.current.checkedUrlParams = true;\n    } catch (error) {\n      console.error(\"Failed to check URL parameters for watch party:\", error);\n    }\n  }, [enabled, enableAsGuest]);\n\n  // Find the host user in the room\n  const hostUser = roomUsers.find((user) => user.isHost) || null;\n\n  // Calculate predicted host time by accounting for elapsed time since update\n  const getPredictedHostTime = useCallback(() => {\n    if (!hostUser) return 0;\n\n    const millisecondsSinceUpdate = Date.now() - hostUser.lastUpdate;\n    const secondsSinceUpdate = millisecondsSinceUpdate / 1000;\n\n    return hostUser.player.isPlaying && !hostUser.player.isPaused\n      ? hostUser.player.time + secondsSinceUpdate\n      : hostUser.player.time;\n  }, [hostUser]);\n\n  // Calculate time difference from host\n  const timeDifferenceFromHost = hostUser\n    ? currentTime - getPredictedHostTime()\n    : 0;\n\n  // Determine if we're ahead or behind the host\n  const isBehindHost =\n    hostUser && !isHost && timeDifferenceFromHost < -syncThresholdSeconds;\n  const isAheadOfHost =\n    hostUser && !isHost && timeDifferenceFromHost > syncThresholdSeconds;\n\n  // Function to sync with host\n  const syncWithHost = useCallback(() => {\n    if (!hostUser || isHost || !display || syncStateRef.current.syncInProgress)\n      return;\n\n    syncStateRef.current.syncInProgress = true;\n    setIsSyncing(true);\n\n    const predictedHostTime = getPredictedHostTime();\n    display.setTime(predictedHostTime);\n\n    setTimeout(() => {\n      if (hostUser.player.isPlaying && !hostUser.player.isPaused) {\n        display.play();\n      } else {\n        display.pause();\n      }\n\n      setTimeout(() => {\n        setIsSyncing(false);\n        syncStateRef.current.syncInProgress = false;\n      }, 500);\n\n      syncStateRef.current.lastSyncTime = Date.now();\n    }, 200);\n  }, [hostUser, isHost, display, getPredictedHostTime]);\n\n  // Combined effect for syncing time and play/pause state\n  useEffect(() => {\n    if (!hostUser || isHost || !display || syncStateRef.current.syncInProgress)\n      return;\n\n    const state = syncStateRef.current;\n    const hostIsPlaying =\n      hostUser.player.isPlaying && !hostUser.player.isPaused;\n    const predictedHostTime = getPredictedHostTime();\n    const difference = currentTime - predictedHostTime;\n\n    // Handle time sync\n    const activeThreshold = isPlaying ? 2 : 5;\n    const needsTimeSync = Math.abs(difference) > activeThreshold;\n\n    // Handle play state sync\n    const needsPlayStateSync =\n      state.previousHostPlaying !== null &&\n      state.previousHostPlaying !== hostIsPlaying;\n\n    // Handle time jumps\n    const needsJumpSync =\n      state.previousHostTime !== null &&\n      Math.abs(hostUser.player.time - state.previousHostTime) > 5;\n\n    // Sync if needed\n    if ((needsTimeSync || needsPlayStateSync || needsJumpSync) && !isSyncing) {\n      state.syncInProgress = true;\n      setIsSyncing(true);\n\n      // Sync time\n      display.setTime(predictedHostTime);\n\n      // Then sync play state after a short delay\n      setTimeout(() => {\n        if (hostIsPlaying) {\n          display.play();\n        } else {\n          display.pause();\n        }\n\n        // Clear syncing flags\n        setTimeout(() => {\n          setIsSyncing(false);\n          state.syncInProgress = false;\n        }, 500);\n      }, 200);\n    }\n\n    // Update state refs\n    state.previousHostPlaying = hostIsPlaying;\n    state.previousHostTime = hostUser.player.time;\n  }, [\n    hostUser,\n    isHost,\n    currentTime,\n    display,\n    isSyncing,\n    getPredictedHostTime,\n    isPlaying,\n  ]);\n\n  // Function to refresh room data\n  const refreshRoomData = useCallback(async () => {\n    if (!enabled || !roomCode || !backendUrl) return;\n\n    try {\n      const response = await getRoomStatuses(backendUrl, account, roomCode);\n      const users: RoomUser[] = [];\n\n      // Process each user's latest status\n      Object.entries(response.users).forEach(\n        ([userIdFromResponse, statuses]) => {\n          if (statuses.length > 0) {\n            // Get the latest status (sort by timestamp DESC)\n            const latestStatus = [...statuses].sort(\n              (a, b) => b.timestamp - a.timestamp,\n            )[0];\n\n            users.push({\n              userId: userIdFromResponse,\n              isHost: latestStatus.isHost,\n              lastUpdate: latestStatus.timestamp,\n              player: {\n                isPlaying: latestStatus.player.isPlaying,\n                isPaused: latestStatus.player.isPaused,\n                time: latestStatus.player.time,\n                duration: latestStatus.player.duration,\n              },\n              content: {\n                title: latestStatus.content.title,\n                type: latestStatus.content.type,\n                tmdbId: latestStatus.content.tmdbId,\n                seasonId: latestStatus.content.seasonId,\n                episodeId: latestStatus.content.episodeId,\n                seasonNumber: latestStatus.content.seasonNumber,\n                episodeNumber: latestStatus.content.episodeNumber,\n              },\n            });\n          }\n        },\n      );\n\n      // Sort users with host first, then by lastUpdate\n      users.sort((a, b) => {\n        if (a.isHost && !b.isHost) return -1;\n        if (!a.isHost && b.isHost) return 1;\n        return b.lastUpdate - a.lastUpdate;\n      });\n\n      // Update user count if changed\n      const newUserCount = users.length;\n      if (newUserCount !== syncStateRef.current.lastUserCount) {\n        setUserCount(newUserCount);\n        syncStateRef.current.lastUserCount = newUserCount;\n      }\n\n      // Update room users\n      syncStateRef.current.prevRoomUsers = users;\n      setRoomUsers(users);\n    } catch (error) {\n      console.error(\"Failed to refresh room data:\", error);\n    }\n  }, [backendUrl, account, roomCode, enabled]);\n\n  // Periodically refresh room data\n  useEffect(() => {\n    // Store reference to current syncState for cleanup\n    const syncState = syncStateRef.current;\n\n    if (!enabled || !roomCode) {\n      setRoomUsers([]);\n      setUserCount(1);\n\n      // Reset all state\n      syncState.lastUserCount = 1;\n      syncState.prevRoomUsers = [];\n      syncState.previousHostPlaying = null;\n      syncState.previousHostTime = null;\n      return;\n    }\n\n    // Initial fetch\n    refreshRoomData();\n\n    // Set up interval - refresh every 2 seconds\n    const interval = setInterval(refreshRoomData, 2000);\n\n    return () => {\n      clearInterval(interval);\n      setRoomUsers([]);\n      setUserCount(1);\n\n      // Use captured reference from outer scope\n      syncState.previousHostPlaying = null;\n      syncState.previousHostTime = null;\n    };\n  }, [enabled, roomCode, refreshRoomData]);\n\n  return {\n    roomUsers,\n    hostUser,\n    isBehindHost: !!isBehindHost,\n    isAheadOfHost: !!isAheadOfHost,\n    timeDifferenceFromHost,\n    syncWithHost,\n    isSyncing,\n    refreshRoomData,\n    userCount,\n  };\n}\n","import { useCallback, useMemo } from \"react\";\n\nimport { DetailedMeta } from \"@/backend/metadata/getmeta\";\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport { usePlayer } from \"@/components/player/hooks/usePlayer\";\nimport {\n  PlayerMeta,\n  metaToScrapeMedia,\n  playerStatus,\n} from \"@/stores/player/slices/source\";\n\nexport function usePlayerMeta() {\n  const { meta, setMeta } = usePlayer();\n  const scrapeMedia = useMemo(\n    () => (meta ? metaToScrapeMedia(meta) : null),\n    [meta],\n  );\n\n  const setDirectMeta = useCallback(\n    (m: PlayerMeta) => {\n      setMeta(m, playerStatus.SCRAPING);\n    },\n    [setMeta],\n  );\n\n  const setPlayerMeta = useCallback(\n    (m: DetailedMeta, episodeId?: string) => {\n      let playerMeta: PlayerMeta;\n      if (m.meta.type === MWMediaType.SERIES) {\n        const ep = m.meta.seasonData.episodes.find((v) => v.id === episodeId);\n        if (!ep) return null;\n        playerMeta = {\n          type: \"show\",\n          releaseYear: +(m.meta.year ?? 0),\n          title: m.meta.title,\n          poster: m.meta.poster,\n          tmdbId: m.tmdbId ?? \"\",\n          imdbId: m.imdbId,\n          episodes: m.meta.seasonData.episodes.map((v) => ({\n            number: v.number,\n            title: v.title,\n            tmdbId: v.id,\n            air_date: v.air_date,\n          })),\n          episode: {\n            number: ep.number,\n            title: ep.title,\n            tmdbId: ep.id,\n            air_date: ep.air_date,\n          },\n          season: {\n            number: m.meta.seasonData.number,\n            title: m.meta.seasonData.title,\n            tmdbId: m.meta.seasonData.id,\n          },\n        };\n      } else {\n        playerMeta = {\n          type: \"movie\",\n          releaseYear: +(m.meta.year ?? 0),\n          title: m.meta.title,\n          poster: m.meta.poster,\n          tmdbId: m.tmdbId ?? \"\",\n          imdbId: m.imdbId,\n        };\n      }\n      setDirectMeta(playerMeta);\n      return playerMeta;\n    },\n    [setDirectMeta],\n  );\n\n  return {\n    playerMeta: meta,\n    setPlayerMeta,\n    setDirectMeta,\n    scrapeMedia,\n  };\n}\n","const hasAiredCache: { [key: string]: boolean } = {};\n\nexport function hasAired(date: string) {\n  if (hasAiredCache[date]) return hasAiredCache[date];\n\n  const now = new Date();\n  const airDate = new Date(date);\n\n  hasAiredCache[date] = airDate < now;\n  return hasAiredCache[date];\n}\n","import { create } from \"zustand\";\n\ntype OverlayType = \"volume\" | \"subtitle\" | null;\n\ninterface OverlayStackStore {\n  currentOverlay: OverlayType;\n  setCurrentOverlay: (overlay: OverlayType) => void;\n}\n\nexport const useOverlayStack = create<OverlayStackStore>((set) => ({\n  currentOverlay: null,\n  setCurrentOverlay: (overlay) => set({ currentOverlay: overlay }),\n}));\n","export function handleBuffered(time: number, buffered: TimeRanges): number {\n  for (let i = 0; i < buffered.length; i += 1) {\n    if (buffered.start(buffered.length - 1 - i) < time) {\n      return buffered.end(buffered.length - 1 - i);\n    }\n  }\n  return 0;\n}\n","const mediaErrorMap: Record<number, { name: string; key: string }> = {\n  1: {\n    name: \"MEDIA_ERR_ABORTED\",\n    key: \"player.playbackError.errors.errorAborted\",\n  },\n  2: {\n    name: \"MEDIA_ERR_NETWORK\",\n    key: \"player.playbackError.errors.errorNetwork\",\n  },\n  3: {\n    name: \"MEDIA_ERR_DECODE\",\n    key: \"player.playbackError.errors.errorDecode\",\n  },\n  4: {\n    name: \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    key: \"player.playbackError.errors.errorNotSupported\",\n  },\n};\n\nexport function getMediaErrorDetails(\n  err: MediaError | null,\n): (typeof mediaErrorMap)[number] {\n  const item = mediaErrorMap[err?.code ?? -1];\n  if (!item) {\n    return {\n      name: \"MEDIA_ERR_GENERIC\",\n      key: \"player.playbackError.errors.errorGenericMedia\",\n    };\n  }\n  return item;\n}\n","import { conf } from \"@/setup/config\";\n\nexport function processCdnLink(url: string): string {\n  const parsedUrl = new URL(url);\n  const replacements = conf().CDN_REPLACEMENTS;\n  for (const [before, after] of replacements) {\n    if (parsedUrl.hostname.endsWith(before)) {\n      parsedUrl.hostname = after;\n      parsedUrl.port = \"\";\n      parsedUrl.protocol = \"https://\";\n      return parsedUrl.toString();\n    }\n  }\n\n  return url;\n}\n","export type EventMap = Record<string, any>;\ntype EventKey<T extends EventMap> = string & keyof T;\ntype EventReceiver<T> = (params: T) => void;\n\nexport interface Emitter<T extends EventMap> {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n}\n\nexport interface Listener<T extends EventMap> {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n}\n\nexport function makeEmitter<T extends EventMap>(): Emitter<T> {\n  const listeners: Partial<\n    Record<EventKey<T>, ((...params: any[]) => void)[]>\n  > = {};\n\n  return {\n    on(eventName, fn) {\n      if (!listeners[eventName]) listeners[eventName] = [];\n      listeners[eventName]?.push(fn);\n    },\n    off(eventName, fn) {\n      listeners[eventName] =\n        listeners[eventName]?.filter((v) => v !== fn) ?? [];\n    },\n    emit(eventName, params) {\n      (listeners[eventName] ?? []).forEach((fn) => fn(params));\n    },\n  };\n}\n","import fscreen from \"fscreen\";\nimport Hls, { Level } from \"hls.js\";\n\nimport {\n  RULE_IDS,\n  isExtensionActiveCached,\n  setDomainRule,\n} from \"@/backend/extension/messaging\";\nimport {\n  DisplayInterface,\n  DisplayInterfaceEvents,\n} from \"@/components/player/display/displayInterface\";\nimport { handleBuffered } from \"@/components/player/utils/handleBuffered\";\nimport { getMediaErrorDetails } from \"@/components/player/utils/mediaErrorDetails\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport {\n  LoadableSource,\n  SourceQuality,\n  getPreferredQuality,\n} from \"@/stores/player/utils/qualities\";\nimport { processCdnLink } from \"@/utils/cdn\";\nimport {\n  canChangeVolume,\n  canFullscreen,\n  canFullscreenAnyElement,\n  canPictureInPicture,\n  canPlayHlsNatively,\n  canWebkitFullscreen,\n  canWebkitPictureInPicture,\n} from \"@/utils/detectFeatures\";\nimport { makeEmitter } from \"@/utils/events\";\n\nconst levelConversionMap: Record<number, SourceQuality> = {\n  360: \"360\",\n  1080: \"1080\",\n  720: \"720\",\n  480: \"480\",\n  2160: \"4k\",\n};\n\n// Define quality thresholds for mapping non-standard resolutions\nconst qualityThresholds = [\n  { minHeight: 1800, quality: \"4k\" as SourceQuality },\n  { minHeight: 800, quality: \"1080\" as SourceQuality },\n  { minHeight: 600, quality: \"720\" as SourceQuality },\n  { minHeight: 420, quality: \"480\" as SourceQuality },\n  { minHeight: 0, quality: \"360\" as SourceQuality },\n];\n\nfunction hlsLevelToQuality(level?: Level): SourceQuality | null {\n  if (!level?.height) return null;\n\n  // First check for exact matches\n  const exactMatch = levelConversionMap[level.height];\n  if (exactMatch) return exactMatch;\n\n  // For non-standard resolutions, map to closest standard quality\n  for (const threshold of qualityThresholds) {\n    if (level.height >= threshold.minHeight) {\n      return threshold.quality;\n    }\n  }\n\n  return \"unknown\"; // fallback to unknown quality\n}\n\nfunction hlsLevelsToQualities(levels: Level[]): SourceQuality[] {\n  return levels\n    .map((v) => hlsLevelToQuality(v))\n    .filter((v): v is SourceQuality => !!v);\n}\n\n// Sort levels by quality (height) to ensure we can select the best one\nfunction sortLevelsByQuality(levels: Level[]): Level[] {\n  return [...levels].sort((a, b) => (b.height || 0) - (a.height || 0));\n}\n\nexport function makeVideoElementDisplayInterface(): DisplayInterface {\n  const { emit, on, off } = makeEmitter<DisplayInterfaceEvents>();\n  let source: LoadableSource | null = null;\n  let hls: Hls | null = null;\n  let videoElement: HTMLVideoElement | null = null;\n  let containerElement: HTMLElement | null = null;\n  let isFullscreen = false;\n  let isPausedBeforeSeeking = false;\n  let isSeeking = false;\n  let startAt = 0;\n  let automaticQuality = false;\n  let preferenceQuality: SourceQuality | null = null;\n  let lastVolume = 1;\n\n  const languagePromises = new Map<\n    string,\n    (value: void | PromiseLike<void>) => void\n  >();\n\n  function reportLevels() {\n    if (!hls) return;\n    const levels = hls.levels;\n    const convertedLevels = levels\n      .map((v) => hlsLevelToQuality(v))\n      .filter((v): v is SourceQuality => !!v);\n    emit(\"qualities\", convertedLevels);\n  }\n\n  function reportAudioTracks() {\n    if (!hls) return;\n    const currentLanguage = useLanguageStore.getState().language;\n    const audioTracks = hls.audioTracks;\n    const languageTrack = audioTracks.find((v) => v.lang === currentLanguage);\n    if (languageTrack) {\n      hls.audioTrack = audioTracks.indexOf(languageTrack);\n    }\n    const currentTrack = audioTracks?.[hls.audioTrack ?? 0];\n    if (!currentTrack) return;\n    emit(\"changedaudiotrack\", {\n      id: currentTrack.id.toString(),\n      label: currentTrack.name,\n      language: currentTrack.lang ?? \"unknown\",\n    });\n    emit(\n      \"audiotracks\",\n      hls.audioTracks.map((v) => ({\n        id: v.id.toString(),\n        label: v.name,\n        language: v.lang ?? \"unknown\",\n      })),\n    );\n  }\n\n  function setupQualityForHls() {\n    if (videoElement && canPlayHlsNatively(videoElement)) {\n      return; // nothing to change\n    }\n\n    if (!hls) return;\n    if (!automaticQuality) {\n      const sortedLevels = sortLevelsByQuality(hls.levels);\n      const qualities = hlsLevelsToQualities(sortedLevels);\n      const availableQuality = getPreferredQuality(qualities, {\n        lastChosenQuality: preferenceQuality,\n        automaticQuality,\n      });\n      if (availableQuality) {\n        // Find the best level that matches our preferred quality\n        const matchingLevels = hls.levels.filter(\n          (level) => hlsLevelToQuality(level) === availableQuality,\n        );\n        if (matchingLevels.length > 0) {\n          // Pick the highest resolution level for this quality\n          const bestLevel = sortLevelsByQuality(matchingLevels)[0];\n          const levelIndex = hls.levels.indexOf(bestLevel);\n          if (levelIndex !== -1) {\n            hls.currentLevel = levelIndex;\n            hls.loadLevel = levelIndex;\n          }\n        }\n      }\n    } else {\n      hls.currentLevel = -1;\n      hls.loadLevel = -1;\n    }\n    const quality = hlsLevelToQuality(hls.levels[hls.currentLevel]);\n    emit(\"changedquality\", quality);\n  }\n\n  function setupSource(vid: HTMLVideoElement, src: LoadableSource) {\n    hls = null;\n    if (src.type === \"hls\") {\n      if (canPlayHlsNatively(vid)) {\n        vid.src = processCdnLink(src.url);\n        vid.currentTime = startAt;\n        return;\n      }\n\n      if (!Hls.isSupported())\n        throw new Error(\"HLS not supported. Update your browser. \");\n      if (!hls) {\n        hls = new Hls({\n          autoStartLoad: true,\n          maxBufferLength: 120, // 120 seconds\n          maxMaxBufferLength: 240,\n          fragLoadPolicy: {\n            default: {\n              maxLoadTimeMs: 30 * 1000, // allow it load extra long, fragments are slow if requested for the first time on an origin\n              maxTimeToFirstByteMs: 30 * 1000,\n              errorRetry: {\n                maxNumRetry: 10,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 10000,\n              },\n              timeoutRetry: {\n                maxNumRetry: 10,\n                maxRetryDelayMs: 0,\n                retryDelayMs: 0,\n              },\n            },\n          },\n          renderTextTracksNatively: false,\n        });\n        const exceptions = [\n          \"Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.\",\n        ];\n        hls?.on(Hls.Events.ERROR, (event, data) => {\n          console.error(\"HLS error\", data);\n          if (\n            data.fatal &&\n            src?.url === data.frag?.baseurl &&\n            !exceptions.includes(data.error.message)\n          ) {\n            emit(\"error\", {\n              message: data.error.message,\n              stackTrace: data.error.stack,\n              errorName: data.error.name,\n              type: \"hls\",\n            });\n          } else if (data.details === \"manifestLoadError\") {\n            // Handle manifest load errors specifically\n            emit(\"error\", {\n              message: \"Failed to load HLS manifest\",\n              stackTrace: data.error?.stack || \"\",\n              errorName: data.error?.name || \"ManifestLoadError\",\n              type: \"hls\",\n            });\n          }\n        });\n        hls.on(Hls.Events.MANIFEST_LOADED, () => {\n          if (!hls) return;\n          reportLevels();\n          setupQualityForHls();\n          reportAudioTracks();\n\n          if (isExtensionActiveCached()) {\n            hls.on(Hls.Events.LEVEL_LOADED, async (_, data) => {\n              const chunkUrlsDomains = data.details.fragments.map(\n                (v) => new URL(v.url).hostname,\n              );\n              const chunkUrls = [...new Set(chunkUrlsDomains)];\n\n              await setDomainRule({\n                ruleId: RULE_IDS.SET_DOMAINS_HLS,\n                targetDomains: chunkUrls,\n                requestHeaders: {\n                  ...src.preferredHeaders,\n                  ...src.headers,\n                },\n              });\n            });\n            hls.on(Hls.Events.AUDIO_TRACK_LOADED, async (_, data) => {\n              const chunkUrlsDomains = data.details.fragments.map(\n                (v) => new URL(v.url).hostname,\n              );\n              const chunkUrls = [...new Set(chunkUrlsDomains)];\n\n              await setDomainRule({\n                ruleId: RULE_IDS.SET_DOMAINS_HLS_AUDIO,\n                targetDomains: chunkUrls,\n                requestHeaders: {\n                  ...src.preferredHeaders,\n                  ...src.headers,\n                },\n              });\n            });\n          }\n        });\n        hls.on(Hls.Events.LEVEL_SWITCHED, () => {\n          if (!hls) return;\n          const quality = hlsLevelToQuality(hls.levels[hls.currentLevel]);\n          emit(\"changedquality\", quality);\n        });\n        hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, () => {\n          for (const [lang, resolve] of languagePromises) {\n            const track = hls?.subtitleTracks.find((t) => t.lang === lang);\n            if (track) {\n              resolve();\n              languagePromises.delete(lang);\n              break;\n            }\n          }\n        });\n      }\n\n      hls.attachMedia(vid);\n      hls.loadSource(processCdnLink(src.url));\n      vid.currentTime = startAt;\n      return;\n    }\n\n    vid.src = processCdnLink(src.url);\n    vid.currentTime = startAt;\n  }\n\n  function setSource() {\n    if (!videoElement || !source) return;\n    setupSource(videoElement, source);\n\n    videoElement.addEventListener(\"play\", () => {\n      emit(\"play\", undefined);\n      emit(\"loading\", false);\n    });\n    videoElement.addEventListener(\"error\", () => {\n      const err = videoElement?.error ?? null;\n      const errorDetails = getMediaErrorDetails(err);\n      emit(\"error\", {\n        errorName: errorDetails.name,\n        key: errorDetails.key,\n        type: \"htmlvideo\",\n      });\n    });\n    videoElement.addEventListener(\"playing\", () => emit(\"play\", undefined));\n    videoElement.addEventListener(\"pause\", () => emit(\"pause\", undefined));\n    videoElement.addEventListener(\"canplay\", () => emit(\"loading\", false));\n    videoElement.addEventListener(\"waiting\", () => emit(\"loading\", true));\n    videoElement.addEventListener(\"volumechange\", () =>\n      emit(\n        \"volumechange\",\n        videoElement?.muted ? 0 : (videoElement?.volume ?? 0),\n      ),\n    );\n    videoElement.addEventListener(\"timeupdate\", () =>\n      emit(\"time\", videoElement?.currentTime ?? 0),\n    );\n    videoElement.addEventListener(\"loadedmetadata\", () => {\n      if (\n        source?.type === \"hls\" &&\n        videoElement &&\n        canPlayHlsNatively(videoElement)\n      ) {\n        emit(\"qualities\", [\"unknown\"]);\n        emit(\"changedquality\", \"unknown\");\n      }\n      emit(\"duration\", videoElement?.duration ?? 0);\n    });\n    videoElement.addEventListener(\"progress\", () => {\n      if (videoElement)\n        emit(\n          \"buffered\",\n          handleBuffered(videoElement.currentTime, videoElement.buffered),\n        );\n    });\n    videoElement.addEventListener(\"webkitendfullscreen\", () => {\n      isFullscreen = false;\n      emit(\"fullscreen\", isFullscreen);\n      if (!isFullscreen) emit(\"needstrack\", false);\n    });\n    videoElement.addEventListener(\n      \"webkitplaybacktargetavailabilitychanged\",\n      (e: any) => {\n        if (e.availability === \"available\") {\n          emit(\"canairplay\", true);\n        }\n      },\n    );\n    videoElement.addEventListener(\"ratechange\", () => {\n      if (videoElement) emit(\"playbackrate\", videoElement.playbackRate);\n    });\n\n    videoElement.addEventListener(\"durationchange\", () => {\n      emit(\"duration\", videoElement?.duration ?? 0);\n    });\n  }\n\n  function unloadSource() {\n    if (videoElement) {\n      videoElement.removeAttribute(\"src\");\n      videoElement.load();\n    }\n    if (hls) {\n      hls.destroy();\n      hls = null;\n    }\n  }\n\n  function destroyVideoElement() {\n    unloadSource();\n    if (videoElement) {\n      videoElement = null;\n    }\n  }\n\n  function fullscreenChange() {\n    isFullscreen =\n      !!document.fullscreenElement || // other browsers\n      !!(document as any).webkitFullscreenElement; // safari\n    emit(\"fullscreen\", isFullscreen);\n    if (!isFullscreen) emit(\"needstrack\", false);\n  }\n  fscreen.addEventListener(\"fullscreenchange\", fullscreenChange);\n\n  return {\n    on,\n    off,\n    getType() {\n      return \"web\";\n    },\n    destroy: () => {\n      destroyVideoElement();\n      fscreen.removeEventListener(\"fullscreenchange\", fullscreenChange);\n    },\n    load(ops) {\n      if (!ops.source) unloadSource();\n      automaticQuality = ops.automaticQuality;\n      preferenceQuality = ops.preferredQuality;\n      source = ops.source;\n      emit(\"loading\", true);\n      startAt = ops.startAt;\n      setSource();\n    },\n    changeQuality(newAutomaticQuality, newPreferredQuality) {\n      if (source?.type !== \"hls\") return;\n      automaticQuality = newAutomaticQuality;\n      preferenceQuality = newPreferredQuality;\n      setupQualityForHls();\n    },\n\n    processVideoElement(video) {\n      destroyVideoElement();\n      videoElement = video;\n      setSource();\n      this.setVolume(lastVolume);\n    },\n    processContainerElement(container) {\n      containerElement = container;\n    },\n    setMeta() {},\n    setCaption() {},\n\n    pause() {\n      videoElement?.pause();\n    },\n    play() {\n      videoElement?.play();\n    },\n    setSeeking(active) {\n      if (active === isSeeking) return;\n      isSeeking = active;\n\n      // if it was playing when starting to seek, play again\n      if (!active) {\n        if (!isPausedBeforeSeeking) this.play();\n        return;\n      }\n\n      isPausedBeforeSeeking = videoElement?.paused ?? true;\n      this.pause();\n    },\n    setTime(t) {\n      if (!videoElement) return;\n      // clamp time between 0 and max duration\n      let time = Math.min(t, videoElement.duration);\n      time = Math.max(0, time);\n\n      if (Number.isNaN(time)) return;\n      emit(\"time\", time);\n      videoElement.currentTime = time;\n    },\n    async setVolume(v) {\n      // clamp time between 0 and 1\n      let volume = Math.min(v, 1);\n      volume = Math.max(0, volume);\n\n      // actually set\n      lastVolume = v;\n      if (!videoElement) return;\n      videoElement.muted = volume === 0; // Muted attribute is always supported\n\n      // update state\n      const isChangeable = await canChangeVolume();\n      if (isChangeable) {\n        videoElement.volume = volume;\n      } else {\n        // For browsers where it can't be changed\n        emit(\"volumechange\", volume === 0 ? 0 : 1);\n      }\n    },\n    toggleFullscreen() {\n      if (isFullscreen) {\n        isFullscreen = false;\n        emit(\"fullscreen\", isFullscreen);\n        emit(\"needstrack\", false);\n        if (!fscreen.fullscreenElement) return;\n        fscreen.exitFullscreen();\n        return;\n      }\n\n      // enter fullscreen\n      isFullscreen = true;\n      emit(\"fullscreen\", isFullscreen);\n      if (!canFullscreen() || fscreen.fullscreenElement) return;\n      if (canFullscreenAnyElement()) {\n        if (containerElement) fscreen.requestFullscreen(containerElement);\n        return;\n      }\n      if (canWebkitFullscreen()) {\n        if (videoElement) {\n          emit(\"needstrack\", true);\n          (videoElement as any).webkitEnterFullscreen();\n        }\n      }\n    },\n    togglePictureInPicture() {\n      if (!videoElement) return;\n      if (canWebkitPictureInPicture()) {\n        const webkitPlayer = videoElement as any;\n        webkitPlayer.webkitSetPresentationMode(\n          webkitPlayer.webkitPresentationMode === \"picture-in-picture\"\n            ? \"inline\"\n            : \"picture-in-picture\",\n        );\n      }\n      if (canPictureInPicture()) {\n        if (videoElement !== document.pictureInPictureElement) {\n          videoElement.requestPictureInPicture();\n        } else {\n          document.exitPictureInPicture();\n        }\n      }\n    },\n    startAirplay() {\n      const videoPlayer = videoElement as any;\n      if (videoPlayer && videoPlayer.webkitShowPlaybackTargetPicker) {\n        videoPlayer.webkitShowPlaybackTargetPicker();\n      }\n    },\n    setPlaybackRate(rate) {\n      if (videoElement) videoElement.playbackRate = rate;\n    },\n    getCaptionList() {\n      return (\n        hls?.subtitleTracks.map((track) => {\n          return {\n            id: track.id.toString(),\n            language: track.lang ?? \"unknown\",\n            url: track.url,\n            needsProxy: false,\n            hls: true,\n          };\n        }) ?? []\n      );\n    },\n    getSubtitleTracks() {\n      return hls?.subtitleTracks ?? [];\n    },\n    async setSubtitlePreference(lang) {\n      // default subtitles are already loaded by hls.js\n      const track = hls?.subtitleTracks.find((t) => t.lang === lang);\n      if (track?.details !== undefined) return Promise.resolve();\n\n      // need to wait a moment before hls loads the subtitles\n      const promise = new Promise<void>((resolve, reject) => {\n        languagePromises.set(lang, resolve);\n\n        // reject after some time, if hls.js fails to load the subtitles\n        // for any reason\n        setTimeout(() => {\n          reject();\n          languagePromises.delete(lang);\n        }, 5000);\n      });\n      hls?.setSubtitleOption({ lang });\n      return promise;\n    },\n    changeAudioTrack(track) {\n      if (!hls) return;\n      const audioTrack = hls?.audioTracks.find(\n        (t) => t.id.toString() === track.id,\n      );\n      if (!audioTrack) return;\n      hls.audioTrack = hls.audioTracks.indexOf(audioTrack);\n      emit(\"changedaudiotrack\", {\n        id: audioTrack.id.toString(),\n        label: audioTrack.name,\n        language: audioTrack.lang ?? \"unknown\",\n      });\n    },\n  };\n}\n","import fscreen from \"fscreen\";\n\nimport { MWMediaType } from \"@/backend/metadata/types/mw\";\nimport {\n  DisplayCaption,\n  DisplayInterface,\n  DisplayInterfaceEvents,\n  DisplayMeta,\n} from \"@/components/player/display/displayInterface\";\nimport { LoadableSource } from \"@/stores/player/utils/qualities\";\nimport { processCdnLink } from \"@/utils/cdn\";\nimport {\n  canChangeVolume,\n  canFullscreen,\n  canFullscreenAnyElement,\n} from \"@/utils/detectFeatures\";\nimport { makeEmitter } from \"@/utils/events\";\n\nexport interface ChromeCastDisplayInterfaceOptions {\n  controller: cast.framework.RemotePlayerController;\n  player: cast.framework.RemotePlayer;\n  instance: cast.framework.CastContext;\n}\n\n/*\n ** Chromecasting is unfinished, here is its limitations:\n **  1. Captions - chromecast requires only VTT, but needs it from a URL. we only have SRT urls\n **  2. HLS - we've having some issues with content types. sometimes it loads, sometimes it doesn't\n */\n\nexport function makeChromecastDisplayInterface(\n  ops: ChromeCastDisplayInterfaceOptions,\n): DisplayInterface {\n  const { emit, on, off } = makeEmitter<DisplayInterfaceEvents>();\n  let isPaused = false;\n  let playbackRate = 1;\n  let source: LoadableSource | null = null;\n  let videoElement: HTMLVideoElement | null = null;\n  let containerElement: HTMLElement | null = null;\n  let isFullscreen = false;\n  let isPausedBeforeSeeking = false;\n  let isSeeking = false;\n  let startAt = 0;\n  let meta: DisplayMeta = {\n    title: \"\",\n    type: MWMediaType.MOVIE,\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let caption: DisplayCaption | null = null;\n\n  function listenForEvents() {\n    const listen = async (e: cast.framework.RemotePlayerChangedEvent) => {\n      switch (e.field) {\n        case \"volumeLevel\":\n          if (await canChangeVolume()) emit(\"volumechange\", e.value);\n          break;\n        case \"currentTime\":\n          emit(\"time\", e.value);\n          break;\n        case \"duration\":\n          emit(\"duration\", e.value ?? 0);\n          break;\n        case \"mediaInfo\":\n          if (e.value) emit(\"duration\", e.value.duration ?? 0);\n          break;\n        case \"playerState\":\n          emit(\"loading\", e.value === \"BUFFERING\");\n          if (e.value === \"PLAYING\") emit(\"play\", undefined);\n          else if (e.value === \"PAUSED\") emit(\"pause\", undefined);\n          isPaused = e.value === \"PAUSED\";\n          break;\n        case \"isMuted\":\n          emit(\"volumechange\", e.value ? 1 : 0);\n          break;\n        case \"displayStatus\":\n        case \"canSeek\":\n        case \"title\":\n        case \"isPaused\":\n        case \"canPause\":\n        case \"isMediaLoaded\":\n        case \"statusText\":\n        case \"isConnected\":\n        case \"displayName\":\n        case \"canControlVolume\":\n        case \"savedPlayerState\":\n          break;\n        default:\n          break;\n      }\n    };\n    ops.controller?.addEventListener(\n      cast.framework.RemotePlayerEventType.ANY_CHANGE,\n      listen,\n    );\n    return () => {\n      ops.controller?.removeEventListener(\n        cast.framework.RemotePlayerEventType.ANY_CHANGE,\n        listen,\n      );\n    };\n  }\n\n  function setupSource() {\n    if (!source) {\n      ops.controller?.stop();\n      return;\n    }\n\n    let type = \"video/mp4\";\n    if (source.type === \"hls\") type = \"application/x-mpegurl\";\n\n    const metaData = new chrome.cast.media.GenericMediaMetadata();\n    metaData.title = meta.title;\n\n    const mediaInfo = new chrome.cast.media.MediaInfo(\"video\", type);\n    (mediaInfo as any).contentUrl = processCdnLink(source.url);\n    mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;\n    mediaInfo.metadata = metaData;\n    mediaInfo.customData = {\n      playbackRate,\n    };\n\n    const request = new chrome.cast.media.LoadRequest(mediaInfo);\n    request.autoplay = true;\n    request.currentTime = startAt;\n\n    if (source.type === \"hls\") {\n      const staticMedia = chrome.cast.media as any;\n      const media = request.media as any;\n      media.hlsSegmentFormat = staticMedia.HlsSegmentFormat.FMP4;\n      media.hlsVideoSegmentFormat = staticMedia.HlsVideoSegmentFormat.FMP4;\n    }\n\n    const session = ops.instance.getCurrentSession();\n    session?.loadMedia(request);\n  }\n\n  function setSource() {\n    if (!videoElement || !source) return;\n    setupSource();\n  }\n\n  function destroyVideoElement() {\n    if (videoElement) videoElement = null;\n  }\n\n  function fullscreenChange() {\n    isFullscreen =\n      !!document.fullscreenElement || // other browsers\n      !!(document as any).webkitFullscreenElement; // safari\n    emit(\"fullscreen\", isFullscreen);\n    if (!isFullscreen) emit(\"needstrack\", false);\n  }\n  fscreen.addEventListener(\"fullscreenchange\", fullscreenChange);\n\n  // start listening immediately\n  const stopListening = listenForEvents();\n\n  return {\n    on,\n    off,\n    getType() {\n      return \"casting\";\n    },\n    destroy: () => {\n      stopListening();\n      destroyVideoElement();\n      fscreen.removeEventListener(\"fullscreenchange\", fullscreenChange);\n    },\n    load(loadOps) {\n      source = loadOps.source;\n      emit(\"loading\", true);\n      startAt = loadOps.startAt;\n      setSource();\n    },\n    changeQuality() {\n      // cant control qualities\n    },\n    setCaption(newCaption) {\n      caption = newCaption;\n      setSource();\n    },\n\n    processVideoElement(video) {\n      destroyVideoElement();\n      videoElement = video;\n      setSource();\n    },\n    processContainerElement(container) {\n      containerElement = container;\n    },\n    setMeta(data) {\n      meta = data;\n      setSource();\n    },\n\n    pause() {\n      if (!isPaused) {\n        ops.controller.playOrPause();\n        isPaused = true;\n      }\n    },\n    play() {\n      if (isPaused) {\n        ops.controller.playOrPause();\n        isPaused = false;\n      }\n    },\n    setSeeking(active) {\n      if (active === isSeeking) return;\n      isSeeking = active;\n\n      // if it was playing when starting to seek, play again\n      if (!active) {\n        if (!isPausedBeforeSeeking) this.play();\n        return;\n      }\n\n      isPausedBeforeSeeking = isPaused ?? true;\n      this.pause();\n    },\n    setTime(t) {\n      if (!videoElement) return;\n      // clamp time between 0 and max duration\n      let time = Math.min(t, ops.player.duration);\n      time = Math.max(0, time);\n\n      if (Number.isNaN(time)) return;\n      emit(\"time\", time);\n      ops.player.currentTime = time;\n      ops.controller.seek();\n    },\n    async setVolume(v) {\n      // clamp time between 0 and 1\n      let volume = Math.min(v, 1);\n      volume = Math.max(0, volume);\n\n      // update state\n      const isChangeable = await canChangeVolume();\n      if (isChangeable) {\n        ops.player.volumeLevel = volume;\n        ops.controller.setVolumeLevel();\n        emit(\"volumechange\", volume);\n      } else {\n        // For browsers where it can't be changed\n        emit(\"volumechange\", volume === 0 ? 0 : 1);\n      }\n    },\n    toggleFullscreen() {\n      if (isFullscreen) {\n        isFullscreen = false;\n        emit(\"fullscreen\", isFullscreen);\n        emit(\"needstrack\", false);\n        if (!fscreen.fullscreenElement) return;\n        fscreen.exitFullscreen();\n        return;\n      }\n\n      // enter fullscreen\n      isFullscreen = true;\n      emit(\"fullscreen\", isFullscreen);\n      if (!canFullscreen() || fscreen.fullscreenElement) return;\n      if (canFullscreenAnyElement()) {\n        if (containerElement) fscreen.requestFullscreen(containerElement);\n      }\n    },\n    togglePictureInPicture() {\n      // Can't PIP while Chromecasting\n    },\n    startAirplay() {\n      // cant airplay while chromecasting\n    },\n    setPlaybackRate(rate) {\n      playbackRate = rate;\n      setSource();\n    },\n    getCaptionList() {\n      return [];\n    },\n    getSubtitleTracks() {\n      return [];\n    },\n    async setSubtitlePreference() {\n      return Promise.resolve();\n    },\n    changeAudioTrack() {\n      // cant change audio tracks\n    },\n  };\n}\n","const CHROMECAST_SENDER_SDK =\n  \"https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1\";\n\nconst callbacks: ((available: boolean) => void)[] = [];\nlet _available: boolean | null = null;\n\nfunction init(available: boolean) {\n  _available = available;\n  callbacks.forEach((cb) => cb(available));\n}\n\nexport function isChromecastAvailable(cb: (available: boolean) => void) {\n  if (_available !== null) return cb(_available);\n  callbacks.push(cb);\n}\n\nexport function initializeChromecast() {\n  window.__onGCastApiAvailable = (isAvailable) => {\n    init(isAvailable);\n  };\n\n  // add script if doesnt exist yet\n  const exists = !!document.getElementById(\"chromecast-script\");\n  if (!exists) {\n    const script = document.createElement(\"script\");\n    script.setAttribute(\"src\", CHROMECAST_SENDER_SDK);\n    script.setAttribute(\"id\", \"chromecast-script\");\n    document.body.appendChild(script);\n  }\n}\n","/// <reference types=\"chromecast-caf-sender\"/>\n\nimport { useEffect, useState } from \"react\";\n\nimport { isChromecastAvailable } from \"@/setup/chromecast\";\n\nexport function useChromecastAvailable() {\n  const [available, setAvailable] = useState<boolean | null>(null);\n\n  useEffect(() => {\n    isChromecastAvailable((bool) => setAvailable(bool));\n  }, []);\n\n  return available;\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { usePlayerStore } from \"@/stores/player/store\";\n\ninterface PlayerStatusData {\n  isPlaying: boolean;\n  isPaused: boolean;\n  isLoading: boolean;\n  hasPlayedOnce: boolean;\n  volume: number;\n  playbackRate: number;\n  time: number;\n  duration: number;\n  buffered: number;\n  timestamp: number; // When this data point was captured\n}\n\ninterface PlayerStatusPollingResult {\n  /** Array of player status data points collected when state changes */\n  statusHistory: PlayerStatusData[];\n  /** The most recent player status data point */\n  latestStatus: PlayerStatusData | null;\n  /** Clear the status history */\n  clearHistory: () => void;\n  /** Force an immediate update of the status */\n  forceUpdate: () => void;\n}\n\n/**\n * Hook that polls player status and progress, but only records changes\n * when there are meaningful differences in the player state\n *\n * @param maxHistory Maximum number of history entries to keep (default: 10)\n */\nexport function usePlayerStatusPolling(\n  maxHistory: number = 10,\n): PlayerStatusPollingResult {\n  const [statusHistory, setStatusHistory] = useState<PlayerStatusData[]>([]);\n  const previousStateRef = useRef<PlayerStatusData | null>(null);\n  const lastUpdateTimeRef = useRef<number>(0);\n\n  // Get the current playing state and progress\n  const mediaPlaying = usePlayerStore((s) => s.mediaPlaying);\n  const progress = usePlayerStore((s) => s.progress);\n\n  // Create a function to update the history\n  const updateHistory = useCallback(() => {\n    const now = Date.now();\n    const currentStatus: PlayerStatusData = {\n      isPlaying: mediaPlaying.isPlaying,\n      isPaused: mediaPlaying.isPaused,\n      isLoading: mediaPlaying.isLoading,\n      hasPlayedOnce: mediaPlaying.hasPlayedOnce,\n      volume: mediaPlaying.volume,\n      playbackRate: mediaPlaying.playbackRate,\n      time: progress.time,\n      duration: progress.duration,\n      buffered: progress.buffered,\n      timestamp: now,\n    };\n\n    // Check if this is the first record\n    const isFirstRecord = previousStateRef.current === null;\n    if (isFirstRecord) {\n      setStatusHistory([currentStatus]);\n      previousStateRef.current = currentStatus;\n      lastUpdateTimeRef.current = now;\n      return currentStatus;\n    }\n\n    // At this point we've confirmed previousStateRef.current is not null\n    const prevState = previousStateRef.current!; // Non-null assertion\n    const timeSinceLastUpdate = now - lastUpdateTimeRef.current;\n\n    // Determine if we should record this update\n    const hasPlaybackStateChanged =\n      prevState.isPlaying !== currentStatus.isPlaying ||\n      prevState.isPaused !== currentStatus.isPaused ||\n      prevState.isLoading !== currentStatus.isLoading;\n\n    const hasPlaybackRateChanged =\n      prevState.playbackRate !== currentStatus.playbackRate;\n\n    const hasTimeChangedDuringPlayback =\n      currentStatus.isPlaying &&\n      timeSinceLastUpdate >= 4000 &&\n      Math.abs(prevState.time - currentStatus.time) > 1;\n\n    const hasDurationChanged =\n      Math.abs(prevState.duration - currentStatus.duration) > 1;\n\n    const periodicUpdateDuringPlayback =\n      currentStatus.isPlaying && timeSinceLastUpdate >= 10000;\n\n    // Update if any significant changes detected\n    const shouldUpdate =\n      hasPlaybackStateChanged ||\n      hasPlaybackRateChanged ||\n      hasTimeChangedDuringPlayback ||\n      hasDurationChanged ||\n      periodicUpdateDuringPlayback;\n\n    if (shouldUpdate) {\n      setStatusHistory((prev) => {\n        const newHistory = [...prev, currentStatus];\n        return newHistory.length > maxHistory\n          ? newHistory.slice(newHistory.length - maxHistory)\n          : newHistory;\n      });\n\n      previousStateRef.current = currentStatus;\n      lastUpdateTimeRef.current = now;\n    }\n\n    return currentStatus;\n  }, [mediaPlaying, progress, maxHistory]);\n\n  const clearHistory = useCallback(() => {\n    setStatusHistory([]);\n    previousStateRef.current = null;\n    lastUpdateTimeRef.current = 0;\n  }, []);\n\n  useEffect(() => {\n    // Initial update\n    updateHistory();\n\n    // Set up polling interval at 2 seconds\n    const interval = setInterval(() => {\n      if (mediaPlaying.hasPlayedOnce) {\n        updateHistory();\n      }\n    }, 2000);\n\n    // Clean up on unmount\n    return () => clearInterval(interval);\n  }, [updateHistory, mediaPlaying.hasPlayedOnce]);\n\n  return {\n    statusHistory,\n    latestStatus:\n      statusHistory.length > 0 ? statusHistory[statusHistory.length - 1] : null,\n    clearHistory,\n    forceUpdate: updateHistory,\n  };\n}\n","import { MWMediaType } from \"./types/mw\";\n\nexport interface TraktLatestResponse {\n  tmdb_ids: number[];\n  count: number;\n}\n\nexport interface TraktReleaseResponse {\n  tmdb_id: number;\n  title: string;\n  year?: number;\n  type: \"movie\" | \"episode\";\n  season?: number;\n  episode?: number;\n  quality?: string;\n  source?: string;\n  group?: string;\n  theatrical_release_date?: string;\n  digital_release_date?: string;\n}\n\nexport interface PaginatedTraktResponse {\n  tmdb_ids: number[];\n  hasMore: boolean;\n  totalCount: number;\n}\n\nexport type TraktContentType = \"movie\" | \"episode\";\n\nexport const TRAKT_BASE_URL = \"https://fed-airdate.pstream.org\";\n\nexport interface TraktDiscoverResponse {\n  movie_tmdb_ids: number[];\n  tv_tmdb_ids: number[];\n  count: number;\n}\n\nexport interface TraktNetworkResponse {\n  type: string;\n  platforms: string[];\n  count: number;\n}\n\n// Pagination utility\nexport function paginateResults(\n  results: TraktLatestResponse,\n  page: number,\n  pageSize: number = 20,\n): PaginatedTraktResponse {\n  const startIndex = (page - 1) * pageSize;\n  const endIndex = startIndex + pageSize;\n  const paginatedIds = results.tmdb_ids.slice(startIndex, endIndex);\n\n  return {\n    tmdb_ids: paginatedIds,\n    hasMore: endIndex < results.tmdb_ids.length,\n    totalCount: results.tmdb_ids.length,\n  };\n}\n\n// Base function to fetch from Trakt API\nasync function fetchFromTrakt<T = TraktLatestResponse>(\n  endpoint: string,\n): Promise<T> {\n  const response = await fetch(`${TRAKT_BASE_URL}${endpoint}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch from ${endpoint}: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n// Release details\nexport async function getReleaseDetails(\n  id: string,\n  season?: number,\n  episode?: number,\n): Promise<TraktReleaseResponse> {\n  let url = `/release/${id}`;\n  if (season !== undefined && episode !== undefined) {\n    url += `/${season}/${episode}`;\n  }\n  const response = await fetch(`${TRAKT_BASE_URL}${url}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch release details: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n// Latest releases\nexport const getLatestReleases = () => fetchFromTrakt(\"/latest\");\nexport const getLatest4KReleases = () => fetchFromTrakt(\"/latest4k\");\nexport const getLatestTVReleases = () => fetchFromTrakt(\"/latesttv\");\n\n// Streaming service releases\nexport const getAppleTVReleases = () => fetchFromTrakt(\"/appletv\");\nexport const getNetflixMovies = () => fetchFromTrakt(\"/netflixmovies\");\nexport const getNetflixTVShows = () => fetchFromTrakt(\"/netflixtv\");\nexport const getPrimeReleases = () => fetchFromTrakt(\"/prime\");\nexport const getHuluReleases = () => fetchFromTrakt(\"/hulu\");\nexport const getDisneyReleases = () => fetchFromTrakt(\"/disney\");\nexport const getHBOReleases = () => fetchFromTrakt(\"/hbo\");\n\n// Genre-specific releases\nexport const getActionReleases = () => fetchFromTrakt(\"/action\");\nexport const getDramaReleases = () => fetchFromTrakt(\"/drama\");\n\n// Popular content\nexport const getPopularTVShows = () => fetchFromTrakt(\"/populartv\");\nexport const getPopularMovies = () => fetchFromTrakt(\"/popularmovies\");\n\n// Discovery content\nexport const getDiscoverContent = () =>\n  fetchFromTrakt<TraktDiscoverResponse>(\"/discover\");\n\n// Network content\nexport const getNetworkContent = (tmdbId: string) =>\n  fetchFromTrakt<TraktNetworkResponse>(`/network/${tmdbId}`);\n\n// Type conversion utilities\nexport function convertToMediaType(type: TraktContentType): MWMediaType {\n  return type === \"movie\" ? MWMediaType.MOVIE : MWMediaType.SERIES;\n}\n\nexport function convertFromMediaType(type: MWMediaType): TraktContentType {\n  return type === MWMediaType.MOVIE ? \"movie\" : \"episode\";\n}\n\n// Map provider names to their Trakt endpoints\nexport const PROVIDER_TO_TRAKT_MAP = {\n  \"8\": \"netflix\", // Netflix\n  \"2\": \"appletv\", // Apple TV+\n  \"10\": \"prime\", // Prime Video\n  \"15\": \"hulu\", // Hulu\n  \"337\": \"disney\", // Disney+\n  \"1899\": \"hbo\", // Max\n} as const;\n\n// Map genres to their Trakt endpoints\nexport const GENRE_TO_TRAKT_MAP = {\n  \"28\": \"action\", // Action\n  \"18\": \"drama\", // Drama\n} as const;\n\n// Map provider names to their image filenames\nexport const PROVIDER_TO_IMAGE_MAP: Record<string, string> = {\n  Max: \"max\",\n  \"Prime Video\": \"prime\",\n  Netflix: \"netflix\",\n  \"Disney+\": \"disney\",\n  Hulu: \"hulu\",\n  \"Apple TV+\": \"appletv\",\n  \"Paramount+\": \"paramount\",\n};\n","import {\n  ProgressEpisodeItem,\n  ProgressItem,\n  ProgressMediaItem,\n  ProgressSeasonItem,\n} from \"@/stores/progress\";\n\nexport interface ShowProgressResult {\n  episode?: ProgressEpisodeItem;\n  season?: ProgressSeasonItem;\n  progress: ProgressItem;\n  show: boolean;\n}\n\nconst defaultProgress = {\n  duration: 0,\n  watched: 0,\n};\n\nfunction progressIsCompleted(duration: number, watched: number): boolean {\n  const timeFromEnd = duration - watched;\n\n  // too close to the end, is completed\n  if (timeFromEnd < 60 * 2) return true;\n\n  // satisfies all constraints, not completed\n  return false;\n}\n\nfunction progressIsNotStarted(duration: number, watched: number): boolean {\n  // too short watch time\n  if (watched < 20) return true;\n\n  // satisfies all constraints, not completed\n  return false;\n}\n\nfunction progressIsAcceptableRange(duration: number, watched: number): boolean {\n  // not started enough yet, not acceptable\n  if (progressIsNotStarted(duration, watched)) return false;\n\n  // is already at the end, not acceptable\n  if (progressIsCompleted(duration, watched)) return false;\n\n  // satisfied all constraints\n  return true;\n}\n\nfunction isFirstEpisodeOfShow(\n  item: ProgressMediaItem,\n  episode: ProgressEpisodeItem,\n): boolean {\n  const seasonId = episode.seasonId;\n  const season = item.seasons[seasonId];\n  return season.number === 1 && episode.number === 1;\n}\n\nexport function shouldShowProgress(\n  item: ProgressMediaItem,\n): ShowProgressResult {\n  // non shows just hide or show depending on acceptable ranges\n  if (item.type !== \"show\") {\n    return {\n      show: progressIsAcceptableRange(\n        item.progress?.duration ?? 0,\n        item.progress?.watched ?? 0,\n      ),\n      progress: item.progress ?? defaultProgress,\n    };\n  }\n\n  // shows only hide an item if its too early in episode, it still shows if its near the end.\n  // Otherwise you would lose episode progress\n  const ep = Object.values(item.episodes)\n    .sort((a, b) => b.updatedAt - a.updatedAt)\n    .filter(\n      (epi) =>\n        !progressIsNotStarted(epi.progress.duration, epi.progress.watched) ||\n        !isFirstEpisodeOfShow(item, epi),\n    )[0];\n\n  const season = item.seasons[ep?.seasonId];\n  if (!ep || !season)\n    return {\n      show: false,\n      progress: defaultProgress,\n    };\n  return {\n    season,\n    episode: ep,\n    show: true,\n    progress: ep.progress,\n  };\n}\n","/* eslint-disable no-console */\nimport { isExtensionActive } from \"@/backend/extension/messaging\";\nimport { proxiedFetch } from \"@/backend/helpers/fetch\";\nimport { makeExtensionFetcher } from \"@/backend/providers/fetchers\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { useLanguageStore } from \"@/stores/language\";\n\nimport { getTmdbLanguageCode } from \"./language\";\n\n// IMDb language code mapping (differs from TMDB format)\n// Map from ISO language code to IMDb language parameter\nconst imdbLanguageMap: Record<string, string> = {\n  \"en-US\": \"en-US\",\n  \"es-ES\": \"es-ES\",\n  \"fr-FR\": \"fr-FR\",\n  \"de-DE\": \"de-DE\",\n  \"it-IT\": \"it-IT\",\n  \"pt-PT\": \"pt-PT\",\n  \"ru-RU\": \"ru-RU\",\n  \"ja-JP\": \"ja-JP\",\n  \"zh-CN\": \"zh-CN\",\n  \"ko-KR\": \"ko-KR\",\n  \"ar-SA\": \"ar-SA\",\n  \"hi-IN\": \"hi-IN\",\n  \"el-GR\": \"el-GR\",\n  // Add more mappings as needed\n};\n\n/**\n * Convert a TMDB-style language code to an IMDb language code\n * @param language TMDB-style language code (e.g., \"en-US\")\n * @returns IMDb language code or default \"en-US\"\n */\nfunction getImdbLanguageCode(language: string): string {\n  // If we have a direct mapping, use it\n  if (imdbLanguageMap[language]) return imdbLanguageMap[language];\n\n  // Otherwise default to English\n  return \"en-US\";\n}\n\ninterface IMDbMetadata {\n  title: string;\n  original_title: string;\n  title_type: string;\n  year: number | null;\n  end_year: number | null;\n  day: number | null;\n  month: number | null;\n  date: string;\n  runtime: number | null;\n  age_rating: string;\n  imdb_rating: number | null;\n  votes: number | null;\n  plot: string;\n  poster_url: string;\n  trailer_url: string;\n  url: string;\n  genre: string[];\n  cast: string[];\n  directors: string[];\n  writers: string[];\n  keywords: string[];\n  countries: string[];\n  languages: string[];\n  locations: string[];\n  season?: number;\n  episode?: number;\n  episode_title?: string;\n  episode_plot?: string;\n  episode_rating?: number;\n  episode_votes?: number;\n}\n\nconst months = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nconst userAgents = [\n  \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n  \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\",\n  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15\",\n];\n\nfunction getRandomUserAgent(): string {\n  return userAgents[Math.floor(Math.random() * userAgents.length)];\n}\n\nfunction formatRuntime(seconds: number | null): string {\n  if (!seconds) return \"\";\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  return `${hours}h ${remainingMinutes}m`;\n}\n\nfunction arrayToString(list: string[]): string {\n  return list.join(\", \");\n}\n\nexport async function scrapeIMDb(\n  imdbId: string,\n  season?: number,\n  episode?: number,\n  language?: string,\n): Promise<IMDbMetadata> {\n  // Check if we have a proxy or extension\n  const hasExtension = await isExtensionActive();\n  const hasProxy = Boolean(useAuthStore.getState().proxySet);\n\n  if (!hasExtension && !hasProxy) {\n    throw new Error(\n      \"IMDb scraping requires either the browser extension or a custom proxy to be set up. \" +\n        \"Please install the extension or set up a proxy in the settings.\",\n    );\n  }\n\n  console.log(\n    `[IMDb Scraper] Using ${hasExtension ? \"browser extension\" : \"custom proxy\"} for requests`,\n  );\n\n  // Get user language if not provided\n  if (!language) {\n    const userLanguage = useLanguageStore.getState().language;\n    language = getTmdbLanguageCode(userLanguage);\n  }\n\n  // Get IMDb language format\n  const imdbLanguage = getImdbLanguageCode(language);\n\n  // Construct IMDb URL with language parameter\n  let imdbUrl = `https://www.imdb.com/title/${imdbId}/`;\n  if (season && episode) {\n    imdbUrl += `episodes?season=${season}`;\n  }\n\n  // Add language parameter to URL\n  const separator = imdbUrl.includes(\"?\") ? \"&\" : \"?\";\n  imdbUrl += `${separator}locale=${imdbLanguage}`;\n\n  // Add random delay to avoid rate limiting\n  const delay = Math.floor(Math.random() * (197 - 69) + 69);\n  await new Promise<void>((resolve) => {\n    setTimeout(resolve, delay);\n  });\n\n  // Fetch IMDb page using appropriate fetcher\n  let response: string;\n  if (hasExtension) {\n    const extensionFetcher = makeExtensionFetcher();\n    const result = await extensionFetcher(imdbUrl, {\n      headers: {\n        \"User-Agent\": getRandomUserAgent(),\n        \"Accept-Language\": imdbLanguage,\n      },\n      method: \"GET\",\n      query: {},\n      readHeaders: [],\n    });\n    response = result.body as string;\n  } else {\n    response = await proxiedFetch<string>(imdbUrl, {\n      headers: {\n        \"User-Agent\": getRandomUserAgent(),\n        \"Accept-Language\": imdbLanguage,\n      },\n    });\n  }\n\n  // Extract JSON data from the page\n  const jsonMatch = response.match(\n    /<script id=\"__NEXT_DATA__\" type=\"application\\/json\">(.*?)<\\/script>/,\n  );\n  if (!jsonMatch) {\n    throw new Error(\"Could not find IMDb data on the page\");\n  }\n\n  const data = JSON.parse(jsonMatch[1]);\n  const metadata: IMDbMetadata = {\n    title: \"\",\n    original_title: \"\",\n    title_type: \"\",\n    year: null,\n    end_year: null,\n    day: null,\n    month: null,\n    date: \"\",\n    runtime: null,\n    age_rating: \"\",\n    imdb_rating: null,\n    votes: null,\n    plot: \"\",\n    poster_url: \"\",\n    trailer_url: \"\",\n    url: imdbUrl,\n    genre: [],\n    cast: [],\n    directors: [],\n    writers: [],\n    keywords: [],\n    countries: [],\n    languages: [],\n    locations: [],\n    season,\n    episode,\n  };\n\n  try {\n    // Extract all the metadata\n    const aboveTheFold = data.props.pageProps.aboveTheFoldData;\n    const mainColumn = data.props.pageProps.mainColumnData;\n\n    metadata.title = aboveTheFold.titleText?.text || \"\";\n    metadata.original_title = aboveTheFold.originalTitleText?.text || \"\";\n    metadata.title_type = aboveTheFold.titleType?.text || \"\";\n    metadata.age_rating = aboveTheFold.certificate?.rating || \"\";\n    metadata.year = aboveTheFold.releaseYear?.year || null;\n    metadata.end_year = aboveTheFold.releaseYear?.endYear || null;\n    metadata.day = aboveTheFold.releaseDate?.day || null;\n    metadata.month = aboveTheFold.releaseDate?.month || null;\n\n    if (metadata.month && metadata.day && metadata.year) {\n      metadata.date = `${months[metadata.month - 1]} ${metadata.day}, ${metadata.year}`;\n    }\n\n    metadata.runtime = aboveTheFold.runtime?.seconds || null;\n    metadata.plot = aboveTheFold.plot?.plotText?.plainText || \"\";\n    metadata.imdb_rating = aboveTheFold.ratingsSummary?.aggregateRating || null;\n    metadata.votes = aboveTheFold.ratingsSummary?.voteCount || null;\n    metadata.poster_url = aboveTheFold.primaryImage?.url || \"\";\n    metadata.trailer_url =\n      aboveTheFold.primaryVideos?.edges?.[0]?.node?.playbackURLs?.[0]?.url ||\n      \"\";\n\n    // Extract arrays\n    metadata.genre = aboveTheFold.genres?.genres?.map((g: any) => g.text) || [];\n    metadata.cast =\n      aboveTheFold.castPageTitle?.edges?.map(\n        (e: any) => e.node.name.nameText.text,\n      ) || [];\n    metadata.directors =\n      aboveTheFold.directorsPageTitle?.[0]?.credits?.map(\n        (c: any) => c.name.nameText.text,\n      ) || [];\n    metadata.writers =\n      mainColumn.writers?.[0]?.credits?.map((c: any) => c.name.nameText.text) ||\n      [];\n    metadata.keywords =\n      aboveTheFold.keywords?.edges?.map((e: any) => e.node.text) || [];\n    metadata.countries =\n      mainColumn.countriesOfOrigin?.countries?.map((c: any) => c.text) || [];\n    metadata.languages =\n      mainColumn.spokenLanguages?.spokenLanguages?.map((l: any) => l.text) ||\n      [];\n    metadata.locations =\n      mainColumn.filmingLocations?.edges?.map((e: any) => e.node.text) || [];\n\n    // If season and episode are provided, get episode-specific data\n    if (season && episode) {\n      const episodeData =\n        data.props.pageProps.mainColumnData.episodes?.edges?.find(\n          (e: any) => e.node.episodeNumber === episode,\n        );\n\n      if (episodeData) {\n        metadata.episode_title = episodeData.node.titleText?.text || \"\";\n        metadata.episode_plot =\n          episodeData.node.plot?.plotText?.plainText || \"\";\n        metadata.episode_rating =\n          episodeData.node.ratingsSummary?.aggregateRating || null;\n        metadata.episode_votes =\n          episodeData.node.ratingsSummary?.voteCount || null;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing IMDb data:\", error);\n    throw error;\n  }\n\n  return metadata;\n}\n\n// Helper function to print metadata (useful for debugging)\nexport function printIMDbMetadata(metadata: IMDbMetadata): void {\n  console.log(\"\\nTitle:\", metadata.title);\n  if (metadata.title !== metadata.original_title) {\n    console.log(\"Original Title:\", metadata.original_title);\n  }\n  console.log(\"Type:\", metadata.title_type);\n  console.log(\"Year:\", metadata.year);\n  console.log(\"Runtime:\", formatRuntime(metadata.runtime));\n  console.log(\"Date:\", metadata.date);\n  console.log(\"Age Rating:\", metadata.age_rating);\n  console.log(\"Genre:\", arrayToString(metadata.genre));\n  console.log(\"Cast:\", arrayToString(metadata.cast));\n  console.log(\"Directed by:\", arrayToString(metadata.directors));\n  console.log(\"Writers:\", arrayToString(metadata.writers));\n  console.log(\"Countries:\", arrayToString(metadata.countries));\n  console.log(\"Filming Locations:\", arrayToString(metadata.locations));\n  console.log(\"Languages:\", arrayToString(metadata.languages));\n  console.log(\"Keywords:\", arrayToString(metadata.keywords));\n\n  if (metadata.season && metadata.episode) {\n    console.log(\"\\nEpisode Details:\");\n    console.log(\"Season:\", metadata.season);\n    console.log(\"Episode:\", metadata.episode);\n    console.log(\"Title:\", metadata.episode_title);\n    console.log(\"Plot:\", metadata.episode_plot);\n    console.log(\"Rating:\", metadata.episode_rating);\n    console.log(\"Votes:\", metadata.episode_votes);\n  }\n  console.log(\"\\n\");\n}\n","import { isExtensionActive } from \"@/backend/extension/messaging\";\nimport { proxiedFetch } from \"@/backend/helpers/fetch\";\nimport { makeExtensionFetcher } from \"@/backend/providers/fetchers\";\nimport { useAuthStore } from \"@/stores/auth\";\n\ninterface RTMovie {\n  title: string;\n  tomatoIcon: \"certified_fresh\" | \"fresh\" | \"rotten\";\n  tomatoScore: number;\n  url: string;\n}\n\nfunction normalizeTitle(title: string): string {\n  return title\n    .toLowerCase()\n    .replace(/[^a-z0-9]/g, \"\")\n    .trim();\n}\n\nfunction calculateSimilarity(str1: string, str2: string): number {\n  const s1 = normalizeTitle(str1);\n  const s2 = normalizeTitle(str2);\n\n  // Check if one string contains the other\n  if (s1.includes(s2) || s2.includes(s1)) {\n    return 0.9;\n  }\n\n  // Calculate word overlap\n  const words1 = new Set(s1.split(/[^a-z0-9]+/));\n  const words2 = new Set(s2.split(/[^a-z0-9]+/));\n  const intersection = new Set([...words1].filter((x) => words2.has(x)));\n  const union = new Set([...words1, ...words2]);\n\n  if (union.size === 0) return 0;\n  return intersection.size / union.size;\n}\n\nfunction findBestMatch(searchTitle: string, movies: any[], year?: number): any {\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const movie of movies) {\n    const similarity = calculateSimilarity(searchTitle, movie.name);\n\n    // Boost score if year matches\n    const yearBoost = year && movie.year === year ? 0.2 : 0;\n    const score = similarity + yearBoost;\n\n    // Consider it a match if:\n    // 1. Score is better than previous best\n    // 2. Score is above threshold (0.5 for general matches, 0.3 if year matches)\n    if (score > bestScore && (score >= 0.5 || (yearBoost && score >= 0.3))) {\n      bestMatch = movie;\n      bestScore = score;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport async function scrapeRottenTomatoes(\n  title: string,\n  year?: number,\n): Promise<RTMovie | null> {\n  // Check if we have a proxy or extension\n  const hasExtension = await isExtensionActive();\n  const hasProxy = Boolean(useAuthStore.getState().proxySet);\n\n  if (!hasExtension && !hasProxy) {\n    throw new Error(\n      \"Rotten Tomatoes scraping requires either the browser extension or a custom proxy to be set up. \" +\n        \"Please install the extension or set up a proxy in the settings.\",\n    );\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `[RT Scraper] Using ${hasExtension ? \"browser extension\" : \"custom proxy\"} for requests`,\n  );\n\n  // Construct search URL with cleaned title\n  const searchQuery = encodeURIComponent(title.trim());\n  const searchUrl = `https://www.rottentomatoes.com/search?search=${searchQuery}`;\n\n  // Add random delay to avoid rate limiting\n  const delay = Math.floor(Math.random() * (197 - 69) + 69);\n  await new Promise<void>((resolve) => {\n    setTimeout(resolve, delay);\n  });\n\n  // Fetch search results using appropriate fetcher\n  let response: string;\n  if (hasExtension) {\n    const extensionFetcher = makeExtensionFetcher();\n    const result = await extensionFetcher(searchUrl, {\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n      },\n      method: \"GET\",\n      query: {},\n      readHeaders: [],\n    });\n    response = result.body as string;\n  } else {\n    response = await proxiedFetch<string>(searchUrl, {\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n      },\n    });\n  }\n\n  try {\n    // Extract movie data from the new HTML structure\n    const searchResultsDiv = response.match(\n      /<div id=\"search-results\"[^>]*>(.*?)<\\/div>/s,\n    );\n    if (!searchResultsDiv) {\n      console.error(\"Could not find search results in RT response\");\n      return null;\n    }\n\n    // Extract movie rows from search results\n    const movieRows = searchResultsDiv[1].match(\n      /<search-page-media-row[^>]*>(.*?)<\\/search-page-media-row>/gs,\n    );\n    if (!movieRows || movieRows.length === 0) return null;\n\n    // Convert movie rows to structured data\n    const movies = movieRows.map((row) => {\n      const nameMatch = row.match(/data-qa=\"info-name\"[^>]*>([^<]+)</);\n      const urlMatch = row.match(/href=\"([^\"]+)\"/);\n      const scoreMatch = row.match(/tomatometerscore=\"([^\"]+)\"/);\n      const sentimentMatch = row.match(/tomatometersentiment=\"([^\"]+)\"/);\n      const yearMatch = row.match(/releaseyear=\"([^\"]+)\"/);\n      const tomatometeriscertified = row.match(\n        /tomatometeriscertified=\"([^\"]+)\"/,\n      );\n\n      return {\n        name: nameMatch ? nameMatch[1].trim() : \"\",\n        url: urlMatch ? urlMatch[1] : \"\",\n        year: yearMatch ? parseInt(yearMatch[1], 10) : null,\n        tomatometer: {\n          value: scoreMatch ? parseInt(scoreMatch[1], 10) : 0,\n          state:\n            sentimentMatch &&\n            tomatometeriscertified?.[1] === \"true\" &&\n            parseInt(scoreMatch?.[1] || \"0\", 10) >= 75\n              ? \"certified_fresh\"\n              : sentimentMatch\n                ? sentimentMatch[1].toLowerCase() === \"positive\"\n                  ? \"fresh\"\n                  : \"rotten\"\n                : \"rotten\",\n        },\n      };\n    });\n\n    // Try to find the best matching movie\n    const match = findBestMatch(title, movies, year);\n\n    if (!match) return null;\n\n    // Extract the movie data\n    return {\n      title: match.name,\n      tomatoIcon: match.tomatometer?.state || \"rotten\",\n      tomatoScore: match.tomatometer?.value || 0,\n      url: `https://www.rottentomatoes.com${match.url}`,\n    };\n  } catch (error) {\n    console.error(\"Error parsing Rotten Tomatoes data:\", error);\n    return null;\n  }\n}\n\nexport function getRTIcon(\n  type: \"certified_fresh\" | \"fresh\" | \"rotten\",\n): string {\n  switch (type) {\n    case \"certified_fresh\":\n      return \"/tomatoes/Certified_Fresh.svg\";\n    case \"fresh\":\n      return \"/tomatoes/Fresh.svg\";\n    case \"rotten\":\n      return \"/tomatoes/Rotten.svg\";\n    default:\n      return \"/tomatoes/Rotten.svg\";\n  }\n}\n","import { useEffect, useState } from \"react\";\n\nimport { usePlayerMeta } from \"@/components/player/hooks/usePlayerMeta\";\nimport { conf } from \"@/setup/config\";\nimport { usePreferencesStore } from \"@/stores/preferences\";\n\n// Thanks Nemo for this API\nconst BASE_URL = \"https://skips.pstream.org\";\nconst MAX_RETRIES = 3;\n\nexport function useSkipTime() {\n  const { playerMeta: meta } = usePlayerMeta();\n  const [skiptime, setSkiptime] = useState<number | null>(null);\n  const febboxKey = usePreferencesStore((s) => s.febboxKey);\n\n  useEffect(() => {\n    const fetchSkipTime = async (retries = 0): Promise<void> => {\n      if (!meta?.imdbId || meta.type === \"movie\") return;\n      if (!conf().ALLOW_FEBBOX_KEY) return;\n      if (!febboxKey) return;\n\n      try {\n        const apiUrl = `${BASE_URL}/${meta.imdbId}/${meta.season?.number}/${meta.episode?.number}`;\n        const response = await fetch(apiUrl);\n\n        if (!response.ok) {\n          if (response.status === 500 && retries < MAX_RETRIES) {\n            return fetchSkipTime(retries + 1);\n          }\n          throw new Error(\"API request failed\");\n        }\n\n        const data = await response.json();\n\n        const parseSkipTime = (timeStr: string | undefined): number | null => {\n          if (!timeStr || typeof timeStr !== \"string\") return null;\n          const match = timeStr.match(/^(\\d+)s$/);\n          if (!match) return null;\n          return parseInt(match[1], 10);\n        };\n\n        const skipTime = parseSkipTime(data.introSkipTime);\n\n        // eslint-disable-next-line no-console\n        console.log(\"Skip time:\", skipTime);\n        setSkiptime(skipTime);\n      } catch (error) {\n        console.error(\"Error fetching skip time:\", error);\n        setSkiptime(null);\n      }\n    };\n\n    fetchSkipTime();\n  }, [\n    meta?.tmdbId,\n    meta?.imdbId,\n    meta?.type,\n    meta?.season?.number,\n    meta?.episode?.number,\n    febboxKey,\n  ]);\n\n  return skiptime;\n}\n","export const APP_VERSION = import.meta.env.PACKAGE_VERSION;\nexport const DISCORD_LINK = \"https://discord.gg/7z6znYgrTG\";\nexport const GITHUB_LINK = \"https://github.com/p-stream/p-strean\";\nexport const GA_ID = import.meta.env.VITE_GA_ID;\nexport const BACKEND_URL = import.meta.env.VITE_BACKEND_URL;\n","import {\n  APP_VERSION,\n  BACKEND_URL,\n  DISCORD_LINK,\n  GITHUB_LINK,\n} from \"./constants\";\n\ninterface Config {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string;\n  TMDB_READ_API_KEY: string;\n  CORS_PROXY_URL: string;\n  NORMAL_ROUTER: boolean;\n  BACKEND_URL: string;\n  DISALLOWED_IDS: string;\n  TURNSTILE_KEY: string;\n  CDN_REPLACEMENTS: string;\n  HAS_ONBOARDING: string;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string;\n  ONBOARDING_PROXY_INSTALL_LINK: string;\n}\n\nexport interface RuntimeConfig {\n  APP_VERSION: string;\n  GITHUB_LINK: string;\n  DISCORD_LINK: string;\n  DMCA_EMAIL: string | null;\n  TMDB_READ_API_KEY: string;\n  NORMAL_ROUTER: boolean;\n  PROXY_URLS: string[];\n  BACKEND_URL: string;\n  DISALLOWED_IDS: string[];\n  TURNSTILE_KEY: string | null;\n  CDN_REPLACEMENTS: Array<string[]>;\n  HAS_ONBOARDING: boolean;\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: string | null;\n  ONBOARDING_PROXY_INSTALL_LINK: string | null;\n}\n\nconst env: Record<keyof Config, undefined | string> = {\n  TMDB_READ_API_KEY: import.meta.env.VITE_TMDB_READ_API_KEY,\n  APP_VERSION: undefined,\n  GITHUB_LINK: undefined,\n  DISCORD_LINK: undefined,\n  ONBOARDING_CHROME_EXTENSION_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_CHROME_EXTENSION_INSTALL_LINK,\n  ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK,\n  ONBOARDING_PROXY_INSTALL_LINK: import.meta.env\n    .VITE_ONBOARDING_PROXY_INSTALL_LINK,\n  DMCA_EMAIL: import.meta.env.VITE_DMCA_EMAIL,\n  CORS_PROXY_URL: import.meta.env.VITE_CORS_PROXY_URL,\n  NORMAL_ROUTER: import.meta.env.VITE_NORMAL_ROUTER,\n  BACKEND_URL: import.meta.env.VITE_BACKEND_URL,\n  DISALLOWED_IDS: import.meta.env.VITE_DISALLOWED_IDS,\n  TURNSTILE_KEY: import.meta.env.VITE_TURNSTILE_KEY,\n  CDN_REPLACEMENTS: import.meta.env.VITE_CDN_REPLACEMENTS,\n  HAS_ONBOARDING: import.meta.env.VITE_HAS_ONBOARDING,\n};\n\n// loads from different locations, in order: environment (VITE_{KEY}), window (public/config.js)\nfunction getKeyValue(key: keyof Config): string | undefined {\n  let windowValue = (window as any)?.__CONFIG__?.[`VITE_${key}`];\n  if (\n    windowValue !== null &&\n    windowValue !== undefined &&\n    windowValue.length === 0\n  )\n    windowValue = undefined;\n  return env[key] ?? windowValue ?? undefined;\n}\n\nfunction getKey(key: keyof Config, defaultString?: string): string {\n  return getKeyValue(key)?.toString() ?? defaultString ?? \"\";\n}\n\nexport function conf(): RuntimeConfig {\n  const dmcaEmail = getKey(\"DMCA_EMAIL\");\n  const chromeExtension = getKey(\"ONBOARDING_CHROME_EXTENSION_INSTALL_LINK\");\n  const firefoxExtension = getKey(\"ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK\");\n  const proxyInstallLink = getKey(\"ONBOARDING_PROXY_INSTALL_LINK\");\n  const turnstileKey = getKey(\"TURNSTILE_KEY\");\n  return {\n    APP_VERSION,\n    GITHUB_LINK,\n    DISCORD_LINK,\n    DMCA_EMAIL: dmcaEmail.length > 0 ? dmcaEmail : null,\n    ONBOARDING_CHROME_EXTENSION_INSTALL_LINK:\n      chromeExtension.length > 0 ? chromeExtension : null,\n    ONBOARDING_FIREFOX_EXTENSION_INSTALL_LINK:\n      firefoxExtension.length > 0 ? firefoxExtension : null,\n    ONBOARDING_PROXY_INSTALL_LINK:\n      proxyInstallLink.length > 0 ? proxyInstallLink : null,\n    BACKEND_URL: getKey(\"BACKEND_URL\", BACKEND_URL),\n    TMDB_READ_API_KEY: getKey(\"TMDB_READ_API_KEY\"),\n    PROXY_URLS: getKey(\"CORS_PROXY_URL\")\n      .split(\",\")\n      .map((v) => v.trim()),\n    NORMAL_ROUTER: getKey(\"NORMAL_ROUTER\", \"false\") === \"true\",\n    HAS_ONBOARDING: getKey(\"HAS_ONBOARDING\", \"false\") === \"true\",\n    TURNSTILE_KEY: turnstileKey.length > 0 ? turnstileKey : null,\n    DISALLOWED_IDS: getKey(\"DISALLOWED_IDS\", \"\")\n      .split(\",\")\n      .map((v) => v.trim())\n      .filter((v) => v.length > 0), // Should be comma-seperated and contain the media type and ID, formatted like so: movie-753342,movie-753342,movie-753342\n    CDN_REPLACEMENTS: getKey(\"CDN_REPLACEMENTS\", \"\")\n      .split(\",\")\n      .map((v) =>\n        v\n          .split(\":\")\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0),\n      )\n      .filter((v) => v.length === 2), // The format is <beforeA>:<afterA>,<beforeB>:<afterB>\n  };\n}\n","import { conf } from \"@/utils/setup/config\";\n\nexport interface TmdbMovie {\n  adult: boolean;\n  backdrop_path: string | null;\n  genre_ids: number[];\n  id: number;\n  original_language: string;\n  original_title: string;\n  overview: string;\n  popularity: number;\n  poster_path: string | null;\n  release_date: string;\n  title: string;\n  video: boolean;\n  vote_average: number;\n  vote_count: number;\n}\n\nexport interface ListMetadata {\n  originalFilmCount: number;\n  foundTmdbMovies: number;\n  expectedItemCount: number | null;\n  workingSelector: string;\n}\n\nexport interface LetterboxdList {\n  listName: string;\n  listUrl: string;\n  tmdbMovies: TmdbMovie[];\n  metadata: ListMetadata;\n}\n\nexport interface LetterboxdResponse {\n  lists: LetterboxdList[];\n}\n\n// Base function to fetch from Letterboxd API\nasync function fetchFromLetterboxd<T = LetterboxdResponse>(\n  endpoint: string,\n): Promise<T> {\n  const response = await fetch(`${conf().BACKEND_URL}${endpoint}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch from ${endpoint}: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n// Get Letterboxd lists with TMDB movie information\nexport const getLetterboxdLists = () => fetchFromLetterboxd(\"/letterboxd\");\n","import { useEffect, useState } from \"react\";\nimport { generatePath, useNavigate, useParams } from \"react-router-dom\";\n\nfunction decode(query: string | null | undefined) {\n  return query ? decodeURIComponent(query) : \"\";\n}\n\nexport function useSearchQuery(): [\n  string,\n  (inp: string, force?: boolean) => void,\n  () => void,\n] {\n  const navigate = useNavigate();\n  const params = useParams<{ query: string }>();\n  const [search, setSearch] = useState(decode(params.query));\n\n  useEffect(() => {\n    setSearch(decode(params.query));\n  }, [params.query]);\n\n  const updateParams = (inp: string, commitToUrl = false) => {\n    setSearch(inp);\n    if (!commitToUrl) return;\n    if (inp.length === 0) {\n      navigate(\"/\", { replace: true });\n      return;\n    }\n    navigate(\n      generatePath(\"/browse/:query\", {\n        query: inp,\n      }),\n      { replace: true },\n    );\n  };\n\n  const onUnFocus = (newSearch?: string) => {\n    updateParams(newSearch ?? search, true);\n  };\n\n  return [search, updateParams, onUnFocus];\n}\n","import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\ntype Category = \"movies\" | \"tvshows\" | \"editorpicks\";\n\ninterface DiscoverView {\n  url: string;\n  scrollPosition: number;\n}\n\ninterface DiscoverState {\n  selectedCategory: Category;\n  lastView: DiscoverView | null;\n  setSelectedCategory: (category: Category) => void;\n  setLastView: (view: DiscoverView) => void;\n  clearLastView: () => void;\n}\n\nexport const useDiscoverStore = create<DiscoverState>()(\n  persist(\n    (set) => ({\n      selectedCategory: \"movies\",\n      lastView: null,\n      setSelectedCategory: (category) => set({ selectedCategory: category }),\n      setLastView: (view) => set({ lastView: view }),\n      clearLastView: () => set({ lastView: null }),\n    }),\n    {\n      name: \"__MW::discover\",\n    },\n  ),\n);\n","import { useCallback, useEffect, useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n\nimport { get } from \"@/backend/metadata/tmdb\";\nimport {\n  GENRE_TO_TRAKT_MAP,\n  PROVIDER_TO_TRAKT_MAP,\n  TraktLatestResponse,\n  getActionReleases,\n  getAppleTVReleases,\n  getDisneyReleases,\n  getDramaReleases,\n  getHBOReleases,\n  getHuluReleases,\n  getLatest4KReleases,\n  getLatestReleases,\n  getLatestTVReleases,\n  getNetflixMovies,\n  getNetflixTVShows,\n  getPrimeReleases,\n  paginateResults,\n} from \"@/backend/metadata/traktApi\";\nimport { conf } from \"@/setup/config\";\nimport { useLanguageStore } from \"@/stores/language\";\nimport { getTmdbLanguageCode } from \"@/utils/language\";\n\n// Shuffle array utility\nconst shuffleArray = <T>(array: T[]): T[] => {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n};\n\n// Editor Picks lists\nexport const EDITOR_PICKS_MOVIES = shuffleArray([\n  { id: 9342, type: \"movie\" }, // The Mask of Zorro\n  { id: 293, type: \"movie\" }, // A River Runs Through It\n  { id: 370172, type: \"movie\" }, // No Time To Die\n  { id: 661374, type: \"movie\" }, // The Glass Onion\n  { id: 207, type: \"movie\" }, // Dead Poets Society\n  { id: 378785, type: \"movie\" }, // The Best of the Blues Brothers\n  { id: 335984, type: \"movie\" }, // Blade Runner 2049\n  { id: 13353, type: \"movie\" }, // It's the Great Pumpkin, Charlie Brown\n  { id: 27205, type: \"movie\" }, // Inception\n  { id: 106646, type: \"movie\" }, // The Wolf of Wall Street\n  { id: 334533, type: \"movie\" }, // Captain Fantastic\n  { id: 693134, type: \"movie\" }, // Dune: Part Two\n  { id: 765245, type: \"movie\" }, // Swan Song\n  { id: 264660, type: \"movie\" }, // Ex Machina\n  { id: 92591, type: \"movie\" }, // Bernie\n  { id: 976893, type: \"movie\" }, // Perfect Days\n  { id: 13187, type: \"movie\" }, // A Charlie Brown Christmas\n  { id: 11527, type: \"movie\" }, // Excalibur\n  { id: 120, type: \"movie\" }, // LOTR: The Fellowship of the Ring\n  { id: 157336, type: \"movie\" }, // Interstellar\n  { id: 762, type: \"movie\" }, // Monty Python and the Holy Grail\n  { id: 666243, type: \"movie\" }, // The Witcher: Nightmare of the Wolf\n  { id: 545611, type: \"movie\" }, // Everything Everywhere All at Once\n  { id: 329, type: \"movie\" }, // Jurrassic Park\n  { id: 330459, type: \"movie\" }, // Rogue One: A Star Wars Story\n  { id: 279, type: \"movie\" }, // Amadeus\n  { id: 823219, type: \"movie\" }, // Flow\n  { id: 22, type: \"movie\" }, // Pirates of the Caribbean: The Curse of the Black Pearl\n  { id: 18971, type: \"movie\" }, // Rosencrantz and Guildenstern Are Dead\n  { id: 26388, type: \"movie\" }, // Buried\n  { id: 152601, type: \"movie\" }, // Her\n]);\n\nexport const EDITOR_PICKS_TV_SHOWS = shuffleArray([\n  { id: 456, type: \"show\" }, // The Simpsons\n  { id: 73021, type: \"show\" }, // Disenchantment\n  { id: 1434, type: \"show\" }, // Family Guy\n  { id: 1695, type: \"show\" }, // Monk\n  { id: 1408, type: \"show\" }, // House\n  { id: 93740, type: \"show\" }, // Foundation\n  { id: 60625, type: \"show\" }, // Rick and Morty\n  { id: 1396, type: \"show\" }, // Breaking Bad\n  { id: 44217, type: \"show\" }, // Vikings\n  { id: 90228, type: \"show\" }, // Dune Prophecy\n  { id: 13916, type: \"show\" }, // Death Note\n  { id: 71912, type: \"show\" }, // The Witcher\n  { id: 61222, type: \"show\" }, // Bojack Horseman\n  { id: 93405, type: \"show\" }, // Squid Game\n  { id: 87108, type: \"show\" }, // Chernobyl\n  { id: 105248, type: \"show\" }, // Cyberpunk: Edgerunners\n]);\n\n/**\n * The type of content to fetch from various endpoints\n */\nexport type DiscoverContentType =\n  | \"popular\"\n  | \"topRated\"\n  | \"onTheAir\"\n  | \"nowPlaying\"\n  | \"latest\"\n  | \"latest4k\"\n  | \"latesttv\"\n  | \"genre\"\n  | \"provider\"\n  | \"editorPicks\"\n  | \"recommendations\";\n\n/**\n * The type of media to fetch (movie or TV show)\n */\nexport type MediaType = \"movie\" | \"tv\";\n\n/**\n * Props for the useDiscoverMedia hook\n */\nexport interface UseDiscoverMediaProps {\n  /** The type of content to fetch */\n  contentType: DiscoverContentType;\n  /** Whether to fetch movies or TV shows */\n  mediaType: MediaType;\n  /** ID used for genre, provider, or recommendations */\n  id?: string;\n  /** Fallback content type if primary fails */\n  fallbackType?: DiscoverContentType;\n  /** Page number for paginated results */\n  page?: number;\n  /** Genre name for display in title */\n  genreName?: string;\n  /** Provider name for display in title */\n  providerName?: string;\n  /** Media title for recommendations display */\n  mediaTitle?: string;\n  /** Whether this is for a carousel view (limits results) */\n  isCarouselView?: boolean;\n}\n\n/**\n * Media item returned from discover endpoints\n */\nexport interface DiscoverMedia {\n  /** TMDB ID of the media */\n  id: number;\n  /** Title for movies */\n  title: string;\n  /** Title for TV shows */\n  name?: string;\n  /** Poster image path */\n  poster_path: string;\n  /** Backdrop image path */\n  backdrop_path: string;\n  /** Release date for movies */\n  release_date?: string;\n  /** First air date for TV shows */\n  first_air_date?: string;\n  /** Media overview/description */\n  overview: string;\n  /** Average vote score (0-10) */\n  vote_average: number;\n  /** Number of votes */\n  vote_count: number;\n  /** Type of media (movie or show) */\n  type?: \"movie\" | \"show\";\n}\n\n/**\n * Return type of the useDiscoverMedia hook\n */\nexport interface UseDiscoverMediaReturn {\n  /** Array of media items */\n  media: DiscoverMedia[];\n  /** Whether media is currently being fetched */\n  isLoading: boolean;\n  /** Error message if fetch failed */\n  error: string | null;\n  /** Whether there are more pages to load */\n  hasMore: boolean;\n  /** Function to refetch the current media */\n  refetch: () => Promise<void>;\n  /** Localized section title for the media carousel */\n  sectionTitle: string;\n}\n\n/**\n * Provider interface for streaming services\n */\nexport interface Provider {\n  /** Provider name (e.g., \"Netflix\", \"Hulu\") */\n  name: string;\n  /** Provider ID from TMDB */\n  id: string;\n}\n\n/**\n * Genre interface for media categorization\n */\nexport interface Genre {\n  /** Genre ID from TMDB */\n  id: number;\n  /** Genre name (e.g., \"Action\", \"Drama\") */\n  name: string;\n}\n\n// Static provider lists\nexport const MOVIE_PROVIDERS: Provider[] = [\n  { name: \"Netflix\", id: \"8\" },\n  { name: \"Apple TV+\", id: \"2\" },\n  { name: \"Amazon Prime Video\", id: \"10\" },\n  { name: \"Hulu\", id: \"15\" },\n  { name: \"Disney Plus\", id: \"337\" },\n  { name: \"Max\", id: \"1899\" },\n  { name: \"Paramount Plus\", id: \"531\" },\n  { name: \"Shudder\", id: \"99\" },\n  { name: \"Crunchyroll\", id: \"283\" },\n  { name: \"fuboTV\", id: \"257\" },\n  { name: \"AMC+\", id: \"526\" },\n  { name: \"Starz\", id: \"43\" },\n  { name: \"Lifetime\", id: \"157\" },\n  { name: \"National Geographic\", id: \"1964\" },\n];\n\nexport const TV_PROVIDERS: Provider[] = [\n  { name: \"Netflix\", id: \"8\" },\n  { name: \"Apple TV+\", id: \"350\" },\n  { name: \"Amazon Prime Video\", id: \"10\" },\n  { name: \"Paramount Plus\", id: \"531\" },\n  { name: \"Hulu\", id: \"15\" },\n  { name: \"Max\", id: \"1899\" },\n  { name: \"Adult Swim\", id: \"318\" },\n  { name: \"Disney Plus\", id: \"337\" },\n  { name: \"Crunchyroll\", id: \"283\" },\n  { name: \"fuboTV\", id: \"257\" },\n  { name: \"Shudder\", id: \"99\" },\n  { name: \"Discovery +\", id: \"520\" },\n  { name: \"National Geographic\", id: \"1964\" },\n  { name: \"Fox\", id: \"328\" },\n];\n\n/**\n * Hook for managing providers and genres\n */\nexport function useDiscoverOptions(mediaType: MediaType) {\n  const [genres, setGenres] = useState<Genre[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const userLanguage = useLanguageStore.getState().language;\n  const formattedLanguage = getTmdbLanguageCode(userLanguage);\n\n  const providers = mediaType === \"movie\" ? MOVIE_PROVIDERS : TV_PROVIDERS;\n\n  useEffect(() => {\n    const fetchGenres = async () => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const data = await get<any>(`/genre/${mediaType}/list`, {\n          api_key: conf().TMDB_READ_API_KEY,\n          language: formattedLanguage,\n        });\n        setGenres(data.genres.slice(0, 50));\n      } catch (err) {\n        console.error(`Error fetching ${mediaType} genres:`, err);\n        setError((err as Error).message);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchGenres();\n  }, [mediaType, formattedLanguage]);\n\n  return {\n    genres,\n    providers,\n    isLoading,\n    error,\n  };\n}\n\nexport function useDiscoverMedia({\n  contentType,\n  mediaType,\n  id,\n  fallbackType,\n  page = 1,\n  genreName,\n  providerName,\n  mediaTitle,\n  isCarouselView = false,\n}: UseDiscoverMediaProps): UseDiscoverMediaReturn {\n  const [media, setMedia] = useState<DiscoverMedia[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [hasMore, setHasMore] = useState(true);\n  const [sectionTitle, setSectionTitle] = useState<string>(\"\");\n  const [currentContentType, setCurrentContentType] =\n    useState<string>(contentType);\n\n  const { t } = useTranslation();\n  const userLanguage = useLanguageStore.getState().language;\n  const formattedLanguage = getTmdbLanguageCode(userLanguage);\n\n  // Reset media when content type or media type changes\n  useEffect(() => {\n    if (contentType !== currentContentType) {\n      setMedia([]);\n      setCurrentContentType(contentType);\n    }\n  }, [contentType, currentContentType]);\n\n  const fetchTMDBMedia = useCallback(\n    async (endpoint: string, params: Record<string, any> = {}) => {\n      try {\n        // For carousel views, we only need one page of results\n        if (isCarouselView) {\n          params.page = \"1\"; // Always use first page for carousels\n        } else {\n          params.page = page.toString(); // Use the requested page for \"view more\" pages\n        }\n\n        const data = await get<any>(endpoint, {\n          api_key: conf().TMDB_READ_API_KEY,\n          language: formattedLanguage,\n          ...params,\n        });\n\n        // For carousel views, we might want to limit the number of results\n        const results = isCarouselView\n          ? data.results.slice(0, 20)\n          : data.results;\n\n        return {\n          results: results.map((item: any) => ({\n            ...item,\n            type: mediaType === \"movie\" ? \"movie\" : \"show\",\n          })),\n          hasMore: page < data.total_pages,\n        };\n      } catch (err) {\n        console.error(\"Error fetching TMDB media:\", err);\n        throw err;\n      }\n    },\n    [formattedLanguage, page, mediaType, isCarouselView],\n  );\n\n  const fetchTraktMedia = useCallback(\n    async (traktFunction: () => Promise<TraktLatestResponse>) => {\n      try {\n        // Create a timeout promise\n        const timeoutPromise = new Promise<TraktLatestResponse>((_, reject) => {\n          setTimeout(() => reject(new Error(\"Trakt request timed out\")), 3000);\n        });\n\n        // Race between the Trakt request and timeout\n        const response = await Promise.race([traktFunction(), timeoutPromise]);\n\n        // Paginate the results\n        const pageSize = isCarouselView ? 20 : 100; // Limit to 20 items for carousels, get more for detailed views\n        const { tmdb_ids: tmdbIds, hasMore: hasMoreResults } = paginateResults(\n          response,\n          page,\n          pageSize,\n        );\n\n        // For carousel views, we only need to fetch details for displayed items\n        const idsToFetch = isCarouselView ? tmdbIds.slice(0, 20) : tmdbIds;\n\n        // Fetch details for each TMDB ID\n        const mediaPromises = idsToFetch.map(async (tmdbId: number) => {\n          const endpoint = `/${mediaType}/${tmdbId}`;\n          try {\n            const data = await get<any>(endpoint, {\n              api_key: conf().TMDB_READ_API_KEY,\n              language: formattedLanguage,\n            });\n            return {\n              ...data,\n              type: mediaType === \"movie\" ? \"movie\" : \"show\",\n            };\n          } catch (err) {\n            console.error(`Error fetching details for TMDB ID ${tmdbId}:`, err);\n            return null; // Return null for failed items\n          }\n        });\n\n        // Use Promise.allSettled to handle failed requests gracefully\n        const settledResults = await Promise.allSettled(mediaPromises);\n\n        // Filter out failed requests and nulls\n        const results = settledResults\n          .filter(\n            (result): result is PromiseFulfilledResult<any> =>\n              result.status === \"fulfilled\" && result.value !== null,\n          )\n          .map((result) => result.value);\n\n        return {\n          results,\n          hasMore: hasMoreResults,\n        };\n      } catch (err) {\n        console.error(\"Error fetching Trakt media:\", err);\n        throw err;\n      }\n    },\n    [mediaType, formattedLanguage, page, isCarouselView],\n  );\n\n  // Get Trakt function for provider\n  const getTraktProviderFunction = useCallback(\n    (providerId: string) => {\n      const trakt =\n        PROVIDER_TO_TRAKT_MAP[providerId as keyof typeof PROVIDER_TO_TRAKT_MAP];\n      if (!trakt) return null;\n\n      // Handle TV vs Movies for Netflix\n      if (trakt === \"netflix\" && mediaType === \"tv\") {\n        return getNetflixTVShows;\n      }\n      if (trakt === \"netflix\" && mediaType === \"movie\") {\n        return getNetflixMovies;\n      }\n\n      // Map provider to corresponding Trakt function\n      switch (trakt) {\n        case \"appletv\":\n          return getAppleTVReleases;\n        case \"prime\":\n          return getPrimeReleases;\n        case \"hulu\":\n          return getHuluReleases;\n        case \"disney\":\n          return getDisneyReleases;\n        case \"hbo\":\n          return getHBOReleases;\n        default:\n          return null;\n      }\n    },\n    [mediaType],\n  );\n\n  // Get Trakt function for genre\n  const getTraktGenreFunction = useCallback((genreId: string) => {\n    const trakt =\n      GENRE_TO_TRAKT_MAP[genreId as keyof typeof GENRE_TO_TRAKT_MAP];\n    if (!trakt) return null;\n\n    switch (trakt) {\n      case \"action\":\n        return getActionReleases;\n      case \"drama\":\n        return getDramaReleases;\n      default:\n        return null;\n    }\n  }, []);\n\n  const fetchEditorPicks = useCallback(async () => {\n    const picks =\n      mediaType === \"movie\" ? EDITOR_PICKS_MOVIES : EDITOR_PICKS_TV_SHOWS;\n\n    // For carousel views, limit the number of picks to fetch\n    const picksToFetch = isCarouselView ? picks.slice(0, 20) : picks;\n\n    try {\n      const mediaPromises = picksToFetch.map(async (item) => {\n        const endpoint = `/${mediaType}/${item.id}`;\n        const data = await get<any>(endpoint, {\n          api_key: conf().TMDB_READ_API_KEY,\n          language: formattedLanguage,\n          append_to_response: \"videos,images\",\n        });\n        return {\n          ...data,\n          type: item.type,\n        };\n      });\n\n      const results = await Promise.all(mediaPromises);\n      return {\n        results,\n        hasMore: picks.length > picksToFetch.length,\n      };\n    } catch (err) {\n      console.error(\"Error fetching editor picks:\", err);\n      throw err;\n    }\n  }, [mediaType, formattedLanguage, isCarouselView]);\n\n  const fetchMedia = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n\n    const attemptFetch = async (type: DiscoverContentType) => {\n      let data;\n      let traktGenreFunction;\n      let traktProviderFunction;\n\n      // Map content types to their endpoints and handling logic\n      switch (type) {\n        case \"popular\":\n          data = await fetchTMDBMedia(`/${mediaType}/popular`);\n          setSectionTitle(t(\"discover.carousel.title.popular\"));\n          break;\n\n        case \"topRated\":\n          data = await fetchTMDBMedia(`/${mediaType}/top_rated`);\n          setSectionTitle(t(\"discover.carousel.title.topRated\"));\n          break;\n\n        case \"onTheAir\":\n          if (mediaType === \"tv\") {\n            data = await fetchTMDBMedia(\"/tv/on_the_air\");\n            setSectionTitle(t(\"discover.carousel.title.onTheAir\"));\n          } else {\n            throw new Error(\"onTheAir is only available for TV shows\");\n          }\n          break;\n\n        case \"nowPlaying\":\n          if (mediaType === \"movie\") {\n            data = await fetchTMDBMedia(\"/movie/now_playing\");\n            setSectionTitle(t(\"discover.carousel.title.inCinemas\"));\n          } else {\n            throw new Error(\"nowPlaying is only available for movies\");\n          }\n          break;\n\n        case \"latest\":\n          data = await fetchTraktMedia(getLatestReleases);\n          setSectionTitle(t(\"discover.carousel.title.latestReleases\"));\n          break;\n\n        case \"latest4k\":\n          data = await fetchTraktMedia(getLatest4KReleases);\n          setSectionTitle(t(\"discover.carousel.title.4kReleases\"));\n          break;\n\n        case \"latesttv\":\n          data = await fetchTraktMedia(getLatestTVReleases);\n          setSectionTitle(t(\"discover.carousel.title.latestTVReleases\"));\n          break;\n\n        case \"genre\":\n          if (!id) throw new Error(\"Genre ID is required\");\n\n          // Try to use Trakt genre endpoint if available\n          traktGenreFunction = getTraktGenreFunction(id);\n          if (traktGenreFunction) {\n            try {\n              data = await fetchTraktMedia(traktGenreFunction);\n              setSectionTitle(\n                mediaType === \"movie\"\n                  ? t(\"discover.carousel.title.movies\", { category: genreName })\n                  : t(\"discover.carousel.title.tvshows\", {\n                      category: genreName,\n                    }),\n              );\n            } catch (traktErr) {\n              console.error(\n                \"Trakt genre fetch failed, falling back to TMDB:\",\n                traktErr,\n              );\n              // Fall back to TMDB\n              data = await fetchTMDBMedia(`/discover/${mediaType}`, {\n                with_genres: id,\n              });\n              setSectionTitle(\n                mediaType === \"movie\"\n                  ? t(\"discover.carousel.title.movies\", { category: genreName })\n                  : t(\"discover.carousel.title.tvshows\", {\n                      category: genreName,\n                    }),\n              );\n            }\n          } else {\n            // Use TMDB if no Trakt endpoint exists for this genre\n            data = await fetchTMDBMedia(`/discover/${mediaType}`, {\n              with_genres: id,\n            });\n            setSectionTitle(\n              mediaType === \"movie\"\n                ? t(\"discover.carousel.title.movies\", { category: genreName })\n                : t(\"discover.carousel.title.tvshows\", { category: genreName }),\n            );\n          }\n          break;\n\n        case \"provider\":\n          if (!id) throw new Error(\"Provider ID is required\");\n\n          // Try to use Trakt provider endpoint if available\n          traktProviderFunction = getTraktProviderFunction(id);\n          if (traktProviderFunction) {\n            try {\n              data = await fetchTraktMedia(traktProviderFunction);\n              setSectionTitle(\n                mediaType === \"movie\"\n                  ? t(\"discover.carousel.title.moviesOn\", {\n                      provider: providerName,\n                    })\n                  : t(\"discover.carousel.title.tvshowsOn\", {\n                      provider: providerName,\n                    }),\n              );\n            } catch (traktErr) {\n              console.error(\n                \"Trakt provider fetch failed, falling back to TMDB:\",\n                traktErr,\n              );\n              // Fall back to TMDB\n              data = await fetchTMDBMedia(`/discover/${mediaType}`, {\n                with_watch_providers: id,\n                watch_region: \"US\",\n              });\n              setSectionTitle(\n                mediaType === \"movie\"\n                  ? t(\"discover.carousel.title.moviesOn\", {\n                      provider: providerName,\n                    })\n                  : t(\"discover.carousel.title.tvshowsOn\", {\n                      provider: providerName,\n                    }),\n              );\n            }\n          } else {\n            // Use TMDB if no Trakt endpoint exists for this provider\n            data = await fetchTMDBMedia(`/discover/${mediaType}`, {\n              with_watch_providers: id,\n              watch_region: \"US\",\n            });\n            setSectionTitle(\n              mediaType === \"movie\"\n                ? t(\"discover.carousel.title.moviesOn\", {\n                    provider: providerName,\n                  })\n                : t(\"discover.carousel.title.tvshowsOn\", {\n                    provider: providerName,\n                  }),\n            );\n          }\n          break;\n\n        case \"recommendations\":\n          if (!id) throw new Error(\"Media ID is required for recommendations\");\n          data = await fetchTMDBMedia(`/${mediaType}/${id}/recommendations`);\n          setSectionTitle(\n            t(\"discover.carousel.title.recommended\", { title: mediaTitle }),\n          );\n          break;\n\n        case \"editorPicks\":\n          data = await fetchEditorPicks();\n          setSectionTitle(\n            mediaType === \"movie\"\n              ? t(\"discover.carousel.title.editorPicksMovies\")\n              : t(\"discover.carousel.title.editorPicksShows\"),\n          );\n          break;\n\n        default:\n          throw new Error(`Unsupported content type: ${type}`);\n      }\n\n      return data;\n    };\n\n    try {\n      const data = await attemptFetch(contentType);\n      setMedia((prevMedia) => {\n        // If page is 1, replace the media array, otherwise append\n        return page === 1 ? data.results : [...prevMedia, ...data.results];\n      });\n      setHasMore(data.hasMore);\n    } catch (err) {\n      console.error(\"Error fetching media:\", err);\n      setError((err as Error).message);\n\n      // Try fallback content type if available\n      if (fallbackType && fallbackType !== contentType) {\n        console.info(`Falling back from ${contentType} to ${fallbackType}`);\n        try {\n          const fallbackData = await attemptFetch(fallbackType);\n          setMedia((prevMedia) => {\n            // If page is 1, replace the media array, otherwise append\n            return page === 1\n              ? fallbackData.results\n              : [...prevMedia, ...fallbackData.results];\n          });\n          setHasMore(fallbackData.hasMore);\n          setError(null); // Clear error if fallback succeeds\n        } catch (fallbackErr) {\n          console.error(\"Error fetching fallback media:\", fallbackErr);\n          setError((fallbackErr as Error).message);\n        }\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [\n    contentType,\n    mediaType,\n    id,\n    fallbackType,\n    genreName,\n    providerName,\n    mediaTitle,\n    fetchTMDBMedia,\n    fetchTraktMedia,\n    fetchEditorPicks,\n    t,\n    page,\n    getTraktGenreFunction,\n    getTraktProviderFunction,\n  ]);\n\n  useEffect(() => {\n    // Reset media when content type, media type, or id changes\n    if (contentType !== currentContentType || page === 1) {\n      setMedia([]);\n      setCurrentContentType(contentType);\n    }\n    fetchMedia();\n  }, [fetchMedia, contentType, currentContentType, page, id]);\n\n  return {\n    media,\n    isLoading,\n    error,\n    hasMore,\n    refetch: fetchMedia,\n    sectionTitle,\n  };\n}\n","import { useEffect, useState } from \"react\";\n\nexport function useDebounce<T>(value: T, delay: number): T {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","import { useCallback, useMemo } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n\n// 35% chance of getting a joke title (Cooper done changed this code!)\nconst shouldGiveJokeTitle = () => Math.random() < 0.35;\n\nexport function useRandomTranslation() {\n  const { t } = useTranslation();\n  const shouldJoke = useMemo(() => shouldGiveJokeTitle(), []);\n  const seed = useMemo(() => Math.random(), []);\n\n  const getRandomTranslation = useCallback(\n    (key: string): string => {\n      const defaultTitle = t(`${key}.default`) ?? \"\";\n      if (!shouldJoke) return defaultTitle;\n\n      const keys = t(`${key}.extra`, {\n        returnObjects: true,\n        defaultValue: defaultTitle,\n      });\n      if (Array.isArray(keys)) {\n        if (keys.length === 0) return defaultTitle;\n        return keys[Math.floor(seed * keys.length)];\n      }\n\n      return typeof keys === \"string\" ? keys : defaultTitle;\n    },\n    [t, seed, shouldJoke],\n  );\n\n  return { t: getRandomTranslation };\n}\n","import { useCallback } from \"react\";\n\n// import { SessionResponse } from \"@/backend/accounts/auth\";\nimport { bookmarkMediaToInput } from \"@/backend/accounts/bookmarks\";\nimport {\n  base64ToBuffer,\n  bytesToBase64,\n  bytesToBase64Url,\n  encryptData,\n  // keysFromMnemonic,\n  keysFromSeed,\n  signChallenge,\n} from \"@/backend/accounts/crypto\";\nimport { importBookmarks, importProgress } from \"@/backend/accounts/import\";\n// import { getLoginChallengeToken, loginAccount } from \"@/backend/accounts/login\";\nimport { progressMediaItemToInputs } from \"@/backend/accounts/progress\";\nimport {\n  getRegisterChallengeToken,\n  registerAccount,\n} from \"@/backend/accounts/register\";\n// import { removeSession } from \"@/backend/accounts/sessions\";\n// import { getSettings } from \"@/backend/accounts/settings\";\n// import {\n//   UserResponse,\n//   getBookmarks,\n//   getProgress,\n//   getUser,\n// } from \"@/backend/accounts/user\";\nimport { useAuthData } from \"@/hooks/auth/useAuthData\";\n// import { useBackendUrl } from \"@/hooks/auth/useBackendUrl\";\nimport { AccountWithToken, useAuthStore } from \"@/stores/auth\";\nimport { BookmarkMediaItem, useBookmarkStore } from \"@/stores/bookmarks\";\nimport { ProgressMediaItem, useProgressStore } from \"@/stores/progress\";\n\nexport interface RegistrationData {\n  recaptchaToken?: string;\n  mnemonic: string;\n  userData: {\n    device: string;\n    profile: {\n      colorA: string;\n      colorB: string;\n      icon: string;\n    };\n  };\n}\n\nexport interface LoginData {\n  mnemonic: string;\n  userData: {\n    device: string;\n  };\n}\n\nexport function useMigration() {\n  const currentAccount = useAuthStore((s) => s.account);\n  const progress = useProgressStore((s) => s.items);\n  const bookmarks = useBookmarkStore((s) => s.bookmarks);\n  const { login: userDataLogin } = useAuthData();\n\n  const importData = async (\n    backendUrl: string,\n    account: AccountWithToken,\n    progressItems: Record<string, ProgressMediaItem>,\n    bookmarkItems: Record<string, BookmarkMediaItem>,\n  ) => {\n    if (\n      Object.keys(progressItems).length === 0 &&\n      Object.keys(bookmarkItems).length === 0\n    ) {\n      return;\n    }\n\n    const progressInputs = Object.entries(progressItems).flatMap(\n      ([tmdbId, item]) => progressMediaItemToInputs(tmdbId, item),\n    );\n\n    const bookmarkInputs = Object.entries(bookmarkItems).map(([tmdbId, item]) =>\n      bookmarkMediaToInput(tmdbId, item),\n    );\n\n    await Promise.all([\n      importProgress(backendUrl, account, progressInputs),\n      importBookmarks(backendUrl, account, bookmarkInputs),\n    ]);\n  };\n\n  const migrate = useCallback(\n    async (backendUrl: string, recaptchaToken?: string) => {\n      if (!currentAccount) return;\n\n      const { challenge } = await getRegisterChallengeToken(\n        backendUrl,\n        recaptchaToken || undefined, // Pass undefined if token is not provided\n      );\n      const keys = await keysFromSeed(base64ToBuffer(currentAccount.seed));\n      const signature = await signChallenge(keys, challenge);\n      const registerResult = await registerAccount(backendUrl, {\n        challenge: {\n          code: challenge,\n          signature,\n        },\n        publicKey: bytesToBase64Url(keys.publicKey),\n        device: await encryptData(currentAccount.deviceName, keys.seed),\n        profile: currentAccount.profile,\n      });\n\n      const account = await userDataLogin(\n        registerResult,\n        registerResult.user,\n        registerResult.session,\n        bytesToBase64(keys.seed),\n      );\n\n      await importData(backendUrl, account, progress, bookmarks);\n\n      return account;\n    },\n    [currentAccount, userDataLogin, bookmarks, progress],\n  );\n\n  return {\n    migrate,\n  };\n}\n","import { useCallback } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nimport { useQueryParam } from \"@/hooks/useQueryParams\";\nimport { useOnboardingStore } from \"@/stores/onboarding\";\n\nexport function useRedirectBack() {\n  const [url] = useQueryParam(\"redirect\");\n  const navigate = useNavigate();\n  const setCompleted = useOnboardingStore((s) => s.setCompleted);\n\n  const redirectBack = useCallback(() => {\n    navigate(url ?? \"/\");\n  }, [navigate, url]);\n\n  const completeAndRedirect = useCallback(() => {\n    setCompleted(true);\n    redirectBack();\n  }, [redirectBack, setCompleted]);\n\n  return { completeAndRedirect };\n}\n\nexport function useNavigateOnboarding() {\n  const navigate = useNavigate();\n  const loc = useLocation();\n  const nav = useCallback(\n    (path: string) => {\n      navigate({\n        pathname: path,\n        search: loc.search,\n      });\n    },\n    [navigate, loc],\n  );\n  return nav;\n}\n","import { isAllowedExtensionVersion } from \"@/backend/extension/compatibility\";\nimport { extensionInfo } from \"@/backend/extension/messaging\";\n\nexport type ExtensionStatus =\n  | \"unknown\"\n  | \"failed\"\n  | \"disallowed\"\n  | \"noperms\"\n  | \"outdated\"\n  | \"success\";\n\nexport async function getExtensionState(): Promise<ExtensionStatus> {\n  const info = await extensionInfo();\n  if (!info) return \"unknown\"; // cant talk to extension\n  if (!info.success) return \"failed\"; // extension failed to respond\n  if (!info.allowed) return \"disallowed\"; // extension is not enabled on this page\n  if (!info.hasPermission) return \"noperms\"; // extension has no perms to do it's tasks\n  if (!isAllowedExtensionVersion(info.version)) return \"outdated\"; // extension is too old\n  return \"success\"; // no problems\n}\n","import { useEffect, useMemo } from \"react\";\nimport { useLocation } from \"react-router-dom\";\nimport { useEffectOnce } from \"react-use\";\nimport { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\n\ninterface HistoryRoute {\n  path: string;\n}\n\ninterface HistoryStore {\n  routes: HistoryRoute[];\n  registerRoute(route: HistoryRoute): void;\n}\n\nexport const useHistoryStore = create(\n  immer<HistoryStore>((set) => ({\n    routes: [],\n    registerRoute(route) {\n      set((s) => {\n        s.routes.push(route);\n      });\n    },\n  })),\n);\n\nexport function useHistoryListener() {\n  const location = useLocation();\n  const registerRoute = useHistoryStore((s) => s.registerRoute);\n  useEffect(() => {\n    registerRoute({ path: location.pathname });\n  }, [location.pathname, registerRoute]);\n\n  useEffectOnce(() => {\n    registerRoute({ path: location.pathname });\n  });\n}\n\nexport function useLastNonPlayerLink() {\n  const routes = useHistoryStore((s) => s.routes);\n  const location = useLocation();\n  const lastNonPlayerLink = useMemo(() => {\n    const reversedRoutes = [...routes];\n    reversedRoutes.reverse();\n    const route = reversedRoutes.find(\n      (v) =>\n        !v.path.startsWith(\"/media\") && // cannot be a player link\n        location.pathname !== v.path && // cannot be current link\n        !v.path.startsWith(\"/s/\") && // cannot be a quick search link\n        !v.path.startsWith(\"/onboarding\"), // cannot be an onboarding link\n    );\n    return route?.path ?? \"/\";\n  }, [routes, location]);\n  return lastNonPlayerLink;\n}\n"],"file":"assets/index-Bhg6ALQw.js"}